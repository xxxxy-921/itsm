{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/syntax-tree.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/syntax-tree.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { TokenType } from 'chevrotain';\r\nimport type { URI } from './utils/uri-utils.js';\r\nimport type { AbstractElement } from './languages/generated/ast.js';\r\nimport type { DocumentSegment, LangiumDocument } from './workspace/documents.js';\r\n\r\n/**\r\n * A node in the Abstract Syntax Tree (AST).\r\n */\r\nexport interface AstNode {\r\n    /** Every AST node has a type corresponding to what was specified in the grammar declaration. */\r\n    readonly $type: string;\r\n    /** The container node in the AST; every node except the root node has a container. */\r\n    readonly $container?: AstNode;\r\n    /** The property of the `$container` node that contains this node. This is either a direct reference or an array. */\r\n    readonly $containerProperty?: string;\r\n    /** In case `$containerProperty` is an array, the array index is stored here. */\r\n    readonly $containerIndex?: number;\r\n    /** The Concrete Syntax Tree (CST) node of the text range from which this node was parsed. */\r\n    readonly $cstNode?: CstNode;\r\n    /** The document containing the AST; only the root node has a direct reference to the document. */\r\n    readonly $document?: LangiumDocument;\r\n}\r\n\r\nexport function isAstNode(obj: unknown): obj is AstNode {\r\n    return typeof obj === 'object' && obj !== null && typeof (obj as AstNode).$type === 'string';\r\n}\r\n\r\nexport interface GenericAstNode extends AstNode {\r\n    [key: string]: unknown\r\n}\r\n\r\ntype SpecificNodeProperties<N extends AstNode> = keyof Omit<N, keyof AstNode | number | symbol>;\r\n\r\n/**\r\n * The property names of a given AST node type.\r\n */\r\nexport type Properties<N extends AstNode> = SpecificNodeProperties<N> extends never ? string : SpecificNodeProperties<N>\r\n\r\n/**\r\n * A cross-reference in the AST. Cross-references may or may not be successfully resolved.\r\n */\r\nexport interface Reference<T extends AstNode = AstNode> {\r\n    /**\r\n     * The target AST node of this reference. Accessing this property may trigger cross-reference\r\n     * resolution by the `Linker` in case it has not been done yet. If the reference cannot be resolved,\r\n     * the value is `undefined`.\r\n     */\r\n    readonly ref?: T;\r\n\r\n    /** If any problem occurred while resolving the reference, it is described by this property. */\r\n    readonly error?: LinkingError;\r\n    /** The CST node from which the reference was parsed */\r\n    readonly $refNode?: CstNode;\r\n    /** The actual text used to look up in the surrounding scope */\r\n    readonly $refText: string;\r\n    /** The node description for the AstNode returned by `ref`  */\r\n    readonly $nodeDescription?: AstNodeDescription;\r\n}\r\n\r\nexport function isReference(obj: unknown): obj is Reference {\r\n    return typeof obj === 'object' && obj !== null && typeof (obj as Reference).$refText === 'string';\r\n}\r\n\r\nexport type ResolvedReference<T extends AstNode = AstNode> = Reference<T> & {\r\n    readonly ref: T;\r\n}\r\n\r\n/**\r\n * A description of an AST node is used when constructing scopes and looking up cross-reference targets.\r\n */\r\nexport interface AstNodeDescription {\r\n    /** The target node; should be present only for local references (linking to the same document). */\r\n    node?: AstNode;\r\n    /**\r\n     * The document segment that represents the range of the name of the AST node.\r\n     */\r\n    nameSegment?: DocumentSegment;\r\n    /**\r\n     * The document segment that represents the full range of the AST node.\r\n     */\r\n    selectionSegment?: DocumentSegment;\r\n    /** `$type` property value of the AST node */\r\n    type: string;\r\n    /** Name of the AST node; this is usually determined by the `NameProvider` service. */\r\n    name: string;\r\n    /** URI to the document containing the AST node */\r\n    documentUri: URI;\r\n    /** Navigation path inside the document */\r\n    path: string;\r\n}\r\n\r\nexport function isAstNodeDescription(obj: unknown): obj is AstNodeDescription {\r\n    return typeof obj === 'object' && obj !== null\r\n        && typeof (obj as AstNodeDescription).name === 'string'\r\n        && typeof (obj as AstNodeDescription).type === 'string'\r\n        && typeof (obj as AstNodeDescription).path === 'string';\r\n}\r\n\r\n/**\r\n * Information about a cross-reference. This is used when traversing references in an AST or to describe\r\n * unresolved references.\r\n */\r\nexport interface ReferenceInfo {\r\n    reference: Reference\r\n    container: AstNode\r\n    property: string\r\n    index?: number\r\n}\r\n\r\n/**\r\n * Used to collect information when the `Linker` service fails to resolve a cross-reference.\r\n */\r\nexport interface LinkingError extends ReferenceInfo {\r\n    message: string;\r\n    targetDescription?: AstNodeDescription;\r\n}\r\n\r\nexport function isLinkingError(obj: unknown): obj is LinkingError {\r\n    return typeof obj === 'object' && obj !== null\r\n        && isAstNode((obj as LinkingError).container)\r\n        && isReference((obj as LinkingError).reference)\r\n        && typeof (obj as LinkingError).message === 'string';\r\n}\r\n\r\n/**\r\n * Service used for generic access to the structure of the AST. This service is shared between\r\n * all involved languages, so it operates on the superset of types of these languages.\r\n */\r\nexport interface AstReflection {\r\n    getAllTypes(): string[]\r\n    getAllSubTypes(type: string): string[]\r\n    getReferenceType(refInfo: ReferenceInfo): string\r\n    getTypeMetaData(type: string): TypeMetaData\r\n    isInstance(node: unknown, type: string): boolean\r\n    isSubtype(subtype: string, supertype: string): boolean\r\n}\r\n\r\n/**\r\n * An abstract implementation of the {@link AstReflection} interface.\r\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\r\n */\r\nexport abstract class AbstractAstReflection implements AstReflection {\r\n\r\n    protected subtypes: Record<string, Record<string, boolean | undefined>> = {};\r\n    protected allSubtypes: Record<string, string[] | undefined> = {};\r\n\r\n    abstract getAllTypes(): string[];\r\n    abstract getReferenceType(refInfo: ReferenceInfo): string;\r\n    abstract getTypeMetaData(type: string): TypeMetaData;\r\n    protected abstract computeIsSubtype(subtype: string, supertype: string): boolean;\r\n\r\n    isInstance(node: unknown, type: string): boolean {\r\n        return isAstNode(node) && this.isSubtype(node.$type, type);\r\n    }\r\n\r\n    isSubtype(subtype: string, supertype: string): boolean {\r\n        if (subtype === supertype) {\r\n            return true;\r\n        }\r\n        let nested = this.subtypes[subtype];\r\n        if (!nested) {\r\n            nested = this.subtypes[subtype] = {};\r\n        }\r\n        const existing = nested[supertype];\r\n        if (existing !== undefined) {\r\n            return existing;\r\n        } else {\r\n            const result = this.computeIsSubtype(subtype, supertype);\r\n            nested[supertype] = result;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    getAllSubTypes(type: string): string[] {\r\n        const existing = this.allSubtypes[type];\r\n        if (existing) {\r\n            return existing;\r\n        } else {\r\n            const allTypes = this.getAllTypes();\r\n            const types: string[] = [];\r\n            for (const possibleSubType of allTypes) {\r\n                if (this.isSubtype(possibleSubType, type)) {\r\n                    types.push(possibleSubType);\r\n                }\r\n            }\r\n            this.allSubtypes[type] = types;\r\n            return types;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents runtime meta data about a meta model type.\r\n */\r\nexport interface TypeMetaData {\r\n    /** The name of this meta model type. Corresponds to the `AstNode.$type` value. */\r\n    name: string\r\n    /** A list of properties. They can contain default values for their respective property in the AST. */\r\n    properties: TypeProperty[]\r\n}\r\n\r\n/**\r\n * Describes the meta data of a property of an AST node.\r\n *\r\n * The optional `defaultValue` indicates that the property is mandatory in the AST node.\r\n * For example, if an AST node contains an array, but no elements of this array have been parsed, we still expect an empty array instead of `undefined`.\r\n */\r\nexport interface TypeProperty {\r\n    name: string\r\n    defaultValue?: PropertyType\r\n}\r\n\r\n/**\r\n * Represents a default value for an AST property.\r\n */\r\nexport type PropertyType = number | string | boolean | PropertyType[];\r\n\r\n/**\r\n * A node in the Concrete Syntax Tree (CST).\r\n */\r\nexport interface CstNode extends DocumentSegment {\r\n    /** The container node in the CST */\r\n    readonly container?: CompositeCstNode;\r\n    /** @deprecated use `container` instead. */\r\n    readonly parent?: CompositeCstNode;\r\n    /** The actual text */\r\n    readonly text: string;\r\n    /** The root CST node */\r\n    readonly root: RootCstNode;\r\n    /** The grammar element from which this node was parsed */\r\n    readonly grammarSource?: AbstractElement;\r\n    /** @deprecated use `grammarSource` instead. */\r\n    readonly feature?: AbstractElement;\r\n    /** The AST node created from this CST node */\r\n    readonly astNode: AstNode;\r\n    /** @deprecated use `astNode` instead. */\r\n    readonly element: AstNode;\r\n    /** Whether the token is hidden, i.e. not explicitly part of the containing grammar rule */\r\n    readonly hidden: boolean;\r\n}\r\n\r\n/**\r\n * A composite CST node contains other nodes, but no directly associated token.\r\n */\r\nexport interface CompositeCstNode extends CstNode {\r\n    readonly content: CstNode[];\r\n    /** @deprecated use `content` instead. */\r\n    readonly children: CstNode[];\r\n}\r\n\r\nexport function isCompositeCstNode(node: unknown): node is CompositeCstNode {\r\n    return typeof node === 'object' && node !== null && Array.isArray((node as CompositeCstNode).content);\r\n}\r\n\r\n/**\r\n * A leaf CST node corresponds to a token in the input token stream.\r\n */\r\nexport interface LeafCstNode extends CstNode {\r\n    readonly tokenType: TokenType;\r\n}\r\n\r\nexport function isLeafCstNode(node: unknown): node is LeafCstNode {\r\n    return typeof node === 'object' && node !== null && typeof (node as LeafCstNode).tokenType === 'object';\r\n}\r\n\r\nexport interface RootCstNode extends CompositeCstNode {\r\n    readonly fullText: string\r\n}\r\n\r\nexport function isRootCstNode(node: unknown): node is RootCstNode {\r\n    return isCompositeCstNode(node) && typeof (node as RootCstNode).fullText === 'string';\r\n}\r\n\r\n/**\r\n * Returns a type to have only properties names (!) of a type T whose property value is of a certain type K.\r\n */\r\ntype ExtractKeysOfValueType<T, K> = { [I in keyof T]: T[I] extends K ? I : never }[keyof T];\r\n\r\n/**\r\n * Returns the property names (!) of an AstNode that are cross-references.\r\n * Meant to be used during cross-reference resolution in combination with `assertUnreachable(context.property)`.\r\n */\r\nexport type CrossReferencesOfAstNodeType<N extends AstNode> = (\r\n    ExtractKeysOfValueType<N, Reference|undefined>\r\n    | ExtractKeysOfValueType<N, Array<Reference|undefined>|undefined>\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\n) & {};\r\n\r\n/**\r\n * Represents the enumeration-like type, that lists all AstNode types of your grammar.\r\n */\r\nexport type AstTypeList<T> = Record<keyof T, AstNode>;\r\n\r\n/**\r\n * Returns all types that contain cross-references, A is meant to be the interface `XXXAstType` fromm your generated `ast.ts` file.\r\n * Meant to be used during cross-reference resolution in combination with `assertUnreachable(context.container)`.\r\n */\r\nexport type AstNodeTypesWithCrossReferences<A extends AstTypeList<A>> = {\r\n    [T in keyof A]: CrossReferencesOfAstNodeType<A[T]> extends never ? never : A[T]\r\n}[keyof A];\r\n\r\nexport type Mutable<T> = {\r\n    -readonly [P in keyof T]: T[P]\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/stream.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/stream.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/**\r\n * A stream is a read-only sequence of values. While the contents of an array can be accessed\r\n * both sequentially and randomly (via index), a stream allows only sequential access.\r\n *\r\n * The advantage of this is that a stream can be evaluated lazily, so it does not require\r\n * to store intermediate values. This can boost performance when a large sequence is\r\n * processed via filtering, mapping etc. and accessed at most once. However, lazy\r\n * evaluation means that all processing is repeated when you access the sequence multiple\r\n * times; in such a case, it may be better to store the resulting sequence into an array.\r\n */\r\nexport interface Stream<T> extends Iterable<T> {\r\n\r\n    /**\r\n     * Returns an iterator for this stream. This is the same as calling the `Symbol.iterator` function property.\r\n     */\r\n    iterator(): IterableIterator<T>;\r\n\r\n    /**\r\n     * Determines whether this stream contains no elements.\r\n     */\r\n    isEmpty(): boolean;\r\n\r\n    /**\r\n     * Determines the number of elements in this stream.\r\n     */\r\n    count(): number;\r\n\r\n    /**\r\n     * Collects all elements of this stream into an array.\r\n     */\r\n    toArray(): T[];\r\n\r\n    /**\r\n     * Collects all elements of this stream into a Set.\r\n     */\r\n    toSet(): Set<T>;\r\n\r\n    /**\r\n     * Collects all elements of this stream into a Map, applying the provided functions to determine keys and values.\r\n     *\r\n     * @param keyFn The function to derive map keys. If omitted, the stream elements are used as keys.\r\n     * @param valueFn The function to derive map values. If omitted, the stream elements are used as values.\r\n     */\r\n    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V>;\r\n\r\n    /**\r\n     * Returns a string representation of a stream.\r\n     */\r\n    toString(): string;\r\n\r\n    /**\r\n     * Combines two streams by returning a new stream that yields all elements of this stream and the other stream.\r\n     *\r\n     * @param other Stream to be concatenated with this one.\r\n     */\r\n    concat<T2>(other: Iterable<T2>): Stream<T | T2>;\r\n\r\n    /**\r\n     * Adds all elements of the stream into a string, separated by the specified separator string.\r\n     *\r\n     * @param separator A string used to separate one element of the stream from the next in the resulting string.\r\n     *        If omitted, the steam elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in the stream, or -1 if it is not present.\r\n     *\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The stream index at which to begin the search. If fromIndex is omitted, the search\r\n     *        starts at index 0.\r\n     */\r\n    indexOf(searchElement: T, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Determines whether all members of the stream satisfy the specified test.\r\n     *\r\n     * @param predicate This method calls the predicate function for each element in the stream until the\r\n     *        predicate returns a value which is coercible to the Boolean value `false`, or until the end\r\n     *        of the stream.\r\n     */\r\n    every<S extends T>(predicate: (value: T) => value is S): this is Stream<S>;\r\n    every(predicate: (value: T) => unknown): boolean;\r\n\r\n    /**\r\n     * Determines whether any member of the stream satisfies the specified test.\r\n     *\r\n     * @param predicate This method calls the predicate function for each element in the stream until the\r\n     *        predicate returns a value which is coercible to the Boolean value `true`, or until the end\r\n     *        of the stream.\r\n     */\r\n    some(predicate: (value: T) => unknown): boolean;\r\n\r\n    /**\r\n     * Performs the specified action for each element in the stream.\r\n     *\r\n     * @param callbackfn Function called once for each element in the stream.\r\n     */\r\n    forEach(callbackfn: (value: T, index: number) => void): void;\r\n\r\n    /**\r\n     * Returns a stream that yields the results of calling the specified callback function on each element\r\n     * of the stream. The function is called when the resulting stream elements are actually accessed, so\r\n     * accessing the resulting stream multiple times means the function is also called multiple times for\r\n     * each element of the stream.\r\n     *\r\n     * @param callbackfn Lazily evaluated function mapping stream elements.\r\n     */\r\n    map<U>(callbackfn: (value: T) => U): Stream<U>;\r\n\r\n    /**\r\n     * Returns the elements of the stream that meet the condition specified in a callback function.\r\n     * The function is called when the resulting stream elements are actually accessed, so accessing the\r\n     * resulting stream multiple times means the function is also called multiple times for each element\r\n     * of the stream.\r\n     *\r\n     * @param predicate Lazily evaluated function checking a condition on stream elements.\r\n     */\r\n    filter<S extends T>(predicate: (value: T) => value is S): Stream<S>;\r\n    filter(predicate: (value: T) => unknown): Stream<T>;\r\n\r\n    /**\r\n     * Returns the elements of the stream that are _non-nullable_, which means they are neither `undefined`\r\n     * nor `null`.\r\n     */\r\n    nonNullable(): Stream<NonNullable<T>>;\r\n\r\n    /**\r\n     * Calls the specified callback function for all elements in the stream. The return value of the\r\n     * callback function is the accumulated result, and is provided as an argument in the next call to\r\n     * the callback function.\r\n     *\r\n     * @param callbackfn This method calls the function once for each element in the stream, providing\r\n     *        the previous and current values of the reduction.\r\n     * @param initialValue If specified, `initialValue` is used as the initial value to start the\r\n     *        accumulation. The first call to the function provides this value as an argument instead\r\n     *        of a stream value.\r\n     */\r\n    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\r\n    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all elements in the stream, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     *\r\n     * @param callbackfn This method calls the function once for each element in the stream, providing\r\n     *        the previous and current values of the reduction.\r\n     * @param initialValue If specified, `initialValue` is used as the initial value to start the\r\n     *        accumulation. The first call to the function provides this value as an argument instead\r\n     *        of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\r\n    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Returns the value of the first element in the stream that meets the condition, or `undefined`\r\n     * if there is no such element.\r\n     *\r\n     * @param predicate This method calls `predicate` once for each element of the stream, in ascending\r\n     *        order, until it finds one where `predicate` returns a value which is coercible to the\r\n     *        Boolean value `true`.\r\n     */\r\n    find<S extends T>(predicate: (value: T) => value is S): S | undefined;\r\n    find(predicate: (value: T) => unknown): T | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the stream that meets the condition, or `-1`\r\n     * if there is no such element.\r\n     *\r\n     * @param predicate This method calls `predicate` once for each element of the stream, in ascending\r\n     *        order, until it finds one where `predicate` returns a value which is coercible to the\r\n     *        Boolean value `true`.\r\n     */\r\n    findIndex(predicate: (value: T) => unknown): number;\r\n\r\n    /**\r\n     * Determines whether the stream includes a certain element, returning `true` or `false` as appropriate.\r\n     *\r\n     * @param searchElement The element to search for.\r\n     */\r\n    includes(searchElement: T): boolean;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of the stream and then flattens the result into\r\n     * a new stream. This is identical to a `map` followed by `flat` with depth 1.\r\n     *\r\n     * @param callbackfn Lazily evaluated function mapping stream elements.\r\n     */\r\n    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U>;\r\n\r\n    /**\r\n     * Returns a new stream with all sub-stream or sub-array elements concatenated into it recursively up\r\n     * to the specified depth.\r\n     *\r\n     * @param depth The maximum recursion depth. Defaults to 1.\r\n     */\r\n    flat<D extends number = 1>(depth?: D): FlatStream<T, D>;\r\n\r\n    /**\r\n     * Returns the first element in the stream, or `undefined` if the stream is empty.\r\n     */\r\n    head(): T | undefined;\r\n\r\n    /**\r\n     * Returns a stream that skips the first `skipCount` elements from this stream.\r\n     *\r\n     * @param skipCount The number of elements to skip. If this is larger than the number of elements in\r\n     *        the stream, an empty stream is returned. Defaults to 1.\r\n     */\r\n    tail(skipCount?: number): Stream<T>;\r\n\r\n    /**\r\n     * Returns a stream consisting of the elements of this stream, truncated to be no longer than `maxSize`\r\n     * in length.\r\n     *\r\n     * @param maxSize The number of elements the stream should be limited to\r\n     */\r\n    limit(maxSize: number): Stream<T>;\r\n\r\n    /**\r\n     * Returns a stream containing only the distinct elements from this stream.\r\n     * Equality is determined with the same rules as a standard `Set`.\r\n     *\r\n     * @param by A function returning the key used to check equality with a previous stream element.\r\n     *        If omitted, the stream elements themselves are used for comparison.\r\n     */\r\n    distinct<Key = T>(by?: (element: T) => Key): Stream<T>;\r\n\r\n    /**\r\n     * Returns a stream that contains all elements that don't exist in the {@link other} iterable.\r\n     * Equality is determined with the same rules as a standard `Set`.\r\n     * @param other The elements that should be exluded from this stream.\r\n     * @param key A function returning the key used to check quality.\r\n     *        If omitted, the stream elements themselves are used for comparison.\r\n     */\r\n    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T>;\r\n\r\n}\r\n\r\nexport type FlatStream<T, Depth extends number> = {\r\n    'done': Stream<T>,\r\n    'recur': T extends Iterable<infer Content>\r\n        ? FlatStream<Content, MinusOne<Depth>>\r\n        : Stream<T>\r\n}[Depth extends 0 ? 'done' : 'recur'];\r\n\r\nexport type MinusOne<N extends number> = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20][N];\r\n\r\n/**\r\n * The default implementation of `Stream` works with two input functions:\r\n *  - The first function creates the initial state of an iteration.\r\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\r\n */\r\nexport class StreamImpl<S, T> implements Stream<T> {\r\n    protected readonly startFn: () => S;\r\n    protected readonly nextFn: (state: S) => IteratorResult<T>;\r\n\r\n    constructor(startFn: () => S, nextFn: (state: S) => IteratorResult<T, undefined>) {\r\n        this.startFn = startFn;\r\n        this.nextFn = nextFn;\r\n    }\r\n\r\n    iterator(): IterableIterator<T> {\r\n        const iterator = {\r\n            state: this.startFn(),\r\n            next: () => this.nextFn(iterator.state),\r\n            [Symbol.iterator]: () => iterator\r\n        };\r\n        return iterator;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<T> {\r\n        return this.iterator();\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        const iterator = this.iterator();\r\n        return Boolean(iterator.next().done);\r\n    }\r\n\r\n    count(): number {\r\n        const iterator = this.iterator();\r\n        let count = 0;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            count++;\r\n            next = iterator.next();\r\n        }\r\n        return count;\r\n    }\r\n\r\n    toArray(): T[] {\r\n        const result: T[] = [];\r\n        const iterator = this.iterator();\r\n        let next: IteratorResult<T>;\r\n        do {\r\n            next = iterator.next();\r\n            if (next.value !== undefined) {\r\n                result.push(next.value);\r\n            }\r\n        } while (!next.done);\r\n        return result;\r\n    }\r\n\r\n    toSet(): Set<T> {\r\n        return new Set(this);\r\n    }\r\n\r\n    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V> {\r\n        const entryStream = this.map(element => <[K, V]>[\r\n            keyFn ? keyFn(element) : element,\r\n            valueFn ? valueFn(element) : element\r\n        ]);\r\n        return new Map(entryStream);\r\n    }\r\n\r\n    toString(): string {\r\n        return this.join();\r\n    }\r\n\r\n    concat<T2>(other: Iterable<T2>): Stream<T | T2> {\r\n        return new StreamImpl<{ first: S, firstDone: boolean, iterator: Iterator<T2, unknown, undefined> }, T | T2>(\r\n            () => ({ first: this.startFn(), firstDone: false, iterator: other[Symbol.iterator]() }),\r\n            state => {\r\n                let result: IteratorResult<T | T2>;\r\n                if (!state.firstDone) {\r\n                    do {\r\n                        result = this.nextFn(state.first);\r\n                        if (!result.done) {\r\n                            return result;\r\n                        }\r\n                    } while (!result.done);\r\n                    state.firstDone = true;\r\n                }\r\n                do {\r\n                    result = state.iterator.next();\r\n                    if (!result.done) {\r\n                        return result;\r\n                    }\r\n                } while (!result.done);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    join(separator = ','): string {\r\n        const iterator = this.iterator();\r\n        let value = '';\r\n        let result: IteratorResult<T>;\r\n        let addSeparator = false;\r\n        do {\r\n            result = iterator.next();\r\n            if (!result.done) {\r\n                if (addSeparator) {\r\n                    value += separator;\r\n                }\r\n                value += toString(result.value);\r\n            }\r\n            addSeparator = true;\r\n        } while (!result.done);\r\n        return value;\r\n    }\r\n\r\n    indexOf(searchElement: T, fromIndex = 0): number {\r\n        const iterator = this.iterator();\r\n        let index = 0;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (index >= fromIndex && next.value === searchElement) {\r\n                return index;\r\n            }\r\n            next = iterator.next();\r\n            index++;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    // In the following definition the '& this' part in the return type is important\r\n    // _and_ the order within 'Stream<U> & this' is crucial!\r\n    // Otherwise Typescript would infer the type of 'this' as 'StreamImpl<S, T> & Stream<U>'\r\n    // (or '<subClass of StreamImpl<S, T> & Stream<U>') and usages like\r\n    // ```\r\n    //  const stream = new StreamImpl(...);\r\n    //  ... stream.every(<typeGuard>) & stream....\r\n    // ```\r\n    // cannot benefit from '<typeGuard>', as Typescript would priorize the signatures\r\n    // of 'StreamImpl<S, T>' (i.e. those of 'Stream<T>') over those of 'Stream<U>'.\r\n    // With the order of 'Stream<U> & this' the signatures of 'Stream<U>' get precedence.\r\n    every<U extends T>(predicate: (value: T) => value is U): this is Stream<U> & this;\r\n    every(predicate: (value: T) => unknown): boolean;\r\n    every(predicate: (value: T) => unknown): boolean {\r\n        const iterator = this.iterator();\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (!predicate(next.value)) {\r\n                return false;\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    some(predicate: (value: T) => unknown): boolean {\r\n        const iterator = this.iterator();\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (predicate(next.value)) {\r\n                return true;\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    forEach(callbackfn: (value: T, index: number) => void): void {\r\n        const iterator = this.iterator();\r\n        let index = 0;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            callbackfn(next.value, index);\r\n            next = iterator.next();\r\n            index++;\r\n        }\r\n    }\r\n\r\n    map<U>(callbackfn: (value: T) => U): Stream<U> {\r\n        return new StreamImpl<S, U>(\r\n            this.startFn,\r\n            (state) => {\r\n                const { done, value } = this.nextFn(state);\r\n                if (done) {\r\n                    return DONE_RESULT;\r\n                } else {\r\n                    return { done: false, value: callbackfn(value) };\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    // for remarks on the return type definition refer to 'every<U extends T>(...)'\r\n    filter<U extends T>(predicate: (value: T) => value is U): Stream<U> & this;\r\n    filter(predicate: (value: T) => unknown): Stream<T> & this;\r\n    filter(predicate: (value: T) => unknown): Stream<T> {\r\n        return new StreamImpl<S, T>(\r\n            this.startFn,\r\n            state => {\r\n                let result: IteratorResult<T>;\r\n                do {\r\n                    result = this.nextFn(state);\r\n                    if (!result.done && predicate(result.value)) {\r\n                        return result;\r\n                    }\r\n                } while (!result.done);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    nonNullable(): Stream<NonNullable<T>> {\r\n        return this.filter(e => e !== undefined && e !== null) as Stream<NonNullable<T>>;\r\n    }\r\n\r\n    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\r\n    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\r\n    reduce<U>(callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\r\n        const iterator = this.iterator();\r\n        let previousValue: U | T | undefined = initialValue;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (previousValue === undefined) {\r\n                previousValue = next.value;\r\n            } else {\r\n                previousValue = callbackfn(previousValue, next.value);\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return previousValue;\r\n    }\r\n\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\r\n    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\r\n    reduceRight<U>(callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\r\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\r\n    }\r\n\r\n    protected recursiveReduce<U>(iterator: Iterator<T>, callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\r\n        const next = iterator.next();\r\n        if (next.done) {\r\n            return initialValue;\r\n        }\r\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\r\n        if (previousValue === undefined) {\r\n            return next.value;\r\n        }\r\n        return callbackfn(previousValue, next.value);\r\n    }\r\n\r\n    find<S extends T>(predicate: (value: T) => value is S): S | undefined;\r\n    find(predicate: (value: T) => unknown): T | undefined;\r\n    find(predicate: (value: T) => unknown): T | undefined {\r\n        const iterator = this.iterator();\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (predicate(next.value)) {\r\n                return next.value;\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    findIndex(predicate: (value: T) => unknown): number {\r\n        const iterator = this.iterator();\r\n        let index = 0;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (predicate(next.value)) {\r\n                return index;\r\n            }\r\n            next = iterator.next();\r\n            index++;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    includes(searchElement: T): boolean {\r\n        const iterator = this.iterator();\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (next.value === searchElement) {\r\n                return true;\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U> {\r\n        type FlatMapState = { this: S, iterator?: Iterator<U, undefined> }\r\n        return new StreamImpl<FlatMapState, U>(\r\n            () => ({ this: this.startFn() }),\r\n            (state) => {\r\n                do {\r\n                    if (state.iterator) {\r\n                        const next = state.iterator.next();\r\n                        if (next.done) {\r\n                            state.iterator = undefined;\r\n                        } else {\r\n                            return next;\r\n                        }\r\n                    }\r\n                    const { done, value } = this.nextFn(state.this);\r\n                    if (!done) {\r\n                        const mapped = callbackfn(value);\r\n                        if (isIterable(mapped)) {\r\n                            state.iterator = mapped[Symbol.iterator]();\r\n                        } else {\r\n                            return { done: false, value: mapped };\r\n                        }\r\n                    }\r\n                } while (state.iterator);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    flat<D extends number = 1>(depth?: D): FlatStream<T, D> {\r\n        if (depth === undefined) {\r\n            depth = 1 as D;\r\n        }\r\n        if (depth <= 0) {\r\n            return this as unknown as FlatStream<T, D>;\r\n        }\r\n        const stream = depth > 1 ? this.flat(depth - 1) as unknown as StreamImpl<S, T> : this;\r\n        type FlatMapState = { this: S, iterator?: Iterator<T, undefined> }\r\n        return new StreamImpl<FlatMapState, T>(\r\n            () => ({ this: stream.startFn() }),\r\n            (state) => {\r\n                do {\r\n                    if (state.iterator) {\r\n                        const next = state.iterator.next();\r\n                        if (next.done) {\r\n                            state.iterator = undefined;\r\n                        } else {\r\n                            return next;\r\n                        }\r\n                    }\r\n                    const { done, value } = stream.nextFn(state.this);\r\n                    if (!done) {\r\n                        if (isIterable(value)) {\r\n                            state.iterator = value[Symbol.iterator]() as Iterator<T>;\r\n                        } else {\r\n                            return { done: false, value: value };\r\n                        }\r\n                    }\r\n                } while (state.iterator);\r\n                return DONE_RESULT;\r\n            }\r\n        ) as unknown as FlatStream<T, D>;\r\n    }\r\n\r\n    head(): T | undefined {\r\n        const iterator = this.iterator();\r\n        const result = iterator.next();\r\n        if (result.done) {\r\n            return undefined;\r\n        }\r\n        return result.value;\r\n    }\r\n\r\n    tail(skipCount = 1): Stream<T> {\r\n        return new StreamImpl<S, T>(\r\n            () => {\r\n                const state = this.startFn();\r\n                for (let i = 0; i < skipCount; i++) {\r\n                    const next = this.nextFn(state);\r\n                    if (next.done) {\r\n                        return state;\r\n                    }\r\n                }\r\n                return state;\r\n            },\r\n            this.nextFn\r\n        );\r\n    }\r\n\r\n    limit(maxSize: number): Stream<T> {\r\n        return new StreamImpl<{ size: number, state: S }, T>(\r\n            () => ({ size: 0, state: this.startFn() }),\r\n            state => {\r\n                state.size++;\r\n                if (state.size > maxSize) {\r\n                    return DONE_RESULT;\r\n                }\r\n                return this.nextFn(state.state);\r\n            }\r\n        );\r\n    }\r\n\r\n    distinct<Key = T>(by?: (element: T) => Key): Stream<T> {\r\n        return new StreamImpl<{ set: Set<Key | T>, internalState: S }, T>(\r\n            () => ({ set: new Set<Key | T>(), internalState: this.startFn() }),\r\n            state => {\r\n                let result: IteratorResult<T>;\r\n                do {\r\n                    result = this.nextFn(state.internalState);\r\n                    if (!result.done) {\r\n                        const value = by ? by(result.value) : result.value;\r\n                        if (!state.set.has(value)) {\r\n                            state.set.add(value);\r\n                            return result;\r\n                        }\r\n                    }\r\n                } while (!result.done);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T> {\r\n        const otherKeySet = new Set<Key | T>();\r\n        for (const item of other) {\r\n            const value = key ? key(item) : item;\r\n            otherKeySet.add(value);\r\n        }\r\n        return this.filter(e => {\r\n            const ownKey = key ? key(e) : e;\r\n            return !otherKeySet.has(ownKey);\r\n        });\r\n    }\r\n}\r\n\r\nfunction toString(item: unknown): string {\r\n    if (typeof item === 'string') {\r\n        return item as string;\r\n    }\r\n    if (typeof item === 'undefined') {\r\n        return 'undefined';\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    if (typeof (item as any).toString === 'function') {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return (item as any).toString();\r\n    }\r\n    return Object.prototype.toString.call(item);\r\n}\r\n\r\nfunction isIterable<T>(obj: unknown): obj is Iterable<T> {\r\n    return !!obj && typeof (obj as Iterable<T>)[Symbol.iterator] === 'function';\r\n}\r\n\r\n/**\r\n * An empty stream of any type.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const EMPTY_STREAM: Stream<any> = new StreamImpl<undefined, any>(() => undefined, () => DONE_RESULT);\r\n\r\n/**\r\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\r\n */\r\nexport const DONE_RESULT: IteratorReturnResult<undefined> = Object.freeze({ done: true, value: undefined });\r\n\r\n/**\r\n * Create a stream from one or more iterables or array-likes.\r\n */\r\nexport function stream<T>(...collections: Array<Iterable<T> | ArrayLike<T>>): Stream<T> {\r\n    if (collections.length === 1) {\r\n        const collection = collections[0];\r\n        if (collection instanceof StreamImpl) {\r\n            return collection as Stream<T>;\r\n        }\r\n        if (isIterable(collection)) {\r\n            return new StreamImpl<Iterator<T, undefined>, T>(\r\n                () => collection[Symbol.iterator](),\r\n                (iterator) => iterator.next()\r\n            );\r\n        }\r\n        if (typeof collection.length === 'number') {\r\n            return new StreamImpl<{ index: number }, T>(\r\n                () => ({ index: 0 }),\r\n                (state) => {\r\n                    if (state.index < collection.length) {\r\n                        return { done: false, value: collection[state.index++] };\r\n                    } else {\r\n                        return DONE_RESULT;\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n    if (collections.length > 1) {\r\n        type State = { collIndex: number, iterator?: Iterator<T, undefined>, array?: ArrayLike<T>, arrIndex: number };\r\n        return new StreamImpl<State, T>(\r\n            () => ({ collIndex: 0, arrIndex: 0 }),\r\n            (state) => {\r\n                do {\r\n                    if (state.iterator) {\r\n                        const next = state.iterator.next();\r\n                        if (!next.done) {\r\n                            return next;\r\n                        }\r\n                        state.iterator = undefined;\r\n                    }\r\n                    if (state.array) {\r\n                        if (state.arrIndex < state.array.length) {\r\n                            return { done: false, value: state.array[state.arrIndex++] };\r\n                        }\r\n                        state.array = undefined;\r\n                        state.arrIndex = 0;\r\n                    }\r\n                    if (state.collIndex < collections.length) {\r\n                        const collection = collections[state.collIndex++];\r\n                        if (isIterable(collection)) {\r\n                            state.iterator = collection[Symbol.iterator]();\r\n                        } else if (collection && typeof collection.length === 'number') {\r\n                            state.array = collection;\r\n                        }\r\n                    }\r\n                } while (state.iterator || state.array || state.collIndex < collections.length);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n    return EMPTY_STREAM;\r\n}\r\n\r\n/**\r\n * A tree iterator adds the ability to prune the current iteration.\r\n */\r\nexport interface TreeIterator<T> extends IterableIterator<T> {\r\n    /**\r\n     * Skip the whole subtree below the last returned element. The iteration continues as if that\r\n     * element had no children.\r\n     */\r\n    prune(): void\r\n}\r\n\r\n/**\r\n * A tree stream is used to stream the elements of a tree, for example an AST or CST.\r\n */\r\nexport interface TreeStream<T> extends Stream<T> {\r\n    iterator(): TreeIterator<T>\r\n}\r\n\r\n/**\r\n * The default implementation of `TreeStream` takes a root element and a function that computes the\r\n * children of its argument. Whether the root node included in the stream is controlled with the\r\n * `includeRoot` option, which defaults to `false`.\r\n */\r\nexport class TreeStreamImpl<T>\r\n    extends StreamImpl<{ iterators: Array<Iterator<T>>, pruned: boolean }, T>\r\n    implements TreeStream<T> {\r\n\r\n    constructor(root: T, children: (node: T) => Iterable<T>, options?: { includeRoot?: boolean }) {\r\n        super(\r\n            () => ({\r\n                iterators: options?.includeRoot ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\r\n                pruned: false\r\n            }),\r\n            state => {\r\n                if (state.pruned) {\r\n                    state.iterators.pop();\r\n                    state.pruned = false;\r\n                }\r\n                while (state.iterators.length > 0) {\r\n                    const iterator = state.iterators[state.iterators.length - 1];\r\n                    const next = iterator.next();\r\n                    if (next.done) {\r\n                        state.iterators.pop();\r\n                    } else {\r\n                        state.iterators.push(children(next.value)[Symbol.iterator]());\r\n                        return next;\r\n                    }\r\n                }\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    override iterator(): TreeIterator<T> {\r\n        const iterator = {\r\n            state: this.startFn(),\r\n            next: () => this.nextFn(iterator.state),\r\n            prune: () => {\r\n                iterator.state.pruned = true;\r\n            },\r\n            [Symbol.iterator]: () => iterator\r\n        };\r\n        return iterator;\r\n    }\r\n}\r\n\r\n/**\r\n * A set of utility functions that reduce a stream to a single value.\r\n */\r\nexport namespace Reduction {\r\n\r\n    /**\r\n     * Compute the sum of a number stream.\r\n     */\r\n    export function sum(stream: Stream<number>): number {\r\n        return stream.reduce((a, b) => a + b, 0);\r\n    }\r\n\r\n    /**\r\n     * Compute the product of a number stream.\r\n     */\r\n    export function product(stream: Stream<number>): number {\r\n        return stream.reduce((a, b) => a * b, 0);\r\n    }\r\n\r\n    /**\r\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\r\n     */\r\n    export function min(stream: Stream<number>): number | undefined {\r\n        return stream.reduce((a, b) => Math.min(a, b));\r\n    }\r\n\r\n    /**\r\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\r\n     */\r\n    export function max(stream: Stream<number>): number | undefined {\r\n        return stream.reduce((a, b) => Math.max(a, b));\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 630, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/cst-utils.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/cst-utils.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IToken } from '@chevrotain/types';\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport type { CstNode, CompositeCstNode, LeafCstNode } from '../syntax-tree.js';\r\nimport type { DocumentSegment } from '../workspace/documents.js';\r\nimport type { Stream, TreeStream } from './stream.js';\r\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\r\nimport { TreeStreamImpl } from './stream.js';\r\n\r\n/**\r\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\r\n * including the root node itself.\r\n */\r\nexport function streamCst(node: CstNode): TreeStream<CstNode> {\r\n    return new TreeStreamImpl(node, element => {\r\n        if (isCompositeCstNode(element)) {\r\n            return element.content;\r\n        } else {\r\n            return [];\r\n        }\r\n    }, { includeRoot: true });\r\n}\r\n\r\n/**\r\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\r\n */\r\nexport function flattenCst(node: CstNode): Stream<LeafCstNode> {\r\n    return streamCst(node).filter(isLeafCstNode);\r\n}\r\n\r\n/**\r\n * Determines whether the specified cst node is a child of the specified parent node.\r\n */\r\nexport function isChildNode(child: CstNode, parent: CstNode): boolean {\r\n    while (child.container) {\r\n        child = child.container;\r\n        if (child === parent) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function tokenToRange(token: IToken): Range {\r\n    // Chevrotain uses 1-based indices everywhere\r\n    // So we subtract 1 from every value to align with the LSP\r\n    return {\r\n        start: {\r\n            character: token.startColumn! - 1,\r\n            line: token.startLine! - 1\r\n        },\r\n        end: {\r\n            character: token.endColumn!, // endColumn uses the correct index\r\n            line: token.endLine! - 1\r\n        }\r\n    };\r\n}\r\n\r\nexport function toDocumentSegment(node: CstNode): DocumentSegment;\r\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined;\r\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined {\r\n    if (!node) {\r\n        return undefined;\r\n    }\r\n    const { offset, end, range } = node;\r\n    return {\r\n        range,\r\n        offset,\r\n        end,\r\n        length: end - offset\r\n    };\r\n}\r\n\r\nexport enum RangeComparison {\r\n    Before = 0,\r\n    After = 1,\r\n    OverlapFront = 2,\r\n    OverlapBack = 3,\r\n    Inside = 4,\r\n    Outside = 5,\r\n}\r\n\r\nexport function compareRange(range: Range, to: Range): RangeComparison {\r\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character <= to.start.character)) {\r\n        return RangeComparison.Before;\r\n    } else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character >= to.end.character)) {\r\n        return RangeComparison.After;\r\n    }\r\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\r\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\r\n    if (startInside && endInside) {\r\n        return RangeComparison.Inside;\r\n    } else if (startInside) {\r\n        return RangeComparison.OverlapBack;\r\n    } else if (endInside) {\r\n        return RangeComparison.OverlapFront;\r\n    } else {\r\n        return RangeComparison.Outside;\r\n    }\r\n}\r\n\r\nexport function inRange(range: Range, to: Range): boolean {\r\n    const comparison = compareRange(range, to);\r\n    return comparison > RangeComparison.After;\r\n}\r\n\r\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\r\n// Together with \\w it matches any kind of character which can commonly appear in IDs\r\nexport const DefaultNameRegexp = /^[\\w\\p{L}]$/u;\r\n\r\n/**\r\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\r\n * it will instead return the leaf node at the `offset - 1` position.\r\n *\r\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\r\n */\r\nexport function findDeclarationNodeAtOffset(cstNode: CstNode | undefined, offset: number, nameRegexp = DefaultNameRegexp): LeafCstNode | undefined {\r\n    if (cstNode) {\r\n        if (offset > 0) {\r\n            const localOffset = offset - cstNode.offset;\r\n            const textAtOffset = cstNode.text.charAt(localOffset);\r\n            if (!nameRegexp.test(textAtOffset)) {\r\n                offset--;\r\n            }\r\n        }\r\n        return findLeafNodeAtOffset(cstNode, offset);\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function findCommentNode(cstNode: CstNode | undefined, commentNames: string[]): CstNode | undefined {\r\n    if (cstNode) {\r\n        const previous = getPreviousNode(cstNode, true);\r\n        if (previous && isCommentNode(previous, commentNames)) {\r\n            return previous;\r\n        }\r\n        if (isRootCstNode(cstNode)) {\r\n            // Go from the first non-hidden node through all nodes in reverse order\r\n            // We do this to find the comment node which directly precedes the root node\r\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\r\n            for (let i = endIndex - 1; i >= 0; i--) {\r\n                const child = cstNode.content[i];\r\n                if (isCommentNode(child, commentNames)) {\r\n                    return child;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function isCommentNode(cstNode: CstNode, commentNames: string[]): boolean {\r\n    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\r\n}\r\n\r\n/**\r\n * Finds the leaf CST node at the specified 0-based string offset.\r\n * Note that the given offset will be within the range of the returned leaf node.\r\n *\r\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\r\n *\r\n * @param node The CST node to search through.\r\n * @param offset The specified offset.\r\n * @returns The CST node at the specified offset.\r\n */\r\nexport function findLeafNodeAtOffset(node: CstNode, offset: number): LeafCstNode | undefined {\r\n    if (isLeafCstNode(node)) {\r\n        return node;\r\n    } else if (isCompositeCstNode(node)) {\r\n        const searchResult = binarySearch(node, offset, false);\r\n        if (searchResult) {\r\n            return findLeafNodeAtOffset(searchResult, offset);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Finds the leaf CST node at the specified 0-based string offset.\r\n * If no CST node exists at the specified position, it will return the leaf node before it.\r\n *\r\n * If there is no leaf node before the specified offset, this method will return `undefined`.\r\n *\r\n * @param node The CST node to search through.\r\n * @param offset The specified offset.\r\n * @returns The CST node closest to the specified offset.\r\n */\r\nexport function findLeafNodeBeforeOffset(node: CstNode, offset: number): LeafCstNode | undefined {\r\n    if (isLeafCstNode(node)) {\r\n        return node;\r\n    } else if (isCompositeCstNode(node)) {\r\n        const searchResult = binarySearch(node, offset, true);\r\n        if (searchResult) {\r\n            return findLeafNodeBeforeOffset(searchResult, offset);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction binarySearch(node: CompositeCstNode, offset: number, closest: boolean): CstNode | undefined {\r\n    let left = 0;\r\n    let right = node.content.length - 1;\r\n    let closestNode: CstNode | undefined = undefined;\r\n\r\n    while (left <= right) {\r\n        const middle = Math.floor((left + right) / 2);\r\n        const middleNode = node.content[middle];\r\n\r\n        if (middleNode.offset <= offset && middleNode.end > offset) {\r\n            // Found an exact match\r\n            return middleNode;\r\n        }\r\n\r\n        if (middleNode.end <= offset) {\r\n            // Update the closest node (less than offset) and move to the right half\r\n            closestNode = closest ? middleNode : undefined;\r\n            left = middle + 1;\r\n        } else {\r\n            // Move to the left half\r\n            right = middle - 1;\r\n        }\r\n    }\r\n\r\n    return closestNode;\r\n}\r\n\r\nexport function getPreviousNode(node: CstNode, hidden = true): CstNode | undefined {\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        let index = parent.content.indexOf(node);\r\n        while (index > 0) {\r\n            index--;\r\n            const previous = parent.content[index];\r\n            if (hidden || !previous.hidden) {\r\n                return previous;\r\n            }\r\n        }\r\n        node = parent;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getNextNode(node: CstNode, hidden = true): CstNode | undefined {\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        let index = parent.content.indexOf(node);\r\n        const last = parent.content.length - 1;\r\n        while (index < last) {\r\n            index++;\r\n            const next = parent.content[index];\r\n            if (hidden || !next.hidden) {\r\n                return next;\r\n            }\r\n        }\r\n        node = parent;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getStartlineNode(node: CstNode): CstNode {\r\n    if (node.range.start.character === 0) {\r\n        return node;\r\n    }\r\n    const line = node.range.start.line;\r\n    let last = node;\r\n    let index: number | undefined;\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        const selfIndex = index ?? parent.content.indexOf(node);\r\n        if (selfIndex === 0) {\r\n            node = parent;\r\n            index = undefined;\r\n        } else {\r\n            index = selfIndex - 1;\r\n            node = parent.content[index];\r\n        }\r\n        if (node.range.start.line !== line) {\r\n            break;\r\n        }\r\n        last = node;\r\n    }\r\n    return last;\r\n}\r\n\r\nexport function getInteriorNodes(start: CstNode, end: CstNode): CstNode[] {\r\n    const commonParent = getCommonParent(start, end);\r\n    if (!commonParent) {\r\n        return [];\r\n    }\r\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\r\n}\r\n\r\nfunction getCommonParent(a: CstNode, b: CstNode): CommonParent | undefined {\r\n    const aParents = getParentChain(a);\r\n    const bParents = getParentChain(b);\r\n    let current: CommonParent | undefined;\r\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\r\n        const aParent = aParents[i];\r\n        const bParent = bParents[i];\r\n        if (aParent.parent === bParent.parent) {\r\n            current = {\r\n                parent: aParent.parent,\r\n                a: aParent.index,\r\n                b: bParent.index\r\n            };\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return current;\r\n}\r\n\r\ninterface CommonParent {\r\n    parent: CompositeCstNode\r\n    a: number\r\n    b: number\r\n}\r\n\r\nfunction getParentChain(node: CstNode): ParentLink[] {\r\n    const chain: ParentLink[] = [];\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        const index = parent.content.indexOf(node);\r\n        chain.push({\r\n            parent,\r\n            index\r\n        });\r\n        node = parent;\r\n    }\r\n    return chain.reverse();\r\n}\r\n\r\ninterface ParentLink {\r\n    parent: CompositeCstNode\r\n    index: number\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 935, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/errors.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/errors.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CstNode } from '../syntax-tree.js';\r\n\r\nexport class ErrorWithLocation extends Error {\r\n    constructor(node: CstNode | undefined, message: string) {\r\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\r\n    }\r\n}\r\n\r\nexport function assertUnreachable(_: never): never {\r\n    throw new Error('Error! The input value was not handled.');\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;AAI1E,MAAO,iBAAkB,SAAQ,KAAK;IACxC,YAAY,IAAyB,EAAE,OAAe,CAAA;QAClD,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,IAAA,EAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAA,CAAA,EAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;IACnG,CAAC;CACJ;AAEK,SAAU,iBAAiB,CAAC,CAAQ;IACtC,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;AAC/D,CAAC"}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/languages/generated/ast.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/languages/generated/ast.ts"],"sourcesContent":["/******************************************************************************\r\n * This file was generated by langium-cli 3.3.0.\r\n * DO NOT EDIT MANUALLY!\r\n ******************************************************************************/\r\n\r\n/* eslint-disable */\r\nimport type { AstNode, Reference, ReferenceInfo, TypeMetaData } from '../../syntax-tree.js';\r\nimport { AbstractAstReflection } from '../../syntax-tree.js';\r\n\r\nexport const LangiumGrammarTerminals = {\r\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\r\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\r\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\r\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\r\n    WS: /\\s+/,\r\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\r\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\r\n};\r\n\r\nexport type LangiumGrammarTerminalNames = keyof typeof LangiumGrammarTerminals;\r\n\r\nexport type LangiumGrammarKeywordNames = \r\n    | \"!\"\r\n    | \"&\"\r\n    | \"(\"\r\n    | \")\"\r\n    | \"*\"\r\n    | \"+\"\r\n    | \"+=\"\r\n    | \",\"\r\n    | \"->\"\r\n    | \".\"\r\n    | \"..\"\r\n    | \":\"\r\n    | \";\"\r\n    | \"<\"\r\n    | \"=\"\r\n    | \"=>\"\r\n    | \">\"\r\n    | \"?\"\r\n    | \"?!\"\r\n    | \"?<!\"\r\n    | \"?<=\"\r\n    | \"?=\"\r\n    | \"@\"\r\n    | \"Date\"\r\n    | \"EOF\"\r\n    | \"[\"\r\n    | \"]\"\r\n    | \"bigint\"\r\n    | \"boolean\"\r\n    | \"current\"\r\n    | \"entry\"\r\n    | \"extends\"\r\n    | \"false\"\r\n    | \"fragment\"\r\n    | \"grammar\"\r\n    | \"hidden\"\r\n    | \"import\"\r\n    | \"infer\"\r\n    | \"infers\"\r\n    | \"interface\"\r\n    | \"number\"\r\n    | \"returns\"\r\n    | \"string\"\r\n    | \"terminal\"\r\n    | \"true\"\r\n    | \"type\"\r\n    | \"with\"\r\n    | \"{\"\r\n    | \"|\"\r\n    | \"}\";\r\n\r\nexport type LangiumGrammarTokenNames = LangiumGrammarTerminalNames | LangiumGrammarKeywordNames;\r\n\r\nexport type AbstractRule = ParserRule | TerminalRule;\r\n\r\nexport const AbstractRule = 'AbstractRule';\r\n\r\nexport function isAbstractRule(item: unknown): item is AbstractRule {\r\n    return reflection.isInstance(item, AbstractRule);\r\n}\r\n\r\nexport type AbstractType = InferredType | Interface | ParserRule | Type;\r\n\r\nexport const AbstractType = 'AbstractType';\r\n\r\nexport function isAbstractType(item: unknown): item is AbstractType {\r\n    return reflection.isInstance(item, AbstractType);\r\n}\r\n\r\nexport type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;\r\n\r\nexport const Condition = 'Condition';\r\n\r\nexport function isCondition(item: unknown): item is Condition {\r\n    return reflection.isInstance(item, Condition);\r\n}\r\n\r\nexport type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;\r\n\r\nexport function isFeatureName(item: unknown): item is FeatureName {\r\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\r\n}\r\n\r\nexport type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';\r\n\r\nexport function isPrimitiveType(item: unknown): item is PrimitiveType {\r\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\r\n}\r\n\r\nexport type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;\r\n\r\nexport const TypeDefinition = 'TypeDefinition';\r\n\r\nexport function isTypeDefinition(item: unknown): item is TypeDefinition {\r\n    return reflection.isInstance(item, TypeDefinition);\r\n}\r\n\r\nexport type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;\r\n\r\nexport const ValueLiteral = 'ValueLiteral';\r\n\r\nexport function isValueLiteral(item: unknown): item is ValueLiteral {\r\n    return reflection.isInstance(item, ValueLiteral);\r\n}\r\n\r\nexport interface AbstractElement extends AstNode {\r\n    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';\r\n    cardinality?: '*' | '+' | '?';\r\n    lookahead?: '?!' | '?<!' | '?<=' | '?=';\r\n}\r\n\r\nexport const AbstractElement = 'AbstractElement';\r\n\r\nexport function isAbstractElement(item: unknown): item is AbstractElement {\r\n    return reflection.isInstance(item, AbstractElement);\r\n}\r\n\r\nexport interface ArrayLiteral extends AstNode {\r\n    readonly $container: ArrayLiteral | TypeAttribute;\r\n    readonly $type: 'ArrayLiteral';\r\n    elements: Array<ValueLiteral>;\r\n}\r\n\r\nexport const ArrayLiteral = 'ArrayLiteral';\r\n\r\nexport function isArrayLiteral(item: unknown): item is ArrayLiteral {\r\n    return reflection.isInstance(item, ArrayLiteral);\r\n}\r\n\r\nexport interface ArrayType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'ArrayType';\r\n    elementType: TypeDefinition;\r\n}\r\n\r\nexport const ArrayType = 'ArrayType';\r\n\r\nexport function isArrayType(item: unknown): item is ArrayType {\r\n    return reflection.isInstance(item, ArrayType);\r\n}\r\n\r\nexport interface BooleanLiteral extends AstNode {\r\n    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;\r\n    readonly $type: 'BooleanLiteral';\r\n    true: boolean;\r\n}\r\n\r\nexport const BooleanLiteral = 'BooleanLiteral';\r\n\r\nexport function isBooleanLiteral(item: unknown): item is BooleanLiteral {\r\n    return reflection.isInstance(item, BooleanLiteral);\r\n}\r\n\r\nexport interface Conjunction extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Conjunction';\r\n    left: Condition;\r\n    right: Condition;\r\n}\r\n\r\nexport const Conjunction = 'Conjunction';\r\n\r\nexport function isConjunction(item: unknown): item is Conjunction {\r\n    return reflection.isInstance(item, Conjunction);\r\n}\r\n\r\nexport interface Disjunction extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Disjunction';\r\n    left: Condition;\r\n    right: Condition;\r\n}\r\n\r\nexport const Disjunction = 'Disjunction';\r\n\r\nexport function isDisjunction(item: unknown): item is Disjunction {\r\n    return reflection.isInstance(item, Disjunction);\r\n}\r\n\r\nexport interface Grammar extends AstNode {\r\n    readonly $type: 'Grammar';\r\n    definesHiddenTokens: boolean;\r\n    hiddenTokens: Array<Reference<AbstractRule>>;\r\n    imports: Array<GrammarImport>;\r\n    interfaces: Array<Interface>;\r\n    isDeclared: boolean;\r\n    name?: string;\r\n    rules: Array<AbstractRule>;\r\n    types: Array<Type>;\r\n    usedGrammars: Array<Reference<Grammar>>;\r\n}\r\n\r\nexport const Grammar = 'Grammar';\r\n\r\nexport function isGrammar(item: unknown): item is Grammar {\r\n    return reflection.isInstance(item, Grammar);\r\n}\r\n\r\nexport interface GrammarImport extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'GrammarImport';\r\n    path: string;\r\n}\r\n\r\nexport const GrammarImport = 'GrammarImport';\r\n\r\nexport function isGrammarImport(item: unknown): item is GrammarImport {\r\n    return reflection.isInstance(item, GrammarImport);\r\n}\r\n\r\nexport interface InferredType extends AstNode {\r\n    readonly $container: Action | ParserRule;\r\n    readonly $type: 'InferredType';\r\n    name: string;\r\n}\r\n\r\nexport const InferredType = 'InferredType';\r\n\r\nexport function isInferredType(item: unknown): item is InferredType {\r\n    return reflection.isInstance(item, InferredType);\r\n}\r\n\r\nexport interface Interface extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'Interface';\r\n    attributes: Array<TypeAttribute>;\r\n    name: string;\r\n    superTypes: Array<Reference<AbstractType>>;\r\n}\r\n\r\nexport const Interface = 'Interface';\r\n\r\nexport function isInterface(item: unknown): item is Interface {\r\n    return reflection.isInstance(item, Interface);\r\n}\r\n\r\nexport interface NamedArgument extends AstNode {\r\n    readonly $container: RuleCall;\r\n    readonly $type: 'NamedArgument';\r\n    calledByName: boolean;\r\n    parameter?: Reference<Parameter>;\r\n    value: Condition;\r\n}\r\n\r\nexport const NamedArgument = 'NamedArgument';\r\n\r\nexport function isNamedArgument(item: unknown): item is NamedArgument {\r\n    return reflection.isInstance(item, NamedArgument);\r\n}\r\n\r\nexport interface Negation extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Negation';\r\n    value: Condition;\r\n}\r\n\r\nexport const Negation = 'Negation';\r\n\r\nexport function isNegation(item: unknown): item is Negation {\r\n    return reflection.isInstance(item, Negation);\r\n}\r\n\r\nexport interface NumberLiteral extends AstNode {\r\n    readonly $container: ArrayLiteral | TypeAttribute;\r\n    readonly $type: 'NumberLiteral';\r\n    value: number;\r\n}\r\n\r\nexport const NumberLiteral = 'NumberLiteral';\r\n\r\nexport function isNumberLiteral(item: unknown): item is NumberLiteral {\r\n    return reflection.isInstance(item, NumberLiteral);\r\n}\r\n\r\nexport interface Parameter extends AstNode {\r\n    readonly $container: ParserRule;\r\n    readonly $type: 'Parameter';\r\n    name: string;\r\n}\r\n\r\nexport const Parameter = 'Parameter';\r\n\r\nexport function isParameter(item: unknown): item is Parameter {\r\n    return reflection.isInstance(item, Parameter);\r\n}\r\n\r\nexport interface ParameterReference extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'ParameterReference';\r\n    parameter: Reference<Parameter>;\r\n}\r\n\r\nexport const ParameterReference = 'ParameterReference';\r\n\r\nexport function isParameterReference(item: unknown): item is ParameterReference {\r\n    return reflection.isInstance(item, ParameterReference);\r\n}\r\n\r\nexport interface ParserRule extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'ParserRule';\r\n    dataType?: PrimitiveType;\r\n    definesHiddenTokens: boolean;\r\n    definition: AbstractElement;\r\n    entry: boolean;\r\n    fragment: boolean;\r\n    hiddenTokens: Array<Reference<AbstractRule>>;\r\n    inferredType?: InferredType;\r\n    name: string;\r\n    parameters: Array<Parameter>;\r\n    returnType?: Reference<AbstractType>;\r\n    wildcard: boolean;\r\n}\r\n\r\nexport const ParserRule = 'ParserRule';\r\n\r\nexport function isParserRule(item: unknown): item is ParserRule {\r\n    return reflection.isInstance(item, ParserRule);\r\n}\r\n\r\nexport interface ReferenceType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'ReferenceType';\r\n    referenceType: TypeDefinition;\r\n}\r\n\r\nexport const ReferenceType = 'ReferenceType';\r\n\r\nexport function isReferenceType(item: unknown): item is ReferenceType {\r\n    return reflection.isInstance(item, ReferenceType);\r\n}\r\n\r\nexport interface ReturnType extends AstNode {\r\n    readonly $container: TerminalRule;\r\n    readonly $type: 'ReturnType';\r\n    name: PrimitiveType | string;\r\n}\r\n\r\nexport const ReturnType = 'ReturnType';\r\n\r\nexport function isReturnType(item: unknown): item is ReturnType {\r\n    return reflection.isInstance(item, ReturnType);\r\n}\r\n\r\nexport interface SimpleType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'SimpleType';\r\n    primitiveType?: PrimitiveType;\r\n    stringType?: string;\r\n    typeRef?: Reference<AbstractType>;\r\n}\r\n\r\nexport const SimpleType = 'SimpleType';\r\n\r\nexport function isSimpleType(item: unknown): item is SimpleType {\r\n    return reflection.isInstance(item, SimpleType);\r\n}\r\n\r\nexport interface StringLiteral extends AstNode {\r\n    readonly $container: ArrayLiteral | TypeAttribute;\r\n    readonly $type: 'StringLiteral';\r\n    value: string;\r\n}\r\n\r\nexport const StringLiteral = 'StringLiteral';\r\n\r\nexport function isStringLiteral(item: unknown): item is StringLiteral {\r\n    return reflection.isInstance(item, StringLiteral);\r\n}\r\n\r\nexport interface TerminalRule extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'TerminalRule';\r\n    definition: AbstractElement;\r\n    fragment: boolean;\r\n    hidden: boolean;\r\n    name: string;\r\n    type?: ReturnType;\r\n}\r\n\r\nexport const TerminalRule = 'TerminalRule';\r\n\r\nexport function isTerminalRule(item: unknown): item is TerminalRule {\r\n    return reflection.isInstance(item, TerminalRule);\r\n}\r\n\r\nexport interface Type extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'Type';\r\n    name: string;\r\n    type: TypeDefinition;\r\n}\r\n\r\nexport const Type = 'Type';\r\n\r\nexport function isType(item: unknown): item is Type {\r\n    return reflection.isInstance(item, Type);\r\n}\r\n\r\nexport interface TypeAttribute extends AstNode {\r\n    readonly $container: Interface;\r\n    readonly $type: 'TypeAttribute';\r\n    defaultValue?: ValueLiteral;\r\n    isOptional: boolean;\r\n    name: FeatureName;\r\n    type: TypeDefinition;\r\n}\r\n\r\nexport const TypeAttribute = 'TypeAttribute';\r\n\r\nexport function isTypeAttribute(item: unknown): item is TypeAttribute {\r\n    return reflection.isInstance(item, TypeAttribute);\r\n}\r\n\r\nexport interface UnionType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'UnionType';\r\n    types: Array<TypeDefinition>;\r\n}\r\n\r\nexport const UnionType = 'UnionType';\r\n\r\nexport function isUnionType(item: unknown): item is UnionType {\r\n    return reflection.isInstance(item, UnionType);\r\n}\r\n\r\nexport interface Action extends AbstractElement {\r\n    readonly $type: 'Action';\r\n    feature?: FeatureName;\r\n    inferredType?: InferredType;\r\n    operator?: '+=' | '=';\r\n    type?: Reference<AbstractType>;\r\n}\r\n\r\nexport const Action = 'Action';\r\n\r\nexport function isAction(item: unknown): item is Action {\r\n    return reflection.isInstance(item, Action);\r\n}\r\n\r\nexport interface Alternatives extends AbstractElement {\r\n    readonly $type: 'Alternatives';\r\n    elements: Array<AbstractElement>;\r\n}\r\n\r\nexport const Alternatives = 'Alternatives';\r\n\r\nexport function isAlternatives(item: unknown): item is Alternatives {\r\n    return reflection.isInstance(item, Alternatives);\r\n}\r\n\r\nexport interface Assignment extends AbstractElement {\r\n    readonly $type: 'Assignment';\r\n    feature: FeatureName;\r\n    operator: '+=' | '=' | '?=';\r\n    terminal: AbstractElement;\r\n}\r\n\r\nexport const Assignment = 'Assignment';\r\n\r\nexport function isAssignment(item: unknown): item is Assignment {\r\n    return reflection.isInstance(item, Assignment);\r\n}\r\n\r\nexport interface CharacterRange extends AbstractElement {\r\n    readonly $type: 'CharacterRange';\r\n    left: Keyword;\r\n    right?: Keyword;\r\n}\r\n\r\nexport const CharacterRange = 'CharacterRange';\r\n\r\nexport function isCharacterRange(item: unknown): item is CharacterRange {\r\n    return reflection.isInstance(item, CharacterRange);\r\n}\r\n\r\nexport interface CrossReference extends AbstractElement {\r\n    readonly $type: 'CrossReference';\r\n    deprecatedSyntax: boolean;\r\n    terminal?: AbstractElement;\r\n    type: Reference<AbstractType>;\r\n}\r\n\r\nexport const CrossReference = 'CrossReference';\r\n\r\nexport function isCrossReference(item: unknown): item is CrossReference {\r\n    return reflection.isInstance(item, CrossReference);\r\n}\r\n\r\nexport interface EndOfFile extends AbstractElement {\r\n    readonly $type: 'EndOfFile';\r\n}\r\n\r\nexport const EndOfFile = 'EndOfFile';\r\n\r\nexport function isEndOfFile(item: unknown): item is EndOfFile {\r\n    return reflection.isInstance(item, EndOfFile);\r\n}\r\n\r\nexport interface Group extends AbstractElement {\r\n    readonly $type: 'Group';\r\n    elements: Array<AbstractElement>;\r\n    guardCondition?: Condition;\r\n}\r\n\r\nexport const Group = 'Group';\r\n\r\nexport function isGroup(item: unknown): item is Group {\r\n    return reflection.isInstance(item, Group);\r\n}\r\n\r\nexport interface Keyword extends AbstractElement {\r\n    readonly $container: CharacterRange;\r\n    readonly $type: 'Keyword';\r\n    value: string;\r\n}\r\n\r\nexport const Keyword = 'Keyword';\r\n\r\nexport function isKeyword(item: unknown): item is Keyword {\r\n    return reflection.isInstance(item, Keyword);\r\n}\r\n\r\nexport interface NegatedToken extends AbstractElement {\r\n    readonly $type: 'NegatedToken';\r\n    terminal: AbstractElement;\r\n}\r\n\r\nexport const NegatedToken = 'NegatedToken';\r\n\r\nexport function isNegatedToken(item: unknown): item is NegatedToken {\r\n    return reflection.isInstance(item, NegatedToken);\r\n}\r\n\r\nexport interface RegexToken extends AbstractElement {\r\n    readonly $type: 'RegexToken';\r\n    regex: string;\r\n}\r\n\r\nexport const RegexToken = 'RegexToken';\r\n\r\nexport function isRegexToken(item: unknown): item is RegexToken {\r\n    return reflection.isInstance(item, RegexToken);\r\n}\r\n\r\nexport interface RuleCall extends AbstractElement {\r\n    readonly $type: 'RuleCall';\r\n    arguments: Array<NamedArgument>;\r\n    rule: Reference<AbstractRule>;\r\n}\r\n\r\nexport const RuleCall = 'RuleCall';\r\n\r\nexport function isRuleCall(item: unknown): item is RuleCall {\r\n    return reflection.isInstance(item, RuleCall);\r\n}\r\n\r\nexport interface TerminalAlternatives extends AbstractElement {\r\n    readonly $type: 'TerminalAlternatives';\r\n    elements: Array<AbstractElement>;\r\n}\r\n\r\nexport const TerminalAlternatives = 'TerminalAlternatives';\r\n\r\nexport function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {\r\n    return reflection.isInstance(item, TerminalAlternatives);\r\n}\r\n\r\nexport interface TerminalGroup extends AbstractElement {\r\n    readonly $type: 'TerminalGroup';\r\n    elements: Array<AbstractElement>;\r\n}\r\n\r\nexport const TerminalGroup = 'TerminalGroup';\r\n\r\nexport function isTerminalGroup(item: unknown): item is TerminalGroup {\r\n    return reflection.isInstance(item, TerminalGroup);\r\n}\r\n\r\nexport interface TerminalRuleCall extends AbstractElement {\r\n    readonly $type: 'TerminalRuleCall';\r\n    rule: Reference<TerminalRule>;\r\n}\r\n\r\nexport const TerminalRuleCall = 'TerminalRuleCall';\r\n\r\nexport function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {\r\n    return reflection.isInstance(item, TerminalRuleCall);\r\n}\r\n\r\nexport interface UnorderedGroup extends AbstractElement {\r\n    readonly $type: 'UnorderedGroup';\r\n    elements: Array<AbstractElement>;\r\n}\r\n\r\nexport const UnorderedGroup = 'UnorderedGroup';\r\n\r\nexport function isUnorderedGroup(item: unknown): item is UnorderedGroup {\r\n    return reflection.isInstance(item, UnorderedGroup);\r\n}\r\n\r\nexport interface UntilToken extends AbstractElement {\r\n    readonly $type: 'UntilToken';\r\n    terminal: AbstractElement;\r\n}\r\n\r\nexport const UntilToken = 'UntilToken';\r\n\r\nexport function isUntilToken(item: unknown): item is UntilToken {\r\n    return reflection.isInstance(item, UntilToken);\r\n}\r\n\r\nexport interface Wildcard extends AbstractElement {\r\n    readonly $type: 'Wildcard';\r\n}\r\n\r\nexport const Wildcard = 'Wildcard';\r\n\r\nexport function isWildcard(item: unknown): item is Wildcard {\r\n    return reflection.isInstance(item, Wildcard);\r\n}\r\n\r\nexport type LangiumGrammarAstType = {\r\n    AbstractElement: AbstractElement\r\n    AbstractRule: AbstractRule\r\n    AbstractType: AbstractType\r\n    Action: Action\r\n    Alternatives: Alternatives\r\n    ArrayLiteral: ArrayLiteral\r\n    ArrayType: ArrayType\r\n    Assignment: Assignment\r\n    BooleanLiteral: BooleanLiteral\r\n    CharacterRange: CharacterRange\r\n    Condition: Condition\r\n    Conjunction: Conjunction\r\n    CrossReference: CrossReference\r\n    Disjunction: Disjunction\r\n    EndOfFile: EndOfFile\r\n    Grammar: Grammar\r\n    GrammarImport: GrammarImport\r\n    Group: Group\r\n    InferredType: InferredType\r\n    Interface: Interface\r\n    Keyword: Keyword\r\n    NamedArgument: NamedArgument\r\n    NegatedToken: NegatedToken\r\n    Negation: Negation\r\n    NumberLiteral: NumberLiteral\r\n    Parameter: Parameter\r\n    ParameterReference: ParameterReference\r\n    ParserRule: ParserRule\r\n    ReferenceType: ReferenceType\r\n    RegexToken: RegexToken\r\n    ReturnType: ReturnType\r\n    RuleCall: RuleCall\r\n    SimpleType: SimpleType\r\n    StringLiteral: StringLiteral\r\n    TerminalAlternatives: TerminalAlternatives\r\n    TerminalGroup: TerminalGroup\r\n    TerminalRule: TerminalRule\r\n    TerminalRuleCall: TerminalRuleCall\r\n    Type: Type\r\n    TypeAttribute: TypeAttribute\r\n    TypeDefinition: TypeDefinition\r\n    UnionType: UnionType\r\n    UnorderedGroup: UnorderedGroup\r\n    UntilToken: UntilToken\r\n    ValueLiteral: ValueLiteral\r\n    Wildcard: Wildcard\r\n}\r\n\r\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\r\n\r\n    getAllTypes(): string[] {\r\n        return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];\r\n    }\r\n\r\n    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\r\n        switch (subtype) {\r\n            case Action:\r\n            case Alternatives:\r\n            case Assignment:\r\n            case CharacterRange:\r\n            case CrossReference:\r\n            case EndOfFile:\r\n            case Group:\r\n            case Keyword:\r\n            case NegatedToken:\r\n            case RegexToken:\r\n            case RuleCall:\r\n            case TerminalAlternatives:\r\n            case TerminalGroup:\r\n            case TerminalRuleCall:\r\n            case UnorderedGroup:\r\n            case UntilToken:\r\n            case Wildcard: {\r\n                return this.isSubtype(AbstractElement, supertype);\r\n            }\r\n            case ArrayLiteral:\r\n            case NumberLiteral:\r\n            case StringLiteral: {\r\n                return this.isSubtype(ValueLiteral, supertype);\r\n            }\r\n            case ArrayType:\r\n            case ReferenceType:\r\n            case SimpleType:\r\n            case UnionType: {\r\n                return this.isSubtype(TypeDefinition, supertype);\r\n            }\r\n            case BooleanLiteral: {\r\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\r\n            }\r\n            case Conjunction:\r\n            case Disjunction:\r\n            case Negation:\r\n            case ParameterReference: {\r\n                return this.isSubtype(Condition, supertype);\r\n            }\r\n            case InferredType:\r\n            case Interface:\r\n            case Type: {\r\n                return this.isSubtype(AbstractType, supertype);\r\n            }\r\n            case ParserRule: {\r\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\r\n            }\r\n            case TerminalRule: {\r\n                return this.isSubtype(AbstractRule, supertype);\r\n            }\r\n            default: {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    getReferenceType(refInfo: ReferenceInfo): string {\r\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\r\n        switch (referenceId) {\r\n            case 'Action:type':\r\n            case 'CrossReference:type':\r\n            case 'Interface:superTypes':\r\n            case 'ParserRule:returnType':\r\n            case 'SimpleType:typeRef': {\r\n                return AbstractType;\r\n            }\r\n            case 'Grammar:hiddenTokens':\r\n            case 'ParserRule:hiddenTokens':\r\n            case 'RuleCall:rule': {\r\n                return AbstractRule;\r\n            }\r\n            case 'Grammar:usedGrammars': {\r\n                return Grammar;\r\n            }\r\n            case 'NamedArgument:parameter':\r\n            case 'ParameterReference:parameter': {\r\n                return Parameter;\r\n            }\r\n            case 'TerminalRuleCall:rule': {\r\n                return TerminalRule;\r\n            }\r\n            default: {\r\n                throw new Error(`${referenceId} is not a valid reference id.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    getTypeMetaData(type: string): TypeMetaData {\r\n        switch (type) {\r\n            case AbstractElement: {\r\n                return {\r\n                    name: AbstractElement,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case ArrayLiteral: {\r\n                return {\r\n                    name: ArrayLiteral,\r\n                    properties: [\r\n                        { name: 'elements', defaultValue: [] }\r\n                    ]\r\n                };\r\n            }\r\n            case ArrayType: {\r\n                return {\r\n                    name: ArrayType,\r\n                    properties: [\r\n                        { name: 'elementType' }\r\n                    ]\r\n                };\r\n            }\r\n            case BooleanLiteral: {\r\n                return {\r\n                    name: BooleanLiteral,\r\n                    properties: [\r\n                        { name: 'true', defaultValue: false }\r\n                    ]\r\n                };\r\n            }\r\n            case Conjunction: {\r\n                return {\r\n                    name: Conjunction,\r\n                    properties: [\r\n                        { name: 'left' },\r\n                        { name: 'right' }\r\n                    ]\r\n                };\r\n            }\r\n            case Disjunction: {\r\n                return {\r\n                    name: Disjunction,\r\n                    properties: [\r\n                        { name: 'left' },\r\n                        { name: 'right' }\r\n                    ]\r\n                };\r\n            }\r\n            case Grammar: {\r\n                return {\r\n                    name: Grammar,\r\n                    properties: [\r\n                        { name: 'definesHiddenTokens', defaultValue: false },\r\n                        { name: 'hiddenTokens', defaultValue: [] },\r\n                        { name: 'imports', defaultValue: [] },\r\n                        { name: 'interfaces', defaultValue: [] },\r\n                        { name: 'isDeclared', defaultValue: false },\r\n                        { name: 'name' },\r\n                        { name: 'rules', defaultValue: [] },\r\n                        { name: 'types', defaultValue: [] },\r\n                        { name: 'usedGrammars', defaultValue: [] }\r\n                    ]\r\n                };\r\n            }\r\n            case GrammarImport: {\r\n                return {\r\n                    name: GrammarImport,\r\n                    properties: [\r\n                        { name: 'path' }\r\n                    ]\r\n                };\r\n            }\r\n            case InferredType: {\r\n                return {\r\n                    name: InferredType,\r\n                    properties: [\r\n                        { name: 'name' }\r\n                    ]\r\n                };\r\n            }\r\n            case Interface: {\r\n                return {\r\n                    name: Interface,\r\n                    properties: [\r\n                        { name: 'attributes', defaultValue: [] },\r\n                        { name: 'name' },\r\n                        { name: 'superTypes', defaultValue: [] }\r\n                    ]\r\n                };\r\n            }\r\n            case NamedArgument: {\r\n                return {\r\n                    name: NamedArgument,\r\n                    properties: [\r\n                        { name: 'calledByName', defaultValue: false },\r\n                        { name: 'parameter' },\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case Negation: {\r\n                return {\r\n                    name: Negation,\r\n                    properties: [\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case NumberLiteral: {\r\n                return {\r\n                    name: NumberLiteral,\r\n                    properties: [\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case Parameter: {\r\n                return {\r\n                    name: Parameter,\r\n                    properties: [\r\n                        { name: 'name' }\r\n                    ]\r\n                };\r\n            }\r\n            case ParameterReference: {\r\n                return {\r\n                    name: ParameterReference,\r\n                    properties: [\r\n                        { name: 'parameter' }\r\n                    ]\r\n                };\r\n            }\r\n            case ParserRule: {\r\n                return {\r\n                    name: ParserRule,\r\n                    properties: [\r\n                        { name: 'dataType' },\r\n                        { name: 'definesHiddenTokens', defaultValue: false },\r\n                        { name: 'definition' },\r\n                        { name: 'entry', defaultValue: false },\r\n                        { name: 'fragment', defaultValue: false },\r\n                        { name: 'hiddenTokens', defaultValue: [] },\r\n                        { name: 'inferredType' },\r\n                        { name: 'name' },\r\n                        { name: 'parameters', defaultValue: [] },\r\n                        { name: 'returnType' },\r\n                        { name: 'wildcard', defaultValue: false }\r\n                    ]\r\n                };\r\n            }\r\n            case ReferenceType: {\r\n                return {\r\n                    name: ReferenceType,\r\n                    properties: [\r\n                        { name: 'referenceType' }\r\n                    ]\r\n                };\r\n            }\r\n            case ReturnType: {\r\n                return {\r\n                    name: ReturnType,\r\n                    properties: [\r\n                        { name: 'name' }\r\n                    ]\r\n                };\r\n            }\r\n            case SimpleType: {\r\n                return {\r\n                    name: SimpleType,\r\n                    properties: [\r\n                        { name: 'primitiveType' },\r\n                        { name: 'stringType' },\r\n                        { name: 'typeRef' }\r\n                    ]\r\n                };\r\n            }\r\n            case StringLiteral: {\r\n                return {\r\n                    name: StringLiteral,\r\n                    properties: [\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case TerminalRule: {\r\n                return {\r\n                    name: TerminalRule,\r\n                    properties: [\r\n                        { name: 'definition' },\r\n                        { name: 'fragment', defaultValue: false },\r\n                        { name: 'hidden', defaultValue: false },\r\n                        { name: 'name' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case Type: {\r\n                return {\r\n                    name: Type,\r\n                    properties: [\r\n                        { name: 'name' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case TypeAttribute: {\r\n                return {\r\n                    name: TypeAttribute,\r\n                    properties: [\r\n                        { name: 'defaultValue' },\r\n                        { name: 'isOptional', defaultValue: false },\r\n                        { name: 'name' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case UnionType: {\r\n                return {\r\n                    name: UnionType,\r\n                    properties: [\r\n                        { name: 'types', defaultValue: [] }\r\n                    ]\r\n                };\r\n            }\r\n            case Action: {\r\n                return {\r\n                    name: Action,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'feature' },\r\n                        { name: 'inferredType' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'operator' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case Alternatives: {\r\n                return {\r\n                    name: Alternatives,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case Assignment: {\r\n                return {\r\n                    name: Assignment,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'feature' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'operator' },\r\n                        { name: 'terminal' }\r\n                    ]\r\n                };\r\n            }\r\n            case CharacterRange: {\r\n                return {\r\n                    name: CharacterRange,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'left' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'right' }\r\n                    ]\r\n                };\r\n            }\r\n            case CrossReference: {\r\n                return {\r\n                    name: CrossReference,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'deprecatedSyntax', defaultValue: false },\r\n                        { name: 'lookahead' },\r\n                        { name: 'terminal' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case EndOfFile: {\r\n                return {\r\n                    name: EndOfFile,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case Group: {\r\n                return {\r\n                    name: Group,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'guardCondition' },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case Keyword: {\r\n                return {\r\n                    name: Keyword,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case NegatedToken: {\r\n                return {\r\n                    name: NegatedToken,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'terminal' }\r\n                    ]\r\n                };\r\n            }\r\n            case RegexToken: {\r\n                return {\r\n                    name: RegexToken,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'regex' }\r\n                    ]\r\n                };\r\n            }\r\n            case RuleCall: {\r\n                return {\r\n                    name: RuleCall,\r\n                    properties: [\r\n                        { name: 'arguments', defaultValue: [] },\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'rule' }\r\n                    ]\r\n                };\r\n            }\r\n            case TerminalAlternatives: {\r\n                return {\r\n                    name: TerminalAlternatives,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case TerminalGroup: {\r\n                return {\r\n                    name: TerminalGroup,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case TerminalRuleCall: {\r\n                return {\r\n                    name: TerminalRuleCall,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'rule' }\r\n                    ]\r\n                };\r\n            }\r\n            case UnorderedGroup: {\r\n                return {\r\n                    name: UnorderedGroup,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case UntilToken: {\r\n                return {\r\n                    name: UntilToken,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'terminal' }\r\n                    ]\r\n                };\r\n            }\r\n            case Wildcard: {\r\n                return {\r\n                    name: Wildcard,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            default: {\r\n                return {\r\n                    name: type,\r\n                    properties: []\r\n                };\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const reflection = new LangiumGrammarAstReflection();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2239, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/ast-utils.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/ast-utils.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport type { AstNode, AstReflection, CstNode, GenericAstNode, Mutable, PropertyType, Reference, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { Stream, TreeStream } from './stream.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { isAstNode, isReference } from '../syntax-tree.js';\r\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';\r\nimport { inRange } from './cst-utils.js';\r\n\r\n/**\r\n * Link the `$container` and other related properties of every AST node that is directly contained\r\n * in the given `node`.\r\n */\r\nexport function linkContentToContainer(node: AstNode): void {\r\n    for (const [name, value] of Object.entries(node)) {\r\n        if (!name.startsWith('$')) {\r\n            if (Array.isArray(value)) {\r\n                value.forEach((item, index) => {\r\n                    if (isAstNode(item)) {\r\n                        (item as Mutable<AstNode>).$container = node;\r\n                        (item as Mutable<AstNode>).$containerProperty = name;\r\n                        (item as Mutable<AstNode>).$containerIndex = index;\r\n                    }\r\n                });\r\n            } else if (isAstNode(value)) {\r\n                (value as Mutable<AstNode>).$container = node;\r\n                (value as Mutable<AstNode>).$containerProperty = name;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\r\n * node that matches the type predicate. If the start node itself matches, it is returned.\r\n * If no container matches, `undefined` is returned.\r\n */\r\nexport function getContainerOfType<T extends AstNode>(node: AstNode | undefined, typePredicate: (n: AstNode) => n is T): T | undefined {\r\n    let item = node;\r\n    while (item) {\r\n        if (typePredicate(item)) {\r\n            return item;\r\n        }\r\n        item = item.$container;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\r\n * of a container that matches the given predicate. The start node is included in the checks.\r\n */\r\nexport function hasContainerOfType(node: AstNode | undefined, predicate: (n: AstNode) => boolean): boolean {\r\n    let item = node;\r\n    while (item) {\r\n        if (predicate(item)) {\r\n            return true;\r\n        }\r\n        item = item.$container;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Retrieve the document in which the given AST node is contained. A reference to the document is\r\n * usually held by the root node of the AST.\r\n *\r\n * @throws an error if the node is not contained in a document.\r\n */\r\nexport function getDocument<T extends AstNode = AstNode>(node: AstNode): LangiumDocument<T> {\r\n    const rootNode = findRootNode(node);\r\n    const result = rootNode.$document;\r\n    if (!result) {\r\n        throw new Error('AST node has no document.');\r\n    }\r\n    return result as LangiumDocument<T>;\r\n}\r\n\r\n/**\r\n * Returns the root node of the given AST node by following the `$container` references.\r\n */\r\nexport function findRootNode(node: AstNode): AstNode {\r\n    while (node.$container) {\r\n        node = node.$container;\r\n    }\r\n    return node;\r\n}\r\n\r\nexport interface AstStreamOptions {\r\n    /**\r\n     * Optional target range that the nodes in the stream need to intersect\r\n     */\r\n    range?: Range\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\r\n * single-valued as well as multi-valued (array) properties.\r\n */\r\nexport function streamContents(node: AstNode, options?: AstStreamOptions): Stream<AstNode> {\r\n    if (!node) {\r\n        throw new Error('Node must be an AstNode.');\r\n    }\r\n    const range = options?.range;\r\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\r\n    return new StreamImpl<State, AstNode>(() => ({\r\n        keys: Object.keys(node),\r\n        keyIndex: 0,\r\n        arrayIndex: 0\r\n    }), state => {\r\n        while (state.keyIndex < state.keys.length) {\r\n            const property = state.keys[state.keyIndex];\r\n            if (!property.startsWith('$')) {\r\n                const value = (node as GenericAstNode)[property];\r\n                if (isAstNode(value)) {\r\n                    state.keyIndex++;\r\n                    if (isAstNodeInRange(value, range)) {\r\n                        return { done: false, value };\r\n                    }\r\n                } else if (Array.isArray(value)) {\r\n                    while (state.arrayIndex < value.length) {\r\n                        const index = state.arrayIndex++;\r\n                        const element = value[index];\r\n                        if (isAstNode(element) && isAstNodeInRange(element, range)) {\r\n                            return { done: false, value: element };\r\n                        }\r\n                    }\r\n                    state.arrayIndex = 0;\r\n                }\r\n            }\r\n            state.keyIndex++;\r\n        }\r\n        return DONE_RESULT;\r\n    });\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\r\n * This does not include the root node itself.\r\n */\r\nexport function streamAllContents(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\r\n    if (!root) {\r\n        throw new Error('Root node must be an AstNode.');\r\n    }\r\n    return new TreeStreamImpl(root, node => streamContents(node, options));\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\r\n * including the root node itself.\r\n */\r\nexport function streamAst(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\r\n    if (!root) {\r\n        throw new Error('Root node must be an AstNode.');\r\n    } else if (options?.range && !isAstNodeInRange(root, options.range)) {\r\n        // Return an empty stream if the root node isn't in range\r\n        return new TreeStreamImpl(root, () => []);\r\n    }\r\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\r\n}\r\n\r\nfunction isAstNodeInRange(astNode: AstNode, range?: Range): boolean {\r\n    if (!range) {\r\n        return true;\r\n    }\r\n    const nodeRange = astNode.$cstNode?.range;\r\n    if (!nodeRange) {\r\n        return false;\r\n    }\r\n    return inRange(nodeRange, range);\r\n}\r\n\r\n/**\r\n * Create a stream of all cross-references that are held by the given AST node. This includes\r\n * single-valued as well as multi-valued (array) properties.\r\n */\r\nexport function streamReferences(node: AstNode): Stream<ReferenceInfo> {\r\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\r\n    return new StreamImpl<State, ReferenceInfo>(() => ({\r\n        keys: Object.keys(node),\r\n        keyIndex: 0,\r\n        arrayIndex: 0\r\n    }), state => {\r\n        while (state.keyIndex < state.keys.length) {\r\n            const property = state.keys[state.keyIndex];\r\n            if (!property.startsWith('$')) {\r\n                const value = (node as GenericAstNode)[property];\r\n                if (isReference(value)) {\r\n                    state.keyIndex++;\r\n                    return { done: false, value: { reference: value, container: node, property } };\r\n                } else if (Array.isArray(value)) {\r\n                    while (state.arrayIndex < value.length) {\r\n                        const index = state.arrayIndex++;\r\n                        const element = value[index];\r\n                        if (isReference(element)) {\r\n                            return { done: false, value: { reference: element, container: node, property, index } };\r\n                        }\r\n                    }\r\n                    state.arrayIndex = 0;\r\n                }\r\n            }\r\n            state.keyIndex++;\r\n        }\r\n        return DONE_RESULT;\r\n    });\r\n}\r\n\r\n/**\r\n * Returns a Stream of references to the target node from the AstNode tree\r\n *\r\n * @param targetNode AstNode we are looking for\r\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\r\n */\r\nexport function findLocalReferences(targetNode: AstNode, lookup = getDocument(targetNode).parseResult.value): Stream<Reference> {\r\n    const refs: Reference[] = [];\r\n    streamAst(lookup).forEach(node => {\r\n        streamReferences(node).forEach(refInfo => {\r\n            if (refInfo.reference.ref === targetNode) {\r\n                refs.push(refInfo.reference);\r\n            }\r\n        });\r\n    });\r\n    return stream(refs);\r\n}\r\n\r\n/**\r\n * Assigns all mandatory AST properties to the specified node.\r\n *\r\n * @param reflection Reflection object used to gather mandatory properties for the node.\r\n * @param node Specified node is modified in place and properties are directly assigned.\r\n */\r\nexport function assignMandatoryProperties(reflection: AstReflection, node: AstNode): void {\r\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\r\n    const genericNode = node as GenericAstNode;\r\n    for (const property of typeMetaData.properties) {\r\n        // Only set the value if the property is not already set and if it has a default value\r\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\r\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\r\n        }\r\n    }\r\n}\r\n\r\nfunction copyDefaultValue(propertyType: PropertyType): PropertyType {\r\n    if (Array.isArray(propertyType)) {\r\n        return [...propertyType.map(copyDefaultValue)];\r\n    } else {\r\n        return propertyType;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a deep copy of the specified AST node.\r\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\r\n *\r\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\r\n */\r\nexport function copyAstNode<T extends AstNode = AstNode>(node: T, buildReference: (node: AstNode, property: string, refNode: CstNode | undefined, refText: string) => Reference<AstNode>): T {\r\n    const copy: GenericAstNode = { $type: node.$type };\r\n\r\n    for (const [name, value] of Object.entries(node)) {\r\n        if (!name.startsWith('$')) {\r\n            if (isAstNode(value)) {\r\n                copy[name] = copyAstNode(value, buildReference);\r\n            } else if (isReference(value)) {\r\n                copy[name] = buildReference(\r\n                    copy,\r\n                    name,\r\n                    value.$refNode,\r\n                    value.$refText\r\n                );\r\n            } else if (Array.isArray(value)) {\r\n                const copiedArray: unknown[] = [];\r\n                for (const element of value) {\r\n                    if (isAstNode(element)) {\r\n                        copiedArray.push(copyAstNode(element, buildReference));\r\n                    } else if (isReference(element)) {\r\n                        copiedArray.push(\r\n                            buildReference(\r\n                                copy,\r\n                                name,\r\n                                element.$refNode,\r\n                                element.$refText\r\n                            )\r\n                        );\r\n                    } else {\r\n                        copiedArray.push(element);\r\n                    }\r\n                }\r\n                copy[name] = copiedArray;\r\n            } else {\r\n                copy[name] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    linkContentToContainer(copy);\r\n    return copy as unknown as T;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2504, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/regexp-utils.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/regexp-utils.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Set, Group, Character, IRegExpAST } from '@chevrotain/regexp-to-ast';\r\nimport { RegExpParser, BaseRegExpVisitor } from '@chevrotain/regexp-to-ast';\r\n\r\nexport const NEWLINE_REGEXP = /\\r?\\n/gm;\r\n\r\nconst regexpParser = new RegExpParser();\r\n\r\n/**\r\n * This class is in charge of heuristically identifying start/end tokens of terminals.\r\n *\r\n * The way this works is by doing the following:\r\n * 1. Traverse the regular expression in the \"start state\"\r\n * 2. Add any encountered sets/single characters to the \"start regexp\"\r\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the \"end state\"\r\n * 4. In the end state, any sets/single characters are added to an \"end stack\".\r\n * 5. If we re-encounter any variable-length content we reset the end stack\r\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\r\n *\r\n * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal\r\n */\r\nclass TerminalRegExpVisitor extends BaseRegExpVisitor {\r\n\r\n    private isStarting = true;\r\n    startRegexp: string;\r\n    private endRegexpStack: string[] = [];\r\n    multiline = false;\r\n    regex: string;\r\n\r\n    get endRegex(): string {\r\n        return this.endRegexpStack.join('');\r\n    }\r\n\r\n    reset(regex: string): void {\r\n        this.multiline = false;\r\n        this.regex = regex;\r\n        this.startRegexp = '';\r\n        this.isStarting = true;\r\n        this.endRegexpStack = [];\r\n    }\r\n\r\n    override visitGroup(node: Group) {\r\n        if (node.quantifier) {\r\n            this.isStarting = false;\r\n            this.endRegexpStack = [];\r\n        }\r\n    }\r\n\r\n    override visitCharacter(node: Character): void {\r\n        const char = String.fromCharCode(node.value);\r\n        if (!this.multiline && char === '\\n') {\r\n            this.multiline = true;\r\n        }\r\n        if (node.quantifier) {\r\n            this.isStarting = false;\r\n            this.endRegexpStack = [];\r\n        } else {\r\n            const escapedChar = escapeRegExp(char);\r\n            this.endRegexpStack.push(escapedChar);\r\n            if (this.isStarting) {\r\n                this.startRegexp += escapedChar;\r\n            }\r\n        }\r\n    }\r\n\r\n    override visitSet(node: Set): void {\r\n        if (!this.multiline) {\r\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\r\n            const regex = new RegExp(set);\r\n            this.multiline = Boolean('\\n'.match(regex));\r\n        }\r\n        if (node.quantifier) {\r\n            this.isStarting = false;\r\n            this.endRegexpStack = [];\r\n        } else {\r\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\r\n            this.endRegexpStack.push(set);\r\n            if (this.isStarting) {\r\n                this.startRegexp += set;\r\n            }\r\n        }\r\n    }\r\n\r\n    override visitChildren(node: IRegExpAST): void {\r\n        if (node.type === 'Group') {\r\n            // Ignore children of groups with quantifier (+/*/?)\r\n            // These groups are unrelated to start/end tokens of terminals\r\n            const group = node as Group;\r\n            if (group.quantifier) {\r\n                return;\r\n            }\r\n        }\r\n        super.visitChildren(node);\r\n    }\r\n}\r\n\r\nconst visitor = new TerminalRegExpVisitor();\r\n\r\nexport function getTerminalParts(regexp: RegExp | string): Array<{ start: string, end: string }> {\r\n    try {\r\n        if (typeof regexp !== 'string') {\r\n            regexp = regexp.source;\r\n        }\r\n        regexp = `/${regexp}/`;\r\n        const pattern = regexpParser.pattern(regexp);\r\n        const parts: Array<{ start: string, end: string }> = [];\r\n        for (const alternative of pattern.value.value) {\r\n            visitor.reset(regexp);\r\n            visitor.visit(alternative);\r\n            parts.push({\r\n                start: visitor.startRegexp,\r\n                end: visitor.endRegex\r\n            });\r\n        }\r\n        return parts;\r\n    } catch {\r\n        return [];\r\n    }\r\n}\r\n\r\nexport function isMultilineComment(regexp: RegExp | string): boolean {\r\n    try {\r\n        if (typeof regexp === 'string') {\r\n            regexp = new RegExp(regexp);\r\n        }\r\n        regexp = regexp.toString();\r\n        visitor.reset(regexp);\r\n        // Parsing the pattern might fail (since it's user code)\r\n        visitor.visit(regexpParser.pattern(regexp));\r\n        return visitor.multiline;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * A set of all characters that are considered whitespace by the '\\s' RegExp character class.\r\n * Taken from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes).\r\n */\r\nexport const whitespaceCharacters = (\r\n    '\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007' +\r\n    '\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff').split('');\r\n\r\nexport function isWhitespace(value: RegExp | string): boolean {\r\n    const regexp = typeof value === 'string' ? new RegExp(value) : value;\r\n    return whitespaceCharacters.some((ws) => regexp.test(ws));\r\n}\r\n\r\nexport function escapeRegExp(value: string): string {\r\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n\r\nexport function getCaseInsensitivePattern(keyword: string): string {\r\n    return Array.prototype.map.call(keyword, letter =>\r\n        /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)\r\n    ).join('');\r\n}\r\n\r\n/**\r\n * Determines whether the given input has a partial match with the specified regex.\r\n * @param regex The regex to partially match against\r\n * @param input The input string\r\n * @returns Whether any match exists.\r\n */\r\nexport function partialMatches(regex: RegExp | string, input: string): boolean {\r\n    const partial = partialRegExp(regex);\r\n    const match = input.match(partial);\r\n    return !!match && match[0].length > 0;\r\n}\r\n\r\n/**\r\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\r\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.\r\n * @param regex The input regex to be converted.\r\n * @returns A partial regex constructed from the input regex.\r\n */\r\nexport function partialRegExp(regex: RegExp | string): RegExp {\r\n    if (typeof regex === 'string') {\r\n        regex = new RegExp(regex);\r\n    }\r\n    const re = regex, source = regex.source;\r\n    let i = 0;\r\n\r\n    function process() {\r\n        let result = '',\r\n            tmp;\r\n\r\n        function appendRaw(nbChars: number) {\r\n            result += source.substr(i, nbChars);\r\n            i += nbChars;\r\n        }\r\n\r\n        function appendOptional(nbChars: number) {\r\n            result += '(?:' + source.substr(i, nbChars) + '|$)';\r\n            i += nbChars;\r\n        }\r\n\r\n        while (i < source.length) {\r\n            switch (source[i]) {\r\n                case '\\\\':\r\n                    switch (source[i + 1]) {\r\n                        case 'c':\r\n                            appendOptional(3);\r\n                            break;\r\n                        case 'x':\r\n                            appendOptional(4);\r\n                            break;\r\n                        case 'u':\r\n                            if (re.unicode) {\r\n                                if (source[i + 2] === '{') {\r\n                                    appendOptional(source.indexOf('}', i) - i + 1);\r\n                                } else {\r\n                                    appendOptional(6);\r\n                                }\r\n                            } else {\r\n                                appendOptional(2);\r\n                            }\r\n                            break;\r\n                        case 'p':\r\n                        case 'P':\r\n                            if (re.unicode) {\r\n                                appendOptional(source.indexOf('}', i) - i + 1);\r\n                            } else {\r\n                                appendOptional(2);\r\n                            }\r\n                            break;\r\n                        case 'k':\r\n                            appendOptional(source.indexOf('>', i) - i + 1);\r\n                            break;\r\n                        default:\r\n                            appendOptional(2);\r\n                            break;\r\n                    }\r\n                    break;\r\n\r\n                case '[':\r\n                    tmp = /\\[(?:\\\\.|.)*?\\]/g;\r\n                    tmp.lastIndex = i;\r\n                    tmp = tmp.exec(source) || [];\r\n                    appendOptional(tmp[0].length);\r\n                    break;\r\n\r\n                case '|':\r\n                case '^':\r\n                case '$':\r\n                case '*':\r\n                case '+':\r\n                case '?':\r\n                    appendRaw(1);\r\n                    break;\r\n                case '{':\r\n                    tmp = /\\{\\d+,?\\d*\\}/g;\r\n                    tmp.lastIndex = i;\r\n                    tmp = tmp.exec(source);\r\n                    if (tmp) {\r\n                        appendRaw(tmp[0].length);\r\n                    } else {\r\n                        appendOptional(1);\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    if (source[i + 1] === '?') {\r\n                        switch (source[i + 2]) {\r\n                            case ':':\r\n                                result += '(?:';\r\n                                i += 3;\r\n                                result += process() + '|$)';\r\n                                break;\r\n                            case '=':\r\n                                result += '(?=';\r\n                                i += 3;\r\n                                result += process() + ')';\r\n                                break;\r\n                            case '!':\r\n                                tmp = i;\r\n                                i += 3;\r\n                                process();\r\n                                result += source.substr(tmp, i - tmp);\r\n                                break;\r\n                            case '<':\r\n                                switch (source[i + 3]) {\r\n                                    case '=':\r\n                                    case '!':\r\n                                        tmp = i;\r\n                                        i += 4;\r\n                                        process();\r\n                                        result += source.substr(tmp, i - tmp);\r\n                                        break;\r\n                                    default:\r\n                                        appendRaw(source.indexOf('>', i) - i + 1);\r\n                                        result += process() + '|$)';\r\n                                        break;\r\n                                }\r\n                                break;\r\n                        }\r\n                    } else {\r\n                        appendRaw(1);\r\n                        result += process() + '|$)';\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    ++i;\r\n                    return result;\r\n                default:\r\n                    appendOptional(1);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    return new RegExp(process(), regex.flags);\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2799, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/grammar-utils.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/grammar-utils.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021-2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { assertUnreachable } from '../utils/errors.js';\r\nimport * as ast from '../languages/generated/ast.js';\r\nimport type { AstNode, CstNode } from '../syntax-tree.js';\r\nimport { isCompositeCstNode } from '../syntax-tree.js';\r\nimport { getContainerOfType, streamAllContents } from './ast-utils.js';\r\nimport { streamCst } from './cst-utils.js';\r\nimport { escapeRegExp, isWhitespace } from './regexp-utils.js';\r\n\r\n/**\r\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\r\n * the result is `undefined`.\r\n */\r\nexport function getEntryRule(grammar: ast.Grammar): ast.ParserRule | undefined {\r\n    return grammar.rules.find(e => ast.isParserRule(e) && e.entry) as ast.ParserRule;\r\n}\r\n\r\n/**\r\n * Returns all hidden terminal rules of the given grammar, if any.\r\n */\r\nexport function getHiddenRules(grammar: ast.Grammar) {\r\n    return grammar.rules.filter((e): e is ast.TerminalRule => ast.isTerminalRule(e) && e.hidden);\r\n}\r\n\r\n/**\r\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\r\n *\r\n * @param grammar The grammar that contains all rules\r\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\r\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\r\n *      this function returns all rules of the specified grammar.\r\n */\r\nexport function getAllReachableRules(grammar: ast.Grammar, allTerminals: boolean): Set<ast.AbstractRule> {\r\n    const ruleNames = new Set<string>();\r\n    const entryRule = getEntryRule(grammar);\r\n    if (!entryRule) {\r\n        return new Set(grammar.rules);\r\n    }\r\n\r\n    const topMostRules = [entryRule as ast.AbstractRule].concat(getHiddenRules(grammar));\r\n    for (const rule of topMostRules) {\r\n        ruleDfs(rule, ruleNames, allTerminals);\r\n    }\r\n\r\n    const rules = new Set<ast.AbstractRule>();\r\n    for (const rule of grammar.rules) {\r\n        if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) && rule.hidden)) {\r\n            rules.add(rule);\r\n        }\r\n    }\r\n    return rules;\r\n}\r\n\r\nfunction ruleDfs(rule: ast.AbstractRule, visitedSet: Set<string>, allTerminals: boolean): void {\r\n    visitedSet.add(rule.name);\r\n    streamAllContents(rule).forEach(node => {\r\n        if (ast.isRuleCall(node) || (allTerminals && ast.isTerminalRuleCall(node))) {\r\n            const refRule = node.rule.ref;\r\n            if (refRule && !visitedSet.has(refRule.name)) {\r\n                ruleDfs(refRule, visitedSet, allTerminals);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\r\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\r\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\r\n *\r\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\r\n * and cannot be inferred.\r\n */\r\nexport function getCrossReferenceTerminal(crossRef: ast.CrossReference): ast.AbstractElement | undefined {\r\n    if (crossRef.terminal) {\r\n        return crossRef.terminal;\r\n    } else if (crossRef.type.ref) {\r\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\r\n        return nameAssigment?.terminal;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\r\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\r\n * that contains visible characters is considered a comment.\r\n */\r\nexport function isCommentTerminal(terminalRule: ast.TerminalRule): boolean {\r\n    return terminalRule.hidden && !isWhitespace(terminalRegex(terminalRule));\r\n}\r\n\r\n/**\r\n * Find all CST nodes within the given node that contribute to the specified property.\r\n *\r\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\r\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\r\n */\r\nexport function findNodesForProperty(node: CstNode | undefined, property: string | undefined): CstNode[] {\r\n    if (!node || !property) {\r\n        return [];\r\n    }\r\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\r\n}\r\n\r\n/**\r\n * Find a single CST node within the given node that contributes to the specified property.\r\n *\r\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\r\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\r\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\r\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\r\n *        the node with the specified index is returned.\r\n */\r\nexport function findNodeForProperty(node: CstNode | undefined, property: string | undefined, index?: number): CstNode | undefined {\r\n    if (!node || !property) {\r\n        return undefined;\r\n    }\r\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\r\n    if (nodes.length === 0) {\r\n        return undefined;\r\n    }\r\n    if (index !== undefined) {\r\n        index = Math.max(0, Math.min(index, nodes.length - 1));\r\n    } else {\r\n        index = 0;\r\n    }\r\n    return nodes[index];\r\n}\r\n\r\nfunction findNodesForPropertyInternal(node: CstNode, property: string, element: AstNode | undefined, first: boolean): CstNode[] {\r\n    if (!first) {\r\n        const nodeFeature = getContainerOfType(node.grammarSource, ast.isAssignment);\r\n        if (nodeFeature && nodeFeature.feature === property) {\r\n            return [node];\r\n        }\r\n    }\r\n    if (isCompositeCstNode(node) && node.astNode === element) {\r\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\r\n    }\r\n    return [];\r\n}\r\n\r\n/**\r\n * Find all CST nodes within the given node that correspond to the specified keyword.\r\n *\r\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\r\n * @param keyword A keyword as specified in the grammar.\r\n */\r\nexport function findNodesForKeyword(node: CstNode | undefined, keyword: string): CstNode[] {\r\n    if (!node) {\r\n        return [];\r\n    }\r\n    return findNodesForKeywordInternal(node, keyword, node?.astNode);\r\n}\r\n\r\n/**\r\n * Find a single CST node within the given node that corresponds to the specified keyword.\r\n *\r\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\r\n * @param keyword A keyword as specified in the grammar.\r\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\r\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\r\n *        the node with the specified index is returned.\r\n */\r\nexport function findNodeForKeyword(node: CstNode | undefined, keyword: string, index?: number): CstNode | undefined {\r\n    if (!node) {\r\n        return undefined;\r\n    }\r\n    const nodes = findNodesForKeywordInternal(node, keyword, node?.astNode);\r\n    if (nodes.length === 0) {\r\n        return undefined;\r\n    }\r\n    if (index !== undefined) {\r\n        index = Math.max(0, Math.min(index, nodes.length - 1));\r\n    } else {\r\n        index = 0;\r\n    }\r\n    return nodes[index];\r\n}\r\n\r\nexport function findNodesForKeywordInternal(node: CstNode, keyword: string, element: AstNode | undefined): CstNode[] {\r\n    if (node.astNode !== element) {\r\n        return [];\r\n    }\r\n    if (ast.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\r\n        return [node];\r\n    }\r\n    const treeIterator = streamCst(node).iterator();\r\n    let result: IteratorResult<CstNode>;\r\n    const keywordNodes: CstNode[] = [];\r\n    do {\r\n        result = treeIterator.next();\r\n        if (!result.done) {\r\n            const childNode = result.value;\r\n            if (childNode.astNode === element) {\r\n                if (ast.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\r\n                    keywordNodes.push(childNode);\r\n                }\r\n            } else {\r\n                treeIterator.prune();\r\n            }\r\n        }\r\n    } while (!result.done);\r\n    return keywordNodes;\r\n}\r\n\r\n/**\r\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\r\n * node is returned. If no assignment is found, the result is `undefined`.\r\n *\r\n * @param cstNode A CST node for which to find a property assignment.\r\n */\r\nexport function findAssignment(cstNode: CstNode): ast.Assignment | undefined {\r\n    const astNode = cstNode.astNode;\r\n    // Only search until the ast node of the parent cst node is no longer the original ast node\r\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\r\n    while (astNode === cstNode.container?.astNode) {\r\n        const assignment = getContainerOfType(cstNode.grammarSource, ast.isAssignment);\r\n        if (assignment) {\r\n            return assignment;\r\n        }\r\n        cstNode = cstNode.container;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\r\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\r\n * this function returns `undefined`.\r\n */\r\nexport function findNameAssignment(type: ast.AbstractType): ast.Assignment | undefined {\r\n    let startNode: AstNode = type;\r\n    if (ast.isInferredType(startNode)) {\r\n        // for inferred types, the location to start searching for the name-assignment is different\r\n        if (ast.isAction(startNode.$container)) {\r\n            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent\r\n            startNode = startNode.$container.$container!;\r\n        } else if (ast.isParserRule(startNode.$container)) {\r\n            // investigate the parser rule with the explicitly inferred type\r\n            startNode = startNode.$container;\r\n        } else {\r\n            assertUnreachable(startNode.$container);\r\n        }\r\n    }\r\n    return findNameAssignmentInternal(type, startNode, new Map());\r\n}\r\n\r\nfunction findNameAssignmentInternal(type: ast.AbstractType, startNode: AstNode, cache: Map<ast.AbstractType, ast.Assignment | undefined>): ast.Assignment | undefined {\r\n    // the cache is only required to prevent infinite loops\r\n    function go(node: AstNode, refType: ast.AbstractType): ast.Assignment | undefined {\r\n        let childAssignment: ast.Assignment | undefined = undefined;\r\n        const parentAssignment = getContainerOfType(node, ast.isAssignment);\r\n        // No parent assignment implies unassigned rule call\r\n        if (!parentAssignment) {\r\n            childAssignment = findNameAssignmentInternal(refType, refType, cache);\r\n        }\r\n        cache.set(type, childAssignment);\r\n        return childAssignment;\r\n    }\r\n\r\n    if (cache.has(type)) {\r\n        return cache.get(type);\r\n    }\r\n    cache.set(type, undefined);\r\n    for (const node of streamAllContents(startNode)) {\r\n        if (ast.isAssignment(node) && node.feature.toLowerCase() === 'name') {\r\n            cache.set(type, node);\r\n            return node;\r\n        } else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {\r\n            return go(node, node.rule.ref);\r\n        } else if (ast.isSimpleType(node) && node.typeRef?.ref) {\r\n            return go(node, node.typeRef.ref);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getActionAtElement(element: ast.AbstractElement): ast.Action | undefined {\r\n    const parent = element.$container;\r\n    if (ast.isGroup(parent)) {\r\n        const elements = parent.elements;\r\n        const index = elements.indexOf(element);\r\n        for (let i = index - 1; i >= 0; i--) {\r\n            const item = elements[i];\r\n            if (ast.isAction(item)) {\r\n                return item;\r\n            } else {\r\n                const action = streamAllContents(elements[i]).find(ast.isAction);\r\n                if (action) {\r\n                    return action;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (ast.isAbstractElement(parent)) {\r\n        return getActionAtElement(parent);\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport type Cardinality = '?' | '*' | '+' | undefined;\r\nexport type Operator = '=' | '+=' | '?=' | undefined;\r\n\r\nexport function isOptionalCardinality(cardinality?: Cardinality, element?: ast.AbstractElement): boolean {\r\n    return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) && Boolean(element.guardCondition));\r\n}\r\n\r\nexport function isArrayCardinality(cardinality?: Cardinality): boolean {\r\n    return cardinality === '*' || cardinality === '+';\r\n}\r\n\r\nexport function isArrayOperator(operator?: Operator): boolean {\r\n    return operator === '+=';\r\n}\r\n\r\n/**\r\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\r\n * primitive return type like `number`, `boolean`, etc.\r\n */\r\nexport function isDataTypeRule(rule: ast.ParserRule): boolean {\r\n    return isDataTypeRuleInternal(rule, new Set());\r\n}\r\n\r\nfunction isDataTypeRuleInternal(rule: ast.ParserRule, visited: Set<ast.ParserRule>): boolean {\r\n    if (visited.has(rule)) {\r\n        return true;\r\n    } else {\r\n        visited.add(rule);\r\n    }\r\n    for (const node of streamAllContents(rule)) {\r\n        if (ast.isRuleCall(node)) {\r\n            if (!node.rule.ref) {\r\n                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.\r\n                return false;\r\n            }\r\n            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\r\n                return false;\r\n            }\r\n        } else if (ast.isAssignment(node)) {\r\n            return false;\r\n        } else if (ast.isAction(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return Boolean(rule.definition);\r\n}\r\n\r\nexport function isDataType(type: ast.Type): boolean {\r\n    return isDataTypeInternal(type.type, new Set());\r\n}\r\n\r\nfunction isDataTypeInternal(type: ast.TypeDefinition, visited: Set<ast.TypeDefinition>): boolean {\r\n    if (visited.has(type)) {\r\n        return true;\r\n    } else {\r\n        visited.add(type);\r\n    }\r\n    if (ast.isArrayType(type)) {\r\n        return false;\r\n    } else if (ast.isReferenceType(type)) {\r\n        return false;\r\n    } else if (ast.isUnionType(type)) {\r\n        return type.types.every(e => isDataTypeInternal(e, visited));\r\n    } else if (ast.isSimpleType(type)) {\r\n        if (type.primitiveType !== undefined) {\r\n            return true;\r\n        } else if (type.stringType !== undefined) {\r\n            return true;\r\n        } else if (type.typeRef !== undefined) {\r\n            const ref = type.typeRef.ref;\r\n            if (ast.isType(ref)) {\r\n                return isDataTypeInternal(ref.type, visited);\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function getExplicitRuleType(rule: ast.ParserRule): string | undefined {\r\n    if (rule.inferredType) {\r\n        return rule.inferredType.name;\r\n    } else if (rule.dataType) {\r\n        return rule.dataType;\r\n    } else if (rule.returnType) {\r\n        const refType = rule.returnType.ref;\r\n        if (refType) {\r\n            // check if we need to check Action as return type\r\n            if (ast.isParserRule(refType)) {\r\n                return refType.name;\r\n            } else if (ast.isInterface(refType) || ast.isType(refType)) {\r\n                return refType.name;\r\n            }\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getTypeName(type: ast.AbstractType | ast.Action): string {\r\n    if (ast.isParserRule(type)) {\r\n        return isDataTypeRule(type) ? type.name : getExplicitRuleType(type) ?? type.name;\r\n    } else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {\r\n        return type.name;\r\n    } else if (ast.isAction(type)) {\r\n        const actionType = getActionType(type);\r\n        if (actionType) {\r\n            return actionType;\r\n        }\r\n    } else if (ast.isInferredType(type)) {\r\n        return type.name;\r\n    }\r\n    throw new Error('Cannot get name of Unknown Type');\r\n}\r\n\r\nexport function getActionType(action: ast.Action): string | undefined {\r\n    if (action.inferredType) {\r\n        return action.inferredType.name;\r\n    } else if (action.type?.ref) {\r\n        return getTypeName(action.type.ref);\r\n    }\r\n    return undefined; // not inferring and not referencing a valid type\r\n}\r\n\r\n/**\r\n * This function is used at development time (for code generation and the internal type system) to get the type of the AST node produced by the given rule.\r\n * For data type rules, the name of the rule is returned,\r\n * e.g. \"INT_value returns number: MY_INT;\" returns \"INT_value\".\r\n * @param rule the given rule\r\n * @returns the name of the AST node type of the rule\r\n */\r\nexport function getRuleTypeName(rule: ast.AbstractRule): string {\r\n    if (ast.isTerminalRule(rule)) {\r\n        return rule.type?.name ?? 'string';\r\n    } else {\r\n        return isDataTypeRule(rule) ? rule.name : getExplicitRuleType(rule) ?? rule.name;\r\n    }\r\n}\r\n\r\n/**\r\n * This function is used at runtime to get the actual type of the values produced by the given rule at runtime.\r\n * For data type rules, the name of the declared return type of the rule is returned (if any),\r\n * e.g. \"INT_value returns number: MY_INT;\" returns \"number\".\r\n * @param rule the given rule\r\n * @returns the name of the type of the produced values of the rule at runtime\r\n */\r\nexport function getRuleType(rule: ast.AbstractRule): string {\r\n    if (ast.isTerminalRule(rule)) {\r\n        return rule.type?.name ?? 'string';\r\n    } else {\r\n        return getExplicitRuleType(rule) ?? rule.name;\r\n    }\r\n}\r\n\r\nexport function terminalRegex(terminalRule: ast.TerminalRule): RegExp {\r\n    const flags: Flags = {\r\n        s: false,\r\n        i: false,\r\n        u: false\r\n    };\r\n    const source = abstractElementToRegex(terminalRule.definition, flags);\r\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');\r\n    return new RegExp(source, flagText);\r\n}\r\n\r\n// Using [\\s\\S]* allows to match everything, compared to . which doesn't match line terminators\r\nconst WILDCARD = /[\\s\\S]/.source;\r\n\r\ntype Flags = {\r\n    s: boolean;\r\n    i: boolean;\r\n    u: boolean;\r\n}\r\n\r\nfunction abstractElementToRegex(element: ast.AbstractElement, flags?: Flags): string {\r\n    if (ast.isTerminalAlternatives(element)) {\r\n        return terminalAlternativesToRegex(element);\r\n    } else if (ast.isTerminalGroup(element)) {\r\n        return terminalGroupToRegex(element);\r\n    } else if (ast.isCharacterRange(element)) {\r\n        return characterRangeToRegex(element);\r\n    } else if (ast.isTerminalRuleCall(element)) {\r\n        const rule = element.rule.ref;\r\n        if (!rule) {\r\n            throw new Error('Missing rule reference.');\r\n        }\r\n        return withCardinality(abstractElementToRegex(rule.definition), {\r\n            cardinality: element.cardinality,\r\n            lookahead: element.lookahead\r\n        });\r\n    } else if (ast.isNegatedToken(element)) {\r\n        return negateTokenToRegex(element);\r\n    } else if (ast.isUntilToken(element)) {\r\n        return untilTokenToRegex(element);\r\n    } else if (ast.isRegexToken(element)) {\r\n        const lastSlash = element.regex.lastIndexOf('/');\r\n        const source = element.regex.substring(1, lastSlash);\r\n        const regexFlags = element.regex.substring(lastSlash + 1);\r\n        if (flags) {\r\n            flags.i = regexFlags.includes('i');\r\n            flags.s = regexFlags.includes('s');\r\n            flags.u = regexFlags.includes('u');\r\n        }\r\n        return withCardinality(source, {\r\n            cardinality: element.cardinality,\r\n            lookahead: element.lookahead,\r\n            wrap: false\r\n        });\r\n    } else if (ast.isWildcard(element)) {\r\n        return withCardinality(WILDCARD, {\r\n            cardinality: element.cardinality,\r\n            lookahead: element.lookahead\r\n        });\r\n    } else {\r\n        throw new Error(`Invalid terminal element: ${element?.$type}`);\r\n    }\r\n}\r\n\r\nfunction terminalAlternativesToRegex(alternatives: ast.TerminalAlternatives): string {\r\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {\r\n        cardinality: alternatives.cardinality,\r\n        lookahead: alternatives.lookahead\r\n    });\r\n}\r\n\r\nfunction terminalGroupToRegex(group: ast.TerminalGroup): string {\r\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {\r\n        cardinality: group.cardinality,\r\n        lookahead: group.lookahead\r\n    });\r\n}\r\n\r\nfunction untilTokenToRegex(until: ast.UntilToken): string {\r\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\r\n        cardinality: until.cardinality,\r\n        lookahead: until.lookahead\r\n    });\r\n}\r\n\r\nfunction negateTokenToRegex(negate: ast.NegatedToken): string {\r\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\r\n        cardinality: negate.cardinality,\r\n        lookahead: negate.lookahead\r\n    });\r\n}\r\n\r\nfunction characterRangeToRegex(range: ast.CharacterRange): string {\r\n    if (range.right) {\r\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\r\n            cardinality: range.cardinality,\r\n            lookahead: range.lookahead,\r\n            wrap: false\r\n        });\r\n    }\r\n    return withCardinality(keywordToRegex(range.left), {\r\n        cardinality: range.cardinality,\r\n        lookahead: range.lookahead,\r\n        wrap: false\r\n    });\r\n}\r\n\r\nfunction keywordToRegex(keyword: ast.Keyword): string {\r\n    return escapeRegExp(keyword.value);\r\n}\r\n\r\nfunction withCardinality(regex: string, options: {\r\n    cardinality?: string\r\n    wrap?: boolean\r\n    lookahead?: string\r\n}): string {\r\n    if (options.wrap !== false || options.lookahead) {\r\n        regex = `(${options.lookahead ?? ''}${regex})`;\r\n    }\r\n    if (options.cardinality) {\r\n        return `${regex}${options.cardinality}`;\r\n    }\r\n    return regex;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEhF,OAAO,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAC;AACvD,OAAO,KAAK,GAAG,MAAM,+BAA+B,CAAC;AAErD,OAAO,EAAE,kBAAkB,EAAE,MAAM,mBAAmB,CAAC;AACvD,OAAO,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,MAAM,gBAAgB,CAAC;AACvE,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAC3C,OAAO,EAAE,YAAY,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;;;;;;;AAMzD,SAAU,YAAY,CAAC,OAAoB;IAC7C,OAAO,OAAO,CAAC,KAAK,CAAC,IAAI,EAAC,CAAC,CAAC,EAAE,AAAC,GAAG,CAAC,+NAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,CAAmB,CAAC;AACrF,CAAC;AAKK,SAAU,cAAc,CAAC,OAAoB;IAC/C,OAAO,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAyB,CAAG,CAAD,EAAI,CAAC,iOAAc,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC;AACjG,CAAC;AAUK,SAAU,oBAAoB,CAAC,OAAoB,EAAE,YAAqB;IAC5E,MAAM,SAAS,GAAG,IAAI,GAAG,EAAU,CAAC;IACpC,MAAM,SAAS,GAAG,YAAY,CAAC,OAAO,CAAC,CAAC;IACxC,IAAI,CAAC,SAAS,EAAE,CAAC;QACb,OAAO,IAAI,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAClC,CAAC;IAED,MAAM,YAAY,GAAG;QAAC,SAA6B;KAAC,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;IACrF,KAAK,MAAM,IAAI,IAAI,YAAY,CAAE,CAAC;QAC9B,OAAO,CAAC,IAAI,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;IAC3C,CAAC;IAED,MAAM,KAAK,GAAG,IAAI,GAAG,EAAoB,CAAC;IAC1C,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,KAAK,CAAE,CAAC;QAC/B,IAAI,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAK,AAAD,GAAI,CAAC,iOAAc,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAE,CAAC;YACxE,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACpB,CAAC;IACL,CAAC;IACD,OAAO,KAAK,CAAC;AACjB,CAAC;AAED,SAAS,OAAO,CAAC,IAAsB,EAAE,UAAuB,EAAE,YAAqB;IACnF,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,gOAAiB,EAAC,IAAI,CAAC,CAAC,OAAO,EAAC,IAAI,CAAC,EAAE;QACnC,IAAI,GAAG,CAAC,6NAAU,CAAC,IAAI,CAAC,IAAI,AAAC,YAAY,IAAI,GAAG,CAAC,qOAAkB,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;YACzE,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;YAC9B,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC3C,OAAO,CAAC,OAAO,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;YAC/C,CAAC;QACL,CAAC;IACL,CAAC,CAAC,CAAC;AACP,CAAC;AAUK,SAAU,yBAAyB,CAAC,QAA4B;IAClE,IAAI,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACpB,OAAO,QAAQ,CAAC,QAAQ,CAAC;IAC7B,CAAC,MAAM,IAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;QAC3B,MAAM,aAAa,GAAG,kBAAkB,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC5D,OAAO,aAAa,KAAA,QAAb,aAAa,KAAA,KAAA,IAAA,KAAA,IAAb,aAAa,CAAE,QAAQ,CAAC;IACnC,CAAC;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAOK,SAAU,iBAAiB,CAAC,YAA8B;IAC5D,OAAO,YAAY,CAAC,MAAM,IAAI,KAAC,8NAAY,EAAC,aAAa,CAAC,YAAY,CAAC,CAAC,CAAC;AAC7E,CAAC;AAQK,SAAU,oBAAoB,CAAC,IAAyB,EAAE,QAA4B;IACxF,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;QACrB,OAAO,EAAE,CAAC;IACd,CAAC;IACD,OAAO,4BAA4B,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC5E,CAAC;AAWK,SAAU,mBAAmB,CAAC,IAAyB,EAAE,QAA4B,EAAE,KAAc;IACvG,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;QACrB,OAAO,SAAS,CAAC;IACrB,CAAC;IACD,MAAM,KAAK,GAAG,4BAA4B,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC/E,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACrB,OAAO,SAAS,CAAC;IACrB,CAAC;IACD,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;QACtB,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3D,CAAC,MAAM,CAAC;QACJ,KAAK,GAAG,CAAC,CAAC;IACd,CAAC;IACD,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC;AACxB,CAAC;AAED,SAAS,4BAA4B,CAAC,IAAa,EAAE,QAAgB,EAAE,OAA4B,EAAE,KAAc;IAC/G,IAAI,CAAC,KAAK,EAAE,CAAC;QACT,MAAM,WAAW,OAAG,iOAAkB,EAAC,IAAI,CAAC,aAAa,EAAE,GAAG,CAAC,+NAAY,CAAC,CAAC;QAC7E,IAAI,WAAW,IAAI,WAAW,CAAC,OAAO,KAAK,QAAQ,EAAE,CAAC;YAClD,OAAO;gBAAC,IAAI;aAAC,CAAC;QAClB,CAAC;IACL,CAAC;IACD,QAAI,0NAAkB,EAAC,IAAI,CAAC,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;QACvD,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,EAAC,CAAC,CAAC,EAAE,AAAC,4BAA4B,CAAC,CAAC,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;IAChG,CAAC;IACD,OAAO,EAAE,CAAC;AACd,CAAC;AAQK,SAAU,mBAAmB,CAAC,IAAyB,EAAE,OAAe;IAC1E,IAAI,CAAC,IAAI,EAAE,CAAC;QACR,OAAO,EAAE,CAAC;IACd,CAAC;IACD,OAAO,2BAA2B,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,KAAA,QAAJ,IAAI,KAAA,KAAA,IAAA,KAAA,IAAJ,IAAI,CAAE,OAAO,CAAC,CAAC;AACrE,CAAC;AAWK,SAAU,kBAAkB,CAAC,IAAyB,EAAE,OAAe,EAAE,KAAc;IACzF,IAAI,CAAC,IAAI,EAAE,CAAC;QACR,OAAO,SAAS,CAAC;IACrB,CAAC;IACD,MAAM,KAAK,GAAG,2BAA2B,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,KAAA,QAAJ,IAAI,KAAA,KAAA,IAAA,KAAA,IAAJ,IAAI,CAAE,OAAO,CAAC,CAAC;IACxE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACrB,OAAO,SAAS,CAAC;IACrB,CAAC;IACD,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;QACtB,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3D,CAAC,MAAM,CAAC;QACJ,KAAK,GAAG,CAAC,CAAC;IACd,CAAC;IACD,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC;AACxB,CAAC;AAEK,SAAU,2BAA2B,CAAC,IAAa,EAAE,OAAe,EAAE,OAA4B;IACpG,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;QAC3B,OAAO,EAAE,CAAC;IACd,CAAC;IACD,IAAI,GAAG,CAAC,4NAAS,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,KAAK,OAAO,EAAE,CAAC;QAC5E,OAAO;YAAC,IAAI;SAAC,CAAC;IAClB,CAAC;IACD,MAAM,YAAY,OAAG,wNAAS,EAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC;IAChD,IAAI,MAA+B,CAAC;IACpC,MAAM,YAAY,GAAc,EAAE,CAAC;IACnC,GAAG,CAAC;QACA,MAAM,GAAG,YAAY,CAAC,IAAI,EAAE,CAAC;QAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;YACf,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC;YAC/B,IAAI,SAAS,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;gBAChC,IAAI,GAAG,CAAC,4NAAS,CAAC,SAAS,CAAC,aAAa,CAAC,IAAI,SAAS,CAAC,aAAa,CAAC,KAAK,KAAK,OAAO,EAAE,CAAC;oBACtF,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBACjC,CAAC;YACL,CAAC,MAAM,CAAC;gBACJ,YAAY,CAAC,KAAK,EAAE,CAAC;YACzB,CAAC;QACL,CAAC;IACL,CAAC,OAAQ,CAAC,MAAM,CAAC,IAAI,CAAE;IACvB,OAAO,YAAY,CAAC;AACxB,CAAC;AAQK,SAAU,cAAc,CAAC,OAAgB;;IAC3C,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChC,2FAA2F;IAC3F,8FAA8F;IAC9F,MAAO,OAAO,KAAA,CAAK,CAAA,KAAA,OAAO,CAAC,SAAS,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,OAAO,CAAA,CAAE,CAAC;QAC5C,MAAM,UAAU,OAAG,iOAAkB,EAAC,OAAO,CAAC,aAAa,EAAE,GAAG,CAAC,+NAAY,CAAC,CAAC;QAC/E,IAAI,UAAU,EAAE,CAAC;YACb,OAAO,UAAU,CAAC;QACtB,CAAC;QACD,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC;IAChC,CAAC;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAOK,SAAU,kBAAkB,CAAC,IAAsB;IACrD,IAAI,SAAS,GAAY,IAAI,CAAC;IAC9B,IAAI,GAAG,CAAC,iOAAc,CAAC,SAAS,CAAC,EAAE,CAAC;QAChC,2FAA2F;QAC3F,IAAI,GAAG,CAAC,2NAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC;YACrC,6IAA6I;YAC7I,SAAS,GAAG,SAAS,CAAC,UAAU,CAAC,UAAW,CAAC;QACjD,CAAC,MAAM,IAAI,GAAG,CAAC,+NAAY,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC;YAChD,gEAAgE;YAChE,SAAS,GAAG,SAAS,CAAC,UAAU,CAAC;QACrC,CAAC,MAAM,CAAC;gBACJ,0NAAiB,EAAC,SAAS,CAAC,UAAU,CAAC,CAAC;QAC5C,CAAC;IACL,CAAC;IACD,OAAO,0BAA0B,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;AAClE,CAAC;AAED,SAAS,0BAA0B,CAAC,IAAsB,EAAE,SAAkB,EAAE,KAAwD;;IACpI,uDAAuD;IACvD,SAAS,EAAE,CAAC,IAAa,EAAE,OAAyB;QAChD,IAAI,eAAe,GAA+B,SAAS,CAAC;QAC5D,MAAM,gBAAgB,OAAG,iOAAkB,EAAC,IAAI,EAAE,GAAG,CAAC,+NAAY,CAAC,CAAC;QACpE,oDAAoD;QACpD,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACpB,eAAe,GAAG,0BAA0B,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QAC1E,CAAC;QACD,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;QACjC,OAAO,eAAe,CAAC;IAC3B,CAAC;IAED,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;QAClB,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IACD,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IAC3B,KAAK,MAAM,IAAI,QAAI,gOAAiB,EAAC,SAAS,CAAC,CAAE,CAAC;QAC9C,IAAI,GAAG,CAAC,+NAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,MAAM,EAAE,CAAC;YAClE,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YACtB,OAAO,IAAI,CAAC;QAChB,CAAC,MAAM,IAAI,GAAG,CAAC,6NAAU,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,+NAAY,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;YACjE,OAAO,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACnC,CAAC,MAAM,IAAI,GAAG,CAAC,+NAAY,CAAC,IAAI,CAAC,IAAA,CAAI,CAAA,KAAA,IAAI,CAAC,OAAO,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,GAAG,CAAA,EAAE,CAAC;YACrD,OAAO,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACtC,CAAC;IACL,CAAC;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAEK,SAAU,kBAAkB,CAAC,OAA4B;IAC3D,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC;IAClC,IAAI,GAAG,CAAC,0NAAO,CAAC,MAAM,CAAC,EAAE,CAAC;QACtB,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;QACjC,MAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QACxC,IAAK,IAAI,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;YAClC,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YACzB,IAAI,GAAG,CAAC,2NAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;gBACrB,OAAO,IAAI,CAAC;YAChB,CAAC,MAAM,CAAC;gBACJ,MAAM,MAAM,OAAG,gOAAiB,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,2NAAQ,CAAC,CAAC;gBACjE,IAAI,MAAM,EAAE,CAAC;oBACT,OAAO,MAAM,CAAC;gBAClB,CAAC;YACL,CAAC;QACL,CAAC;IACL,CAAC;IACD,IAAI,GAAG,CAAC,oOAAiB,CAAC,MAAM,CAAC,EAAE,CAAC;QAChC,OAAO,kBAAkB,CAAC,MAAM,CAAC,CAAC;IACtC,CAAC,MAAM,CAAC;QACJ,OAAO,SAAS,CAAC;IACrB,CAAC;AACL,CAAC;AAKK,SAAU,qBAAqB,CAAC,WAAyB,EAAE,OAA6B;IAC1F,OAAO,WAAW,KAAK,GAAG,IAAI,WAAW,KAAK,GAAG,IAAI,AAAC,GAAG,CAAC,0NAAO,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC;AACnH,CAAC;AAEK,SAAU,kBAAkB,CAAC,WAAyB;IACxD,OAAO,WAAW,KAAK,GAAG,IAAI,WAAW,KAAK,GAAG,CAAC;AACtD,CAAC;AAEK,SAAU,eAAe,CAAC,QAAmB;IAC/C,OAAO,QAAQ,KAAK,IAAI,CAAC;AAC7B,CAAC;AAMK,SAAU,cAAc,CAAC,IAAoB;IAC/C,OAAO,sBAAsB,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;AACnD,CAAC;AAED,SAAS,sBAAsB,CAAC,IAAoB,EAAE,OAA4B;IAC9E,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;QACpB,OAAO,IAAI,CAAC;IAChB,CAAC,MAAM,CAAC;QACJ,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACtB,CAAC;IACD,KAAK,MAAM,IAAI,QAAI,gOAAiB,EAAC,IAAI,CAAC,CAAE,CAAC;QACzC,IAAI,GAAG,CAAC,6NAAU,CAAC,IAAI,CAAC,EAAE,CAAC;YACvB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;gBACjB,uEAAuE;gBACvE,OAAO,KAAK,CAAC;YACjB,CAAC;YACD,IAAI,GAAG,CAAC,+NAAY,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,EAAE,CAAC;gBACrF,OAAO,KAAK,CAAC;YACjB,CAAC;QACL,CAAC,MAAM,IAAI,GAAG,CAAC,+NAAY,CAAC,IAAI,CAAC,EAAE,CAAC;YAChC,OAAO,KAAK,CAAC;QACjB,CAAC,MAAM,IAAI,GAAG,CAAC,2NAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;YAC5B,OAAO,KAAK,CAAC;QACjB,CAAC;IACL,CAAC;IACD,OAAO,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACpC,CAAC;AAEK,SAAU,UAAU,CAAC,IAAc;IACrC,OAAO,kBAAkB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;AACpD,CAAC;AAED,SAAS,kBAAkB,CAAC,IAAwB,EAAE,OAAgC;IAClF,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;QACpB,OAAO,IAAI,CAAC;IAChB,CAAC,MAAM,CAAC;QACJ,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACtB,CAAC;IACD,IAAI,GAAG,CAAC,8NAAW,CAAC,IAAI,CAAC,EAAE,CAAC;QACxB,OAAO,KAAK,CAAC;IACjB,CAAC,MAAM,IAAI,GAAG,CAAC,kOAAe,CAAC,IAAI,CAAC,EAAE,CAAC;QACnC,OAAO,KAAK,CAAC;IACjB,CAAC,MAAM,IAAI,GAAG,CAAC,8NAAW,CAAC,IAAI,CAAC,EAAE,CAAC;QAC/B,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,EAAC,CAAC,CAAC,EAAE,AAAC,kBAAkB,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;IACjE,CAAC,MAAM,IAAI,GAAG,CAAC,+NAAY,CAAC,IAAI,CAAC,EAAE,CAAC;QAChC,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,EAAE,CAAC;YACnC,OAAO,IAAI,CAAC;QAChB,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;YACvC,OAAO,IAAI,CAAC;QAChB,CAAC,MAAM,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS,EAAE,CAAC;YACpC,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;YAC7B,IAAI,GAAG,CAAC,yNAAM,CAAC,GAAG,CAAC,EAAE,CAAC;gBAClB,OAAO,kBAAkB,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YACjD,CAAC,MAAM,CAAC;gBACJ,OAAO,KAAK,CAAC;YACjB,CAAC;QACL,CAAC,MAAM,CAAC;YACJ,OAAO,KAAK,CAAC;QACjB,CAAC;IACL,CAAC,MAAM,CAAC;QACJ,OAAO,KAAK,CAAC;IACjB,CAAC;AACL,CAAC;AAEK,SAAU,mBAAmB,CAAC,IAAoB;IACpD,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;IAClC,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;QACvB,OAAO,IAAI,CAAC,QAAQ,CAAC;IACzB,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;QACzB,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;QACpC,IAAI,OAAO,EAAE,CAAC;YACV,kDAAkD;YAClD,IAAI,GAAG,CAAC,+NAAY,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC5B,OAAO,OAAO,CAAC,IAAI,CAAC;YACxB,CAAC,MAAM,IAAI,GAAG,CAAC,8NAAW,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,yNAAM,CAAC,OAAO,CAAC,EAAE,CAAC;gBACzD,OAAO,OAAO,CAAC,IAAI,CAAC;YACxB,CAAC;QACL,CAAC;IACL,CAAC;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAEK,SAAU,WAAW,CAAC,IAAmC;;IAC3D,IAAI,GAAG,CAAC,+NAAY,CAAC,IAAI,CAAC,EAAE,CAAC;QACzB,OAAO,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA,KAAA,mBAAmB,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,IAAI,CAAC;IACrF,CAAC,MAAM,IAAI,GAAG,CAAC,8NAAW,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,yNAAM,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,+NAAY,CAAC,IAAI,CAAC,EAAE,CAAC;QAC7E,OAAO,IAAI,CAAC,IAAI,CAAC;IACrB,CAAC,MAAM,IAAI,GAAG,CAAC,2NAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;QAC5B,MAAM,UAAU,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QACvC,IAAI,UAAU,EAAE,CAAC;YACb,OAAO,UAAU,CAAC;QACtB,CAAC;IACL,CAAC,MAAM,IAAI,GAAG,CAAC,iOAAc,CAAC,IAAI,CAAC,EAAE,CAAC;QAClC,OAAO,IAAI,CAAC,IAAI,CAAC;IACrB,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;AACvD,CAAC;AAEK,SAAU,aAAa,CAAC,MAAkB;;IAC5C,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC;QACtB,OAAO,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC;IACpC,CAAC,MAAM,IAAI,CAAA,KAAA,MAAM,CAAC,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,GAAG,EAAE,CAAC;QAC1B,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACxC,CAAC;IACD,OAAO,SAAS,CAAC,CAAC,iDAAiD;AACvE,CAAC;AASK,SAAU,eAAe,CAAC,IAAsB;;IAClD,IAAI,GAAG,CAAC,iOAAc,CAAC,IAAI,CAAC,EAAE,CAAC;QAC3B,OAAO,CAAA,KAAA,CAAA,KAAA,IAAI,CAAC,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,QAAQ,CAAC;IACvC,CAAC,MAAM,CAAC;QACJ,OAAO,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA,KAAA,mBAAmB,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,IAAI,CAAC;IACrF,CAAC;AACL,CAAC;AASK,SAAU,WAAW,CAAC,IAAsB;;IAC9C,IAAI,GAAG,CAAC,iOAAc,CAAC,IAAI,CAAC,EAAE,CAAC;QAC3B,OAAO,CAAA,KAAA,CAAA,KAAA,IAAI,CAAC,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,QAAQ,CAAC;IACvC,CAAC,MAAM,CAAC;QACJ,OAAO,CAAA,KAAA,mBAAmB,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,IAAI,CAAC;IAClD,CAAC;AACL,CAAC;AAEK,SAAU,aAAa,CAAC,YAA8B;IACxD,MAAM,KAAK,GAAU;QACjB,CAAC,EAAE,KAAK;QACR,CAAC,EAAE,KAAK;QACR,CAAC,EAAE,KAAK;KACX,CAAC;IACF,MAAM,MAAM,GAAG,sBAAsB,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IACtE,MAAM,QAAQ,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,CAAG,CAAD,IAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnG,OAAO,IAAI,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;AACxC,CAAC;AAED,+FAA+F;AAC/F,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC;AAQjC,SAAS,sBAAsB,CAAC,OAA4B,EAAE,KAAa;IACvE,IAAI,GAAG,CAAC,yOAAsB,CAAC,OAAO,CAAC,EAAE,CAAC;QACtC,OAAO,2BAA2B,CAAC,OAAO,CAAC,CAAC;IAChD,CAAC,MAAM,IAAI,GAAG,CAAC,kOAAe,CAAC,OAAO,CAAC,EAAE,CAAC;QACtC,OAAO,oBAAoB,CAAC,OAAO,CAAC,CAAC;IACzC,CAAC,MAAM,IAAI,GAAG,CAAC,mOAAgB,CAAC,OAAO,CAAC,EAAE,CAAC;QACvC,OAAO,qBAAqB,CAAC,OAAO,CAAC,CAAC;IAC1C,CAAC,MAAM,IAAI,GAAG,CAAC,qOAAkB,CAAC,OAAO,CAAC,EAAE,CAAC;QACzC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;QAC9B,IAAI,CAAC,IAAI,EAAE,CAAC;YACR,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC/C,CAAC;QACD,OAAO,eAAe,CAAC,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YAC5D,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,SAAS,EAAE,OAAO,CAAC,SAAS;SAC/B,CAAC,CAAC;IACP,CAAC,MAAM,IAAI,GAAG,CAAC,iOAAc,CAAC,OAAO,CAAC,EAAE,CAAC;QACrC,OAAO,kBAAkB,CAAC,OAAO,CAAC,CAAC;IACvC,CAAC,MAAM,IAAI,GAAG,CAAC,+NAAY,CAAC,OAAO,CAAC,EAAE,CAAC;QACnC,OAAO,iBAAiB,CAAC,OAAO,CAAC,CAAC;IACtC,CAAC,MAAM,IAAI,GAAG,CAAC,+NAAY,CAAC,OAAO,CAAC,EAAE,CAAC;QACnC,MAAM,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QACjD,MAAM,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;QACrD,MAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;QAC1D,IAAI,KAAK,EAAE,CAAC;YACR,KAAK,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACnC,KAAK,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACnC,KAAK,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QACvC,CAAC;QACD,OAAO,eAAe,CAAC,MAAM,EAAE;YAC3B,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,SAAS,EAAE,OAAO,CAAC,SAAS;YAC5B,IAAI,EAAE,KAAK;SACd,CAAC,CAAC;IACP,CAAC,MAAM,IAAI,GAAG,CAAC,6NAAU,CAAC,OAAO,CAAC,EAAE,CAAC;QACjC,OAAO,eAAe,CAAC,QAAQ,EAAE;YAC7B,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,SAAS,EAAE,OAAO,CAAC,SAAS;SAC/B,CAAC,CAAC;IACP,CAAC,MAAM,CAAC;QACJ,MAAM,IAAI,KAAK,CAAC,CAAA,0BAAA,EAA6B,OAAO,KAAA,QAAP,OAAO,KAAA,KAAA,IAAA,KAAA,IAAP,OAAO,CAAE,KAAK,EAAE,CAAC,CAAC;IACnE,CAAC;AACL,CAAC;AAED,SAAS,2BAA2B,CAAC,YAAsC;IACvE,OAAO,eAAe,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,EAAC,CAAC,CAAC,EAAG,AAAD,sBAAuB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;QACxF,WAAW,EAAE,YAAY,CAAC,WAAW;QACrC,SAAS,EAAE,YAAY,CAAC,SAAS;KACpC,CAAC,CAAC;AACP,CAAC;AAED,SAAS,oBAAoB,CAAC,KAAwB;IAClD,OAAO,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAC,CAAC,CAAC,EAAE,AAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;QAChF,WAAW,EAAE,KAAK,CAAC,WAAW;QAC9B,SAAS,EAAE,KAAK,CAAC,SAAS;KAC7B,CAAC,CAAC;AACP,CAAC;AAED,SAAS,iBAAiB,CAAC,KAAqB;IAC5C,OAAO,eAAe,CAAC,GAAG,QAAQ,CAAA,EAAA,EAAK,sBAAsB,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,EAAE;QAC7E,WAAW,EAAE,KAAK,CAAC,WAAW;QAC9B,SAAS,EAAE,KAAK,CAAC,SAAS;KAC7B,CAAC,CAAC;AACP,CAAC;AAED,SAAS,kBAAkB,CAAC,MAAwB;IAChD,OAAO,eAAe,CAAC,CAAA,GAAA,EAAM,sBAAsB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA,CAAA,EAAI,QAAQ,CAAA,EAAA,CAAI,EAAE;QAClF,WAAW,EAAE,MAAM,CAAC,WAAW;QAC/B,SAAS,EAAE,MAAM,CAAC,SAAS;KAC9B,CAAC,CAAC;AACP,CAAC;AAED,SAAS,qBAAqB,CAAC,KAAyB;IACpD,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;QACd,OAAO,eAAe,CAAC,CAAA,CAAA,EAAI,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA,CAAA,EAAI,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA,CAAA,CAAG,EAAE;YACrF,WAAW,EAAE,KAAK,CAAC,WAAW;YAC9B,SAAS,EAAE,KAAK,CAAC,SAAS;YAC1B,IAAI,EAAE,KAAK;SACd,CAAC,CAAC;IACP,CAAC;IACD,OAAO,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QAC/C,WAAW,EAAE,KAAK,CAAC,WAAW;QAC9B,SAAS,EAAE,KAAK,CAAC,SAAS;QAC1B,IAAI,EAAE,KAAK;KACd,CAAC,CAAC;AACP,CAAC;AAED,SAAS,cAAc,CAAC,OAAoB;IACxC,WAAO,8NAAY,EAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACvC,CAAC;AAED,SAAS,eAAe,CAAC,KAAa,EAAE,OAIvC;;IACG,IAAI,OAAO,CAAC,IAAI,KAAK,KAAK,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;QAC9C,KAAK,GAAG,CAAA,CAAA,EAAI,CAAA,KAAA,OAAO,CAAC,SAAS,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE,GAAG,KAAK,CAAA,CAAA,CAAG,CAAC;IACnD,CAAC;IACD,IAAI,OAAO,CAAC,WAAW,EAAE,CAAC;QACtB,OAAO,GAAG,KAAK,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC;IAC5C,CAAC;IACD,OAAO,KAAK,CAAC;AACjB,CAAC"}},
    {"offset": {"line": 3317, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/languages/grammar-config.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/languages/grammar-config.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport { DefaultNameRegexp } from '../utils/cst-utils.js';\r\nimport { isCommentTerminal, terminalRegex } from '../utils/grammar-utils.js';\r\nimport { isMultilineComment } from '../utils/regexp-utils.js';\r\nimport { isTerminalRule } from './generated/ast.js';\r\n\r\nexport interface GrammarConfig {\r\n    /**\r\n     * Lists all rule names which are classified as multiline comment rules\r\n     */\r\n    multilineCommentRules: string[]\r\n    /**\r\n     * A regular expression which matches characters of names\r\n     */\r\n    nameRegexp: RegExp\r\n}\r\n\r\n/**\r\n * Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a\r\n * language-specific module.\r\n */\r\nexport function createGrammarConfig(services: LangiumCoreServices): GrammarConfig {\r\n    const rules: string[] = [];\r\n    const grammar = services.Grammar;\r\n    for (const rule of grammar.rules) {\r\n        if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\r\n            rules.push(rule.name);\r\n        }\r\n    }\r\n    return {\r\n        multilineCommentRules: rules,\r\n        nameRegexp: DefaultNameRegexp\r\n    };\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAGhF,OAAO,EAAE,iBAAiB,EAAE,MAAM,uBAAuB,CAAC;AAC1D,OAAO,EAAE,iBAAiB,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAC;AAC7E,OAAO,EAAE,kBAAkB,EAAE,MAAM,0BAA0B,CAAC;AAC9D,OAAO,EAAE,cAAc,EAAE,MAAM,oBAAoB,CAAC;;;;;AAiB9C,SAAU,mBAAmB,CAAC,QAA6B;IAC7D,MAAM,KAAK,GAAa,EAAE,CAAC;IAC3B,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IACjC,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,KAAK,CAAE,CAAC;QAC/B,QAAI,qOAAc,EAAC,IAAI,CAAC,QAAI,oOAAiB,EAAC,IAAI,CAAC,QAAI,oOAAkB,MAAC,gOAAa,EAAC,IAAI,CAAC,CAAC,EAAE,CAAC;YAC7F,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,CAAC;IACL,CAAC;IACD,OAAO;QACH,qBAAqB,EAAE,KAAK;QAC5B,UAAU,EAAE,gOAAiB;KAChC,CAAC;AACN,CAAC"}},
    {"offset": {"line": 3350, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/cst-node-builder.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/cst-node-builder.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IToken, TokenType } from 'chevrotain';\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport type { AbstractElement } from '../languages/generated/ast.js';\r\nimport type { AstNode, CompositeCstNode, CstNode, LeafCstNode, RootCstNode } from '../syntax-tree.js';\r\nimport { Position } from 'vscode-languageserver-types';\r\nimport { tokenToRange } from '../utils/cst-utils.js';\r\n\r\nexport class CstNodeBuilder {\r\n\r\n    private rootNode!: RootCstNodeImpl;\r\n    private nodeStack: CompositeCstNodeImpl[] = [];\r\n\r\n    get current(): CompositeCstNodeImpl {\r\n        return this.nodeStack[this.nodeStack.length - 1] ?? this.rootNode;\r\n    }\r\n\r\n    buildRootNode(input: string): RootCstNode {\r\n        this.rootNode = new RootCstNodeImpl(input);\r\n        this.rootNode.root = this.rootNode;\r\n        this.nodeStack = [this.rootNode];\r\n        return this.rootNode;\r\n    }\r\n\r\n    buildCompositeNode(feature: AbstractElement): CompositeCstNode {\r\n        const compositeNode = new CompositeCstNodeImpl();\r\n        compositeNode.grammarSource = feature;\r\n        compositeNode.root = this.rootNode;\r\n        this.current.content.push(compositeNode);\r\n        this.nodeStack.push(compositeNode);\r\n        return compositeNode;\r\n    }\r\n\r\n    buildLeafNode(token: IToken, feature?: AbstractElement): LeafCstNode {\r\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, !feature);\r\n        leafNode.grammarSource = feature;\r\n        leafNode.root = this.rootNode;\r\n        this.current.content.push(leafNode);\r\n        return leafNode;\r\n    }\r\n\r\n    removeNode(node: CstNode): void {\r\n        const parent = node.container;\r\n        if (parent) {\r\n            const index = parent.content.indexOf(node);\r\n            if (index >= 0) {\r\n                parent.content.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    addHiddenNodes(tokens: IToken[]): void {\r\n        const nodes: LeafCstNode[] = [];\r\n        for (const token of tokens) {\r\n            const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\r\n            leafNode.root = this.rootNode;\r\n            nodes.push(leafNode);\r\n        }\r\n        let current: CompositeCstNode = this.current;\r\n        let added = false;\r\n        // If we are within a composite node, we add the hidden nodes to the content\r\n        if (current.content.length > 0) {\r\n            current.content.push(...nodes);\r\n            return;\r\n        }\r\n        // Otherwise we are at a newly created node\r\n        // Instead of adding the hidden nodes here, we search for the first parent node with content\r\n        while (current.container) {\r\n            const index = current.container.content.indexOf(current);\r\n            if (index > 0) {\r\n                // Add the hidden nodes before the current node\r\n                current.container.content.splice(index, 0, ...nodes);\r\n                added = true;\r\n                break;\r\n            }\r\n            current = current.container;\r\n        }\r\n        // If we arrive at the root node, we add the hidden nodes at the beginning\r\n        // This is the case if the hidden nodes are the first nodes in the tree\r\n        if (!added) {\r\n            this.rootNode.content.unshift(...nodes);\r\n        }\r\n    }\r\n\r\n    construct(item: { $type: string | symbol | undefined, $cstNode: CstNode }): void {\r\n        const current: CstNode = this.current;\r\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\r\n        // Only if the $type is a string, we actually assign the element\r\n        if (typeof item.$type === 'string') {\r\n            this.current.astNode = <AstNode>item;\r\n        }\r\n        item.$cstNode = current;\r\n        const node = this.nodeStack.pop();\r\n        // Empty composite nodes are not valid\r\n        // Simply remove the node from the tree\r\n        if (node?.content.length === 0) {\r\n            this.removeNode(node);\r\n        }\r\n    }\r\n}\r\n\r\nexport abstract class AbstractCstNode implements CstNode {\r\n    abstract get offset(): number;\r\n    abstract get length(): number;\r\n    abstract get end(): number;\r\n    abstract get range(): Range;\r\n\r\n    container?: CompositeCstNode;\r\n    grammarSource?: AbstractElement;\r\n    root: RootCstNode;\r\n    private _astNode?: AstNode;\r\n\r\n    /** @deprecated use `container` instead. */\r\n    get parent(): CompositeCstNode | undefined {\r\n        return this.container;\r\n    }\r\n\r\n    /** @deprecated use `grammarSource` instead. */\r\n    get feature(): AbstractElement | undefined {\r\n        return this.grammarSource;\r\n    }\r\n\r\n    get hidden(): boolean {\r\n        return false;\r\n    }\r\n\r\n    get astNode(): AstNode {\r\n        const node = typeof this._astNode?.$type === 'string' ? this._astNode : this.container?.astNode;\r\n        if (!node) {\r\n            throw new Error('This node has no associated AST element');\r\n        }\r\n        return node;\r\n    }\r\n\r\n    set astNode(value: AstNode | undefined) {\r\n        this._astNode = value;\r\n    }\r\n\r\n    /** @deprecated use `astNode` instead. */\r\n    get element(): AstNode {\r\n        return this.astNode;\r\n    }\r\n\r\n    get text(): string {\r\n        return this.root.fullText.substring(this.offset, this.end);\r\n    }\r\n}\r\n\r\nexport class LeafCstNodeImpl extends AbstractCstNode implements LeafCstNode {\r\n    get offset(): number {\r\n        return this._offset;\r\n    }\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n    get end(): number {\r\n        return this._offset + this._length;\r\n    }\r\n\r\n    override get hidden(): boolean {\r\n        return this._hidden;\r\n    }\r\n\r\n    get tokenType(): TokenType {\r\n        return this._tokenType;\r\n    }\r\n\r\n    get range(): Range {\r\n        return this._range;\r\n    }\r\n\r\n    private _hidden: boolean;\r\n    private _offset: number;\r\n    private _length: number;\r\n    private _range: Range;\r\n    private _tokenType: TokenType;\r\n\r\n    constructor(offset: number, length: number, range: Range, tokenType: TokenType, hidden = false) {\r\n        super();\r\n        this._hidden = hidden;\r\n        this._offset = offset;\r\n        this._tokenType = tokenType;\r\n        this._length = length;\r\n        this._range = range;\r\n    }\r\n}\r\n\r\nexport class CompositeCstNodeImpl extends AbstractCstNode implements CompositeCstNode {\r\n    readonly content: CstNode[] = new CstNodeContainer(this);\r\n    private _rangeCache?: Range;\r\n\r\n    /** @deprecated use `content` instead. */\r\n    get children(): CstNode[] {\r\n        return this.content;\r\n    }\r\n\r\n    get offset(): number {\r\n        return this.firstNonHiddenNode?.offset ?? 0;\r\n    }\r\n\r\n    get length(): number {\r\n        return this.end - this.offset;\r\n    }\r\n\r\n    get end(): number {\r\n        return this.lastNonHiddenNode?.end ?? 0;\r\n    }\r\n\r\n    get range(): Range {\r\n        const firstNode = this.firstNonHiddenNode;\r\n        const lastNode = this.lastNonHiddenNode;\r\n        if (firstNode && lastNode) {\r\n            if (this._rangeCache === undefined) {\r\n                const { range: firstRange } = firstNode;\r\n                const { range: lastRange } = lastNode;\r\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\r\n            }\r\n            return this._rangeCache;\r\n        } else {\r\n            return { start: Position.create(0, 0), end: Position.create(0, 0) };\r\n        }\r\n    }\r\n\r\n    private get firstNonHiddenNode(): CstNode | undefined {\r\n        for (const child of this.content) {\r\n            if (!child.hidden) {\r\n                return child;\r\n            }\r\n        }\r\n        return this.content[0];\r\n    }\r\n\r\n    private get lastNonHiddenNode(): CstNode | undefined {\r\n        for (let i = this.content.length - 1; i >= 0; i--) {\r\n            const child = this.content[i];\r\n            if (!child.hidden) {\r\n                return child;\r\n            }\r\n        }\r\n        return this.content[this.content.length - 1];\r\n    }\r\n}\r\n\r\nclass CstNodeContainer extends Array<CstNode> {\r\n    readonly parent: CompositeCstNode;\r\n\r\n    constructor(parent: CompositeCstNode) {\r\n        super();\r\n        this.parent = parent;\r\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\r\n    }\r\n\r\n    override push(...items: CstNode[]): number {\r\n        this.addParents(items);\r\n        return super.push(...items);\r\n    }\r\n\r\n    override unshift(...items: CstNode[]): number {\r\n        this.addParents(items);\r\n        return super.unshift(...items);\r\n    }\r\n\r\n    override splice(start: number, count: number, ...items: CstNode[]): CstNode[] {\r\n        this.addParents(items);\r\n        return super.splice(start, count, ...items);\r\n    }\r\n\r\n    private addParents(items: CstNode[]): void {\r\n        for (const item of items) {\r\n            (<AbstractCstNode>item).container = this.parent;\r\n        }\r\n    }\r\n}\r\n\r\nexport class RootCstNodeImpl extends CompositeCstNodeImpl implements RootCstNode {\r\n    private _text = '';\r\n\r\n    override get text(): string {\r\n        return this._text.substring(this.offset, this.end);\r\n    }\r\n\r\n    get fullText(): string {\r\n        return this._text;\r\n    }\r\n\r\n    constructor(input?: string) {\r\n        super();\r\n        this._text = input ?? '';\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3612, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/langium-parser.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/langium-parser.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport type { DSLMethodOpts, ILexingError, IOrAlt, IParserErrorMessageProvider, IRecognitionException, IToken, TokenType, TokenVocabulary } from 'chevrotain';\r\nimport type { AbstractElement, Action, Assignment, ParserRule } from '../languages/generated/ast.js';\r\nimport type { Linker } from '../references/linker.js';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstReflection, CompositeCstNode, CstNode } from '../syntax-tree.js';\r\nimport type { Lexer, LexerResult } from './lexer.js';\r\nimport type { IParserConfig } from './parser-config.js';\r\nimport type { ValueConverter } from './value-converter.js';\r\nimport { defaultParserErrorProvider, EmbeddedActionsParser, LLkLookaheadStrategy } from 'chevrotain';\r\nimport { LLStarLookaheadStrategy } from 'chevrotain-allstar';\r\nimport { isAssignment, isCrossReference, isKeyword } from '../languages/generated/ast.js';\r\nimport { getExplicitRuleType, isDataTypeRule } from '../utils/grammar-utils.js';\r\nimport { assignMandatoryProperties, getContainerOfType, linkContentToContainer } from '../utils/ast-utils.js';\r\nimport { CstNodeBuilder } from './cst-node-builder.js';\r\nimport type { LexingReport } from './token-builder.js';\r\n\r\nexport type ParseResult<T = AstNode> = {\r\n    value: T,\r\n    parserErrors: IRecognitionException[],\r\n    lexerErrors: ILexingError[],\r\n    lexerReport?: LexingReport\r\n}\r\n\r\nexport const DatatypeSymbol = Symbol('Datatype');\r\n\r\ninterface DataTypeNode {\r\n    $cstNode: CompositeCstNode\r\n    /** Instead of a string, this node is uniquely identified by the `Datatype` symbol */\r\n    $type: symbol\r\n    /** Used as a storage for all parsed terminals, keywords and sub-datatype rules */\r\n    value: string\r\n}\r\n\r\nfunction isDataTypeNode(node: { $type: string | symbol | undefined }): node is DataTypeNode {\r\n    return node.$type === DatatypeSymbol;\r\n}\r\n\r\ntype RuleResult = (args: Args) => any;\r\n\r\ntype Args = Record<string, boolean>;\r\n\r\ntype RuleImpl = (args: Args) => any;\r\n\r\ninterface AssignmentElement {\r\n    assignment?: Assignment\r\n    isCrossRef: boolean\r\n}\r\n\r\n/**\r\n * Base interface for all parsers. Mainly used by the `parser-builder-base.ts` to perform work on different kinds of parsers.\r\n * The main use cases are:\r\n * * AST parser: Based on a string, create an AST for the current grammar\r\n * * Completion parser: Based on a partial string, identify the current position of the input within the grammar\r\n */\r\nexport interface BaseParser {\r\n    /**\r\n     * Adds a new parser rule to the parser\r\n     */\r\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult;\r\n    /**\r\n     * Returns the executable rule function for the specified rule name\r\n     */\r\n    getRule(name: string): RuleResult | undefined;\r\n    /**\r\n     * Performs alternatives parsing (the `|` operation in EBNF/Langium)\r\n     */\r\n    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;\r\n    /**\r\n     * Parses the callback as optional (the `?` operation in EBNF/Langium)\r\n     */\r\n    optional(idx: number, callback: DSLMethodOpts<unknown>): void;\r\n    /**\r\n     * Parses the callback 0 or more times (the `*` operation in EBNF/Langium)\r\n     */\r\n    many(idx: number, callback: DSLMethodOpts<unknown>): void;\r\n    /**\r\n     * Parses the callback 1 or more times (the `+` operation in EBNF/Langium)\r\n     */\r\n    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;\r\n    /**\r\n     * Consumes a specific token type from the token input stream.\r\n     * Requires a unique index within the rule for a specific token type.\r\n     */\r\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;\r\n    /**\r\n     * Invokes the executable function for a given parser rule.\r\n     * Requires a unique index within the rule for a specific sub rule.\r\n     * Arguments can be supplied to the rule invocation for semantic predicates\r\n     */\r\n    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;\r\n    /**\r\n     * Executes a grammar action that modifies the currently active AST node\r\n     */\r\n    action($type: string, action: Action): void;\r\n    /**\r\n     * Finishes construction of the current AST node. Only used by the AST parser.\r\n     */\r\n    construct(): unknown;\r\n    /**\r\n     * Whether the parser is currently actually in use or in \"recording mode\".\r\n     * Recording mode is activated once when the parser is analyzing itself.\r\n     * During this phase, no input exists and therefore no AST should be constructed\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Current state of the unordered groups\r\n     */\r\n    get unorderedGroups(): Map<string, boolean[]>;\r\n    /**\r\n     * The rule stack indicates the indices of rules that are currently invoked,\r\n     * in order of their invocation.\r\n     */\r\n    getRuleStack(): number[];\r\n}\r\n\r\nconst ruleSuffix = '\\u200B';\r\nconst withRuleSuffix = (name: string): string => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\r\n\r\nexport abstract class AbstractLangiumParser implements BaseParser {\r\n\r\n    protected readonly lexer: Lexer;\r\n    protected readonly wrapper: ChevrotainWrapper;\r\n    protected _unorderedGroups: Map<string, boolean[]> = new Map<string, boolean[]>();\r\n\r\n    protected allRules = new Map<string, RuleResult>();\r\n    protected mainRule!: RuleResult;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.lexer = services.parser.Lexer;\r\n        const tokens = this.lexer.definition;\r\n        const production = services.LanguageMetaData.mode === 'production';\r\n        this.wrapper = new ChevrotainWrapper(tokens, {\r\n            ...services.parser.ParserConfig,\r\n            skipValidations: production,\r\n            errorMessageProvider: services.parser.ParserErrorMessageProvider\r\n        });\r\n    }\r\n\r\n    alternatives(idx: number, choices: Array<IOrAlt<any>>): void {\r\n        this.wrapper.wrapOr(idx, choices);\r\n    }\r\n\r\n    optional(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.wrapper.wrapOption(idx, callback);\r\n    }\r\n\r\n    many(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.wrapper.wrapMany(idx, callback);\r\n    }\r\n\r\n    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.wrapper.wrapAtLeastOne(idx, callback);\r\n    }\r\n\r\n    abstract rule(rule: ParserRule, impl: RuleImpl): RuleResult;\r\n    abstract consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;\r\n    abstract subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;\r\n    abstract action($type: string, action: Action): void;\r\n    abstract construct(): unknown;\r\n\r\n    getRule(name: string): RuleResult | undefined {\r\n        return this.allRules.get(name);\r\n    }\r\n\r\n    isRecording(): boolean {\r\n        return this.wrapper.IS_RECORDING;\r\n    }\r\n\r\n    get unorderedGroups(): Map<string, boolean[]> {\r\n        return this._unorderedGroups;\r\n    }\r\n\r\n    getRuleStack(): number[] {\r\n        return (this.wrapper as any).RULE_STACK;\r\n    }\r\n\r\n    finalize(): void {\r\n        this.wrapper.wrapSelfAnalysis();\r\n    }\r\n}\r\n\r\nexport interface ParserOptions {\r\n    rule?: string\r\n}\r\n\r\nexport class LangiumParser extends AbstractLangiumParser {\r\n    private readonly linker: Linker;\r\n    private readonly converter: ValueConverter;\r\n    private readonly astReflection: AstReflection;\r\n    private readonly nodeBuilder = new CstNodeBuilder();\r\n    private lexerResult?: LexerResult;\r\n    private stack: any[] = [];\r\n    private assignmentMap = new Map<AbstractElement, AssignmentElement | undefined>();\r\n\r\n    private get current(): any {\r\n        return this.stack[this.stack.length - 1];\r\n    }\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        super(services);\r\n        this.linker = services.references.Linker;\r\n        this.converter = services.parser.ValueConverter;\r\n        this.astReflection = services.shared.AstReflection;\r\n    }\r\n\r\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult {\r\n        const type = this.computeRuleType(rule);\r\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\r\n        this.allRules.set(rule.name, ruleMethod);\r\n        if (rule.entry) {\r\n            this.mainRule = ruleMethod;\r\n        }\r\n        return ruleMethod;\r\n    }\r\n\r\n    private computeRuleType(rule: ParserRule): string | symbol | undefined {\r\n        if (rule.fragment) {\r\n            return undefined;\r\n        } else if (isDataTypeRule(rule)) {\r\n            return DatatypeSymbol;\r\n        } else {\r\n            const explicit = getExplicitRuleType(rule);\r\n            return explicit ?? rule.name;\r\n        }\r\n    }\r\n\r\n    parse<T extends AstNode = AstNode>(input: string, options: ParserOptions = {}): ParseResult<T> {\r\n        this.nodeBuilder.buildRootNode(input);\r\n        const lexerResult = this.lexerResult = this.lexer.tokenize(input);\r\n        this.wrapper.input = lexerResult.tokens;\r\n        const ruleMethod = options.rule ? this.allRules.get(options.rule) : this.mainRule;\r\n        if (!ruleMethod) {\r\n            throw new Error(options.rule ? `No rule found with name '${options.rule}'` : 'No main rule available.');\r\n        }\r\n        const result = ruleMethod.call(this.wrapper, {});\r\n        this.nodeBuilder.addHiddenNodes(lexerResult.hidden);\r\n        this.unorderedGroups.clear();\r\n        this.lexerResult = undefined;\r\n        return {\r\n            value: result,\r\n            lexerErrors: lexerResult.errors,\r\n            lexerReport: lexerResult.report,\r\n            parserErrors: this.wrapper.errors\r\n        };\r\n    }\r\n\r\n    private startImplementation($type: string | symbol | undefined, implementation: RuleImpl): RuleImpl {\r\n        return (args) => {\r\n            // Only create a new AST node in case the calling rule is not a fragment rule\r\n            const createNode = !this.isRecording() && $type !== undefined;\r\n            if (createNode) {\r\n                const node: any = { $type };\r\n                this.stack.push(node);\r\n                if ($type === DatatypeSymbol) {\r\n                    node.value = '';\r\n                }\r\n            }\r\n            let result: unknown;\r\n            try {\r\n                result = implementation(args);\r\n            } catch (err) {\r\n                result = undefined;\r\n            }\r\n            if (result === undefined && createNode) {\r\n                result = this.construct();\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n\r\n    private extractHiddenTokens(token: IToken): IToken[] {\r\n        const hiddenTokens = this.lexerResult!.hidden;\r\n        if (!hiddenTokens.length) {\r\n            return [];\r\n        }\r\n        const offset = token.startOffset;\r\n        for (let i = 0; i < hiddenTokens.length; i++) {\r\n            const token = hiddenTokens[i];\r\n            if (token.startOffset > offset) {\r\n                return hiddenTokens.splice(0, i);\r\n            }\r\n        }\r\n        return hiddenTokens.splice(0, hiddenTokens.length);\r\n    }\r\n\r\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void {\r\n        const token = this.wrapper.wrapConsume(idx, tokenType);\r\n        if (!this.isRecording() && this.isValidToken(token)) {\r\n            const hiddenTokens = this.extractHiddenTokens(token);\r\n            this.nodeBuilder.addHiddenNodes(hiddenTokens);\r\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\r\n            const { assignment, isCrossRef } = this.getAssignment(feature);\r\n            const current = this.current;\r\n            if (assignment) {\r\n                const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\r\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\r\n            } else if (isDataTypeNode(current)) {\r\n                let text = token.image;\r\n                if (!isKeyword(feature)) {\r\n                    text = this.converter.convert(text, leafNode).toString();\r\n                }\r\n                current.value += text;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\r\n     *\r\n     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\r\n     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\r\n     */\r\n    private isValidToken(token: IToken): boolean {\r\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === 'number' && !isNaN(token.endOffset);\r\n    }\r\n\r\n    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void {\r\n        let cstNode: CompositeCstNode | undefined;\r\n        if (!this.isRecording() && !fragment) {\r\n            // We only want to create a new CST node if the subrule actually creates a new AST node.\r\n            // In other cases like calls of fragment rules the current CST/AST is populated further.\r\n            // Note that skipping this initialization and leaving cstNode unassigned also skips the subrule assignment later on.\r\n            // This is intended, as fragment rules only enrich the current AST node\r\n            cstNode = this.nodeBuilder.buildCompositeNode(feature);\r\n        }\r\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args) as any;\r\n        if (!this.isRecording() && cstNode && cstNode.length > 0) {\r\n            this.performSubruleAssignment(subruleResult, feature, cstNode);\r\n        }\r\n    }\r\n\r\n    private performSubruleAssignment(result: any, feature: AbstractElement, cstNode: CompositeCstNode): void {\r\n        const { assignment, isCrossRef } = this.getAssignment(feature);\r\n        if (assignment) {\r\n            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\r\n        } else if (!assignment) {\r\n            // If we call a subrule without an assignment we either:\r\n            // 1. append the result of the subrule (data type rule)\r\n            // 2. override the current object with the newly parsed object\r\n            // If the current element is an AST node and the result of the subrule\r\n            // is a data type rule, we can safely discard the results.\r\n            const current = this.current;\r\n            if (isDataTypeNode(current)) {\r\n                current.value += result.toString();\r\n            } else if (typeof result === 'object' && result) {\r\n                const object = this.assignWithoutOverride(result, current);\r\n                const newItem = object;\r\n                this.stack.pop();\r\n                this.stack.push(newItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    action($type: string, action: Action): void {\r\n        if (!this.isRecording()) {\r\n            let last = this.current;\r\n            if (action.feature && action.operator) {\r\n                last = this.construct();\r\n                this.nodeBuilder.removeNode(last.$cstNode);\r\n                const node = this.nodeBuilder.buildCompositeNode(action);\r\n                node.content.push(last.$cstNode);\r\n                const newItem = { $type };\r\n                this.stack.push(newItem);\r\n                this.assign(action.operator, action.feature, last, last.$cstNode, false);\r\n            } else {\r\n                last.$type = $type;\r\n            }\r\n        }\r\n    }\r\n\r\n    construct(): unknown {\r\n        if (this.isRecording()) {\r\n            return undefined;\r\n        }\r\n        const obj = this.current;\r\n        linkContentToContainer(obj);\r\n        this.nodeBuilder.construct(obj);\r\n        this.stack.pop();\r\n        if (isDataTypeNode(obj)) {\r\n            return this.converter.convert(obj.value, obj.$cstNode);\r\n        } else {\r\n            assignMandatoryProperties(this.astReflection, obj);\r\n        }\r\n        return obj;\r\n    }\r\n\r\n    private getAssignment(feature: AbstractElement): AssignmentElement {\r\n        if (!this.assignmentMap.has(feature)) {\r\n            const assignment = getContainerOfType(feature, isAssignment);\r\n            this.assignmentMap.set(feature, {\r\n                assignment: assignment,\r\n                isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\r\n            });\r\n        }\r\n        return this.assignmentMap.get(feature)!;\r\n    }\r\n\r\n    private assign(operator: string, feature: string, value: unknown, cstNode: CstNode, isCrossRef: boolean): void {\r\n        const obj = this.current;\r\n        let item: unknown;\r\n        if (isCrossRef && typeof value === 'string') {\r\n            item = this.linker.buildReference(obj, feature, cstNode, value);\r\n        } else {\r\n            item = value;\r\n        }\r\n        switch (operator) {\r\n            case '=': {\r\n                obj[feature] = item;\r\n                break;\r\n            }\r\n            case '?=': {\r\n                obj[feature] = true;\r\n                break;\r\n            }\r\n            case '+=': {\r\n                if (!Array.isArray(obj[feature])) {\r\n                    obj[feature] = [];\r\n                }\r\n                obj[feature].push(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    private assignWithoutOverride(target: any, source: any): any {\r\n        for (const [name, existingValue] of Object.entries(source)) {\r\n            const newValue = target[name];\r\n            if (newValue === undefined) {\r\n                target[name] = existingValue;\r\n            } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\r\n                existingValue.push(...newValue);\r\n                target[name] = existingValue;\r\n            }\r\n        }\r\n        // The target was parsed from a unassigned subrule\r\n        // After the subrule construction, it received a cst node\r\n        // This CST node will later be overriden by the cst node builder\r\n        // To prevent references to stale AST nodes in the CST,\r\n        // we need to remove the reference here\r\n        const targetCstNode = target.$cstNode;\r\n        if (targetCstNode) {\r\n            targetCstNode.astNode = undefined;\r\n            target.$cstNode = undefined;\r\n        }\r\n        return target;\r\n    }\r\n\r\n    get definitionErrors(): IParserDefinitionError[] {\r\n        return this.wrapper.definitionErrors;\r\n    }\r\n}\r\n\r\nexport interface IParserDefinitionError {\r\n    message: string\r\n    type: number\r\n    ruleName?: string\r\n}\r\n\r\nexport abstract class AbstractParserErrorMessageProvider implements IParserErrorMessageProvider {\r\n\r\n    buildMismatchTokenMessage(options: {\r\n        expected: TokenType\r\n        actual: IToken\r\n        previous: IToken\r\n        ruleName: string\r\n    }): string {\r\n        return defaultParserErrorProvider.buildMismatchTokenMessage(options);\r\n    }\r\n\r\n    buildNotAllInputParsedMessage(options: {\r\n        firstRedundant: IToken\r\n        ruleName: string\r\n    }): string {\r\n        return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\r\n    }\r\n\r\n    buildNoViableAltMessage(options: {\r\n        expectedPathsPerAlt: TokenType[][][]\r\n        actual: IToken[]\r\n        previous: IToken\r\n        customUserDescription: string\r\n        ruleName: string\r\n    }): string {\r\n        return defaultParserErrorProvider.buildNoViableAltMessage(options);\r\n    }\r\n\r\n    buildEarlyExitMessage(options: {\r\n        expectedIterationPaths: TokenType[][]\r\n        actual: IToken[]\r\n        previous: IToken\r\n        customUserDescription: string\r\n        ruleName: string\r\n    }): string {\r\n        return defaultParserErrorProvider.buildEarlyExitMessage(options);\r\n    }\r\n\r\n}\r\n\r\nexport class LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\r\n\r\n    override buildMismatchTokenMessage({ expected, actual }: {\r\n        expected: TokenType\r\n        actual: IToken\r\n        previous: IToken\r\n        ruleName: string\r\n    }): string {\r\n        const expectedMsg = expected.LABEL\r\n            ? '`' + expected.LABEL + '`'\r\n            : expected.name.endsWith(':KW')\r\n                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`\r\n                : `token of type '${expected.name}'`;\r\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\r\n    }\r\n\r\n    override buildNotAllInputParsedMessage({ firstRedundant }: {\r\n        firstRedundant: IToken\r\n        ruleName: string\r\n    }): string {\r\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\r\n    }\r\n}\r\n\r\nexport interface CompletionParserResult {\r\n    tokens: IToken[]\r\n    elementStack: AbstractElement[]\r\n    tokenIndex: number\r\n}\r\n\r\nexport class LangiumCompletionParser extends AbstractLangiumParser {\r\n    private tokens: IToken[] = [];\r\n\r\n    private elementStack: AbstractElement[] = [];\r\n    private lastElementStack: AbstractElement[] = [];\r\n    private nextTokenIndex = 0;\r\n    private stackSize = 0;\r\n\r\n    action(): void {\r\n        // NOOP\r\n    }\r\n\r\n    construct(): unknown {\r\n        // NOOP\r\n        return undefined;\r\n    }\r\n\r\n    parse(input: string): CompletionParserResult {\r\n        this.resetState();\r\n        const tokens = this.lexer.tokenize(input, { mode: 'partial' });\r\n        this.tokens = tokens.tokens;\r\n        this.wrapper.input = [...this.tokens];\r\n        this.mainRule.call(this.wrapper, {});\r\n        this.unorderedGroups.clear();\r\n        return {\r\n            tokens: this.tokens,\r\n            elementStack: [...this.lastElementStack],\r\n            tokenIndex: this.nextTokenIndex\r\n        };\r\n    }\r\n\r\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult {\r\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\r\n        this.allRules.set(rule.name, ruleMethod);\r\n        if (rule.entry) {\r\n            this.mainRule = ruleMethod;\r\n        }\r\n        return ruleMethod;\r\n    }\r\n\r\n    private resetState(): void {\r\n        this.elementStack = [];\r\n        this.lastElementStack = [];\r\n        this.nextTokenIndex = 0;\r\n        this.stackSize = 0;\r\n    }\r\n\r\n    private startImplementation(implementation: RuleImpl): RuleImpl {\r\n        return (args) => {\r\n            const size = this.keepStackSize();\r\n            try {\r\n                implementation(args);\r\n            } finally {\r\n                this.resetStackSize(size);\r\n            }\r\n        };\r\n    }\r\n\r\n    private removeUnexpectedElements(): void {\r\n        this.elementStack.splice(this.stackSize);\r\n    }\r\n\r\n    keepStackSize(): number {\r\n        const size = this.elementStack.length;\r\n        this.stackSize = size;\r\n        return size;\r\n    }\r\n\r\n    resetStackSize(size: number): void {\r\n        this.removeUnexpectedElements();\r\n        this.stackSize = size;\r\n    }\r\n\r\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void {\r\n        this.wrapper.wrapConsume(idx, tokenType);\r\n        if (!this.isRecording()) {\r\n            this.lastElementStack = [...this.elementStack, feature];\r\n            this.nextTokenIndex = this.currIdx + 1;\r\n        }\r\n    }\r\n\r\n    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void {\r\n        this.before(feature);\r\n        this.wrapper.wrapSubrule(idx, rule, args);\r\n        this.after(feature);\r\n    }\r\n\r\n    before(element: AbstractElement): void {\r\n        if (!this.isRecording()) {\r\n            this.elementStack.push(element);\r\n        }\r\n    }\r\n\r\n    after(element: AbstractElement): void {\r\n        if (!this.isRecording()) {\r\n            const index = this.elementStack.lastIndexOf(element);\r\n            if (index >= 0) {\r\n                this.elementStack.splice(index);\r\n            }\r\n        }\r\n    }\r\n\r\n    get currIdx(): number {\r\n        return (this.wrapper as any).currIdx;\r\n    }\r\n}\r\n\r\nconst defaultConfig: IParserConfig = {\r\n    recoveryEnabled: true,\r\n    nodeLocationTracking: 'full',\r\n    skipValidations: true,\r\n    errorMessageProvider: new LangiumParserErrorMessageProvider()\r\n};\r\n\r\n/**\r\n * This class wraps the embedded actions parser of chevrotain and exposes protected methods.\r\n * This way, we can build the `LangiumParser` as a composition.\r\n */\r\nclass ChevrotainWrapper extends EmbeddedActionsParser {\r\n\r\n    // This array is set in the base implementation of Chevrotain.\r\n    definitionErrors: IParserDefinitionError[];\r\n\r\n    constructor(tokens: TokenVocabulary, config: IParserConfig) {\r\n        const useDefaultLookahead = config && 'maxLookahead' in config;\r\n        super(tokens, {\r\n            ...defaultConfig,\r\n            lookaheadStrategy: useDefaultLookahead\r\n                ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })\r\n                : new LLStarLookaheadStrategy({\r\n                    // If validations are skipped, don't log the lookahead warnings\r\n                    logging: config.skipValidations ? () => { } : undefined\r\n                }),\r\n            ...config,\r\n        });\r\n    }\r\n\r\n    get IS_RECORDING(): boolean {\r\n        return this.RECORDING_PHASE;\r\n    }\r\n\r\n    DEFINE_RULE(name: string, impl: RuleImpl): RuleResult {\r\n        return this.RULE(name, impl);\r\n    }\r\n\r\n    wrapSelfAnalysis(): void {\r\n        this.performSelfAnalysis();\r\n    }\r\n\r\n    wrapConsume(idx: number, tokenType: TokenType): IToken {\r\n        return this.consume(idx, tokenType);\r\n    }\r\n\r\n    wrapSubrule(idx: number, rule: RuleResult, args: Args): unknown {\r\n        return this.subrule(idx, rule, {\r\n            ARGS: [args]\r\n        });\r\n    }\r\n\r\n    wrapOr(idx: number, choices: Array<IOrAlt<any>>): void {\r\n        this.or(idx, choices);\r\n    }\r\n\r\n    wrapOption(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.option(idx, callback);\r\n    }\r\n\r\n    wrapMany(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.many(idx, callback);\r\n    }\r\n\r\n    wrapAtLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.atLeastOne(idx, callback);\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4125, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/parser-builder-base.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/parser-builder-base.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IOrAlt, TokenType, TokenTypeDictionary } from 'chevrotain';\r\nimport type { AbstractElement, Action, Alternatives, Condition, CrossReference, Grammar, Group, Keyword, NamedArgument, ParserRule, RuleCall, UnorderedGroup } from '../languages/generated/ast.js';\r\nimport type { BaseParser } from './langium-parser.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { Cardinality } from '../utils/grammar-utils.js';\r\nimport { EMPTY_ALT, EOF } from 'chevrotain';\r\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';\r\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';\r\n\r\ntype RuleContext = {\r\n    optional: number,\r\n    consume: number,\r\n    subrule: number,\r\n    many: number,\r\n    or: number\r\n} & ParserContext;\r\n\r\ntype ParserContext = {\r\n    parser: BaseParser\r\n    tokens: TokenTypeDictionary\r\n    ruleNames: Map<AstNode, string>\r\n}\r\n\r\ntype Rule = (args: Args) => unknown;\r\n\r\ntype Args = Record<string, boolean>;\r\n\r\ntype Predicate = (args: Args) => boolean;\r\n\r\ntype Method = (args: Args) => void;\r\n\r\nexport function createParser<T extends BaseParser>(grammar: Grammar, parser: T, tokens: TokenTypeDictionary): T {\r\n    const parserContext: ParserContext = {\r\n        parser,\r\n        tokens,\r\n        ruleNames: new Map()\r\n    };\r\n    buildRules(parserContext, grammar);\r\n    return parser;\r\n}\r\n\r\nfunction buildRules(parserContext: ParserContext, grammar: Grammar): void {\r\n    const reachable = getAllReachableRules(grammar, false);\r\n    const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\r\n    for (const rule of parserRules) {\r\n        const ctx: RuleContext = {\r\n            ...parserContext,\r\n            consume: 1,\r\n            optional: 1,\r\n            subrule: 1,\r\n            many: 1,\r\n            or: 1\r\n        };\r\n        parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\r\n    }\r\n}\r\n\r\nfunction buildElement(ctx: RuleContext, element: AbstractElement, ignoreGuard = false): Method {\r\n    let method: Method;\r\n    if (isKeyword(element)) {\r\n        method = buildKeyword(ctx, element);\r\n    } else if (isAction(element)) {\r\n        method = buildAction(ctx, element);\r\n    } else if (isAssignment(element)) {\r\n        method = buildElement(ctx, element.terminal);\r\n    } else if (isCrossReference(element)) {\r\n        method = buildCrossReference(ctx, element);\r\n    } else if (isRuleCall(element)) {\r\n        method = buildRuleCall(ctx, element);\r\n    } else if (isAlternatives(element)) {\r\n        method = buildAlternatives(ctx, element);\r\n    } else if (isUnorderedGroup(element)) {\r\n        method = buildUnorderedGroup(ctx, element);\r\n    } else if (isGroup(element)) {\r\n        method = buildGroup(ctx, element);\r\n    } else if(isEndOfFile(element)) {\r\n        const idx = ctx.consume++;\r\n        method = () => ctx.parser.consume(idx, EOF, element);\r\n    } else {\r\n        throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\r\n    }\r\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\r\n}\r\n\r\nfunction buildAction(ctx: RuleContext, action: Action): Method {\r\n    const actionType = getTypeName(action);\r\n    return () => ctx.parser.action(actionType, action);\r\n}\r\n\r\nfunction buildRuleCall(ctx: RuleContext, ruleCall: RuleCall): Method {\r\n    const rule = ruleCall.rule.ref;\r\n    if (isParserRule(rule)) {\r\n        const idx = ctx.subrule++;\r\n        const fragment = rule.fragment;\r\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\r\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\r\n    } else if (isTerminalRule(rule)) {\r\n        const idx = ctx.consume++;\r\n        const method = getToken(ctx, rule.name);\r\n        return () => ctx.parser.consume(idx, method, ruleCall);\r\n    } else if (!rule) {\r\n        throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);\r\n    } else {\r\n        assertUnreachable(rule);\r\n    }\r\n}\r\n\r\nfunction buildRuleCallPredicate(rule: ParserRule, namedArgs: NamedArgument[]): (args: Args) => Args {\r\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\r\n    return (args) => {\r\n        const ruleArgs: Args = {};\r\n        for (let i = 0; i < predicates.length; i++) {\r\n            const ruleTarget = rule.parameters[i];\r\n            const predicate = predicates[i];\r\n            ruleArgs[ruleTarget.name] = predicate(args);\r\n        }\r\n        return ruleArgs;\r\n    };\r\n}\r\n\r\ninterface PredicatedMethod {\r\n    ALT: Method,\r\n    GATE?: Predicate\r\n}\r\n\r\nfunction buildPredicate(condition: Condition): Predicate {\r\n    if (isDisjunction(condition)) {\r\n        const left = buildPredicate(condition.left);\r\n        const right = buildPredicate(condition.right);\r\n        return (args) => (left(args) || right(args));\r\n    } else if (isConjunction(condition)) {\r\n        const left = buildPredicate(condition.left);\r\n        const right = buildPredicate(condition.right);\r\n        return (args) => (left(args) && right(args));\r\n    } else if (isNegation(condition)) {\r\n        const value = buildPredicate(condition.value);\r\n        return (args) => !value(args);\r\n    } else if (isParameterReference(condition)) {\r\n        const name = condition.parameter.ref!.name;\r\n        return (args) => args !== undefined && args[name] === true;\r\n    } else if (isBooleanLiteral(condition)) {\r\n        const value = Boolean(condition.true);\r\n        return () => value;\r\n    }\r\n    assertUnreachable(condition);\r\n}\r\n\r\nfunction buildAlternatives(ctx: RuleContext, alternatives: Alternatives): Method {\r\n    if (alternatives.elements.length === 1) {\r\n        return buildElement(ctx, alternatives.elements[0]);\r\n    } else {\r\n        const methods: PredicatedMethod[] = [];\r\n\r\n        for (const element of alternatives.elements) {\r\n            const predicatedMethod: PredicatedMethod = {\r\n                // Since we handle the guard condition in the alternative already\r\n                // We can ignore the group guard condition inside\r\n                ALT: buildElement(ctx, element, true)\r\n            };\r\n            const guard = getGuardCondition(element);\r\n            if (guard) {\r\n                predicatedMethod.GATE = buildPredicate(guard);\r\n            }\r\n            methods.push(predicatedMethod);\r\n        }\r\n\r\n        const idx = ctx.or++;\r\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\r\n            const alt: IOrAlt<unknown> = {\r\n                ALT: () => method.ALT(args)\r\n            };\r\n            const gate = method.GATE;\r\n            if (gate) {\r\n                alt.GATE = () => gate(args);\r\n            }\r\n            return alt;\r\n        }));\r\n    }\r\n}\r\n\r\nfunction buildUnorderedGroup(ctx: RuleContext, group: UnorderedGroup): Method {\r\n    if (group.elements.length === 1) {\r\n        return buildElement(ctx, group.elements[0]);\r\n    }\r\n    const methods: PredicatedMethod[] = [];\r\n\r\n    for (const element of group.elements) {\r\n        const predicatedMethod: PredicatedMethod = {\r\n            // Since we handle the guard condition in the alternative already\r\n            // We can ignore the group guard condition inside\r\n            ALT: buildElement(ctx, element, true)\r\n        };\r\n        const guard = getGuardCondition(element);\r\n        if (guard) {\r\n            predicatedMethod.GATE = buildPredicate(guard);\r\n        }\r\n        methods.push(predicatedMethod);\r\n    }\r\n\r\n    const orIdx = ctx.or++;\r\n\r\n    const idFunc = (groupIdx: number, lParser: BaseParser) => {\r\n        const stackId = lParser.getRuleStack().join('-');\r\n        return `uGroup_${groupIdx}_${stackId}`;\r\n    };\r\n    const alternatives: Method = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\r\n        const alt: IOrAlt<unknown> = { ALT: () => true };\r\n        const parser = ctx.parser;\r\n        alt.ALT = () => {\r\n            method.ALT(args);\r\n            if (!parser.isRecording()) {\r\n                const key = idFunc(orIdx, parser);\r\n                if (!parser.unorderedGroups.get(key)) {\r\n                    // init after clear state\r\n                    parser.unorderedGroups.set(key, []);\r\n                }\r\n                const groupState = parser.unorderedGroups.get(key)!;\r\n                if (typeof groupState?.[idx] === 'undefined') {\r\n                    // Not accessed yet\r\n                    groupState[idx] = true;\r\n                }\r\n            }\r\n        };\r\n        const gate = method.GATE;\r\n        if (gate) {\r\n            alt.GATE = () => gate(args);\r\n        } else {\r\n            alt.GATE = () => {\r\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\r\n                const allow = !trackedAlternatives?.[idx];\r\n                return allow;\r\n            };\r\n        }\r\n        return alt;\r\n    }));\r\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\r\n    return (args) => {\r\n        wrapped(args);\r\n        if (!ctx.parser.isRecording()) {\r\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\r\n        }\r\n    };\r\n}\r\n\r\nfunction buildGroup(ctx: RuleContext, group: Group): Method {\r\n    const methods = group.elements.map(e => buildElement(ctx, e));\r\n    return (args) => methods.forEach(method => method(args));\r\n}\r\n\r\nfunction getGuardCondition(element: AbstractElement): Condition | undefined {\r\n    if (isGroup(element)) {\r\n        return element.guardCondition;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction buildCrossReference(ctx: RuleContext, crossRef: CrossReference, terminal = crossRef.terminal): Method {\r\n    if (!terminal) {\r\n        if (!crossRef.type.ref) {\r\n            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\r\n        }\r\n        const assignment = findNameAssignment(crossRef.type.ref);\r\n        const assignTerminal = assignment?.terminal;\r\n        if (!assignTerminal) {\r\n            throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\r\n        }\r\n        return buildCrossReference(ctx, crossRef, assignTerminal);\r\n    } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\r\n        // The terminal is a data type rule here. Everything else will result in a validation error.\r\n        const rule = terminal.rule.ref;\r\n        const idx = ctx.subrule++;\r\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\r\n    } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\r\n        const idx = ctx.consume++;\r\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\r\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\r\n    } else if (isKeyword(terminal)) {\r\n        const idx = ctx.consume++;\r\n        const keyword = getToken(ctx, terminal.value);\r\n        return () => ctx.parser.consume(idx, keyword, crossRef);\r\n    }\r\n    else {\r\n        throw new Error('Could not build cross reference parser');\r\n    }\r\n}\r\n\r\nfunction buildKeyword(ctx: RuleContext, keyword: Keyword): Method {\r\n    const idx = ctx.consume++;\r\n    const token = ctx.tokens[keyword.value];\r\n    if (!token) {\r\n        throw new Error('Could not find token for keyword: ' + keyword.value);\r\n    }\r\n    return () => ctx.parser.consume(idx, token, keyword);\r\n}\r\n\r\nfunction wrap(ctx: RuleContext, guard: Condition | undefined, method: Method, cardinality: Cardinality): Method {\r\n    const gate = guard && buildPredicate(guard);\r\n\r\n    if (!cardinality) {\r\n        if (gate) {\r\n            const idx = ctx.or++;\r\n            return (args) => ctx.parser.alternatives(idx, [\r\n                {\r\n                    ALT: () => method(args),\r\n                    GATE: () => gate(args)\r\n                },\r\n                {\r\n                    ALT: EMPTY_ALT(),\r\n                    GATE: () => !gate(args)\r\n                }\r\n            ]);\r\n        } else {\r\n            return method;\r\n        }\r\n    }\r\n\r\n    if (cardinality === '*') {\r\n        const idx = ctx.many++;\r\n        return (args) => ctx.parser.many(idx, {\r\n            DEF: () => method(args),\r\n            GATE: gate ? () => gate(args) : undefined\r\n        });\r\n    } else if (cardinality === '+') {\r\n        const idx = ctx.many++;\r\n        if (gate) {\r\n            const orIdx = ctx.or++;\r\n            // In the case of a guard condition for the `+` group\r\n            // We combine it with an empty alternative\r\n            // If the condition returns true, it needs to parse at least a single iteration\r\n            // If its false, it is not allowed to parse anything\r\n            return (args) => ctx.parser.alternatives(orIdx, [\r\n                {\r\n                    ALT: () => ctx.parser.atLeastOne(idx, {\r\n                        DEF: () => method(args)\r\n                    }),\r\n                    GATE: () => gate(args)\r\n                },\r\n                {\r\n                    ALT: EMPTY_ALT(),\r\n                    GATE: () => !gate(args)\r\n                }\r\n            ]);\r\n        } else {\r\n            return (args) => ctx.parser.atLeastOne(idx, {\r\n                DEF: () => method(args),\r\n            });\r\n        }\r\n    } else if (cardinality === '?') {\r\n        const idx = ctx.optional++;\r\n        return (args) => ctx.parser.optional(idx, {\r\n            DEF: () => method(args),\r\n            GATE: gate ? () => gate(args) : undefined\r\n        });\r\n    } else {\r\n        assertUnreachable(cardinality);\r\n    }\r\n}\r\n\r\nfunction getRule(ctx: ParserContext, element: ParserRule | AbstractElement): Rule {\r\n    const name = getRuleName(ctx, element);\r\n    const rule = ctx.parser.getRule(name);\r\n    if (!rule) throw new Error(`Rule \"${name}\" not found.\"`);\r\n    return rule;\r\n}\r\n\r\nfunction getRuleName(ctx: ParserContext, element: ParserRule | AbstractElement): string {\r\n    if (isParserRule(element)) {\r\n        return element.name;\r\n    } else if (ctx.ruleNames.has(element)) {\r\n        return ctx.ruleNames.get(element)!;\r\n    } else {\r\n        let item: AstNode = element;\r\n        let parent: AstNode = item.$container!;\r\n        let ruleName: string = element.$type;\r\n        while (!isParserRule(parent)) {\r\n            if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\r\n                const index = parent.elements.indexOf(item as AbstractElement);\r\n                ruleName = index.toString() + ':' + ruleName;\r\n            }\r\n            item = parent;\r\n            parent = parent.$container!;\r\n        }\r\n        const rule = parent as ParserRule;\r\n        ruleName = rule.name + ':' + ruleName;\r\n        ctx.ruleNames.set(element, ruleName);\r\n        return ruleName;\r\n    }\r\n}\r\n\r\nfunction getToken(ctx: ParserContext, name: string): TokenType {\r\n    const token = ctx.tokens[name];\r\n    if (!token) throw new Error(`Token \"${name}\" not found.\"`);\r\n    return token;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4484, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/completion-parser-builder.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/completion-parser-builder.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport { LangiumCompletionParser } from './langium-parser.js';\r\nimport { createParser } from './parser-builder-base.js';\r\n\r\nexport function createCompletionParser(services: LangiumCoreServices): LangiumCompletionParser {\r\n    const grammar = services.Grammar;\r\n    const lexer = services.parser.Lexer;\r\n    const parser = new LangiumCompletionParser(services);\r\n    createParser(grammar, parser, lexer.definition);\r\n    parser.finalize();\r\n    return parser;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAGhF,OAAO,EAAE,uBAAuB,EAAE,MAAM,qBAAqB,CAAC;AAC9D,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;;;AAElD,SAAU,sBAAsB,CAAC,QAA6B;IAChE,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IACjC,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC;IACpC,MAAM,MAAM,GAAG,IAAI,4OAAuB,CAAC,QAAQ,CAAC,CAAC;QACrD,yOAAY,EAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;IAChD,MAAM,CAAC,QAAQ,EAAE,CAAC;IAClB,OAAO,MAAM,CAAC;AAClB,CAAC"}},
    {"offset": {"line": 4508, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/langium-parser-builder.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/langium-parser-builder.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport { LangiumParser } from './langium-parser.js';\r\nimport { createParser } from './parser-builder-base.js';\r\n\r\n/**\r\n * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is\r\n * available at `services.Grammar`.\r\n */\r\nexport function createLangiumParser(services: LangiumCoreServices): LangiumParser {\r\n    const parser = prepareLangiumParser(services);\r\n    parser.finalize();\r\n    return parser;\r\n}\r\n\r\n/**\r\n * Create a Langium parser without finalizing it. This is used to extract more detailed error\r\n * information when the parser is initially validated.\r\n */\r\nexport function prepareLangiumParser(services: LangiumCoreServices): LangiumParser {\r\n    const grammar = services.Grammar;\r\n    const lexer = services.parser.Lexer;\r\n    const parser = new LangiumParser(services);\r\n    return createParser(grammar, parser, lexer.definition);\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;AAGhF,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;;;AAMlD,SAAU,mBAAmB,CAAC,QAA6B;IAC7D,MAAM,MAAM,GAAG,oBAAoB,CAAC,QAAQ,CAAC,CAAC;IAC9C,MAAM,CAAC,QAAQ,EAAE,CAAC;IAClB,OAAO,MAAM,CAAC;AAClB,CAAC;AAMK,SAAU,oBAAoB,CAAC,QAA6B;IAC9D,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IACjC,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC;IACpC,MAAM,MAAM,GAAG,IAAI,kOAAa,CAAC,QAAQ,CAAC,CAAC;IAC3C,WAAO,yOAAY,EAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;AAC3D,CAAC"}},
    {"offset": {"line": 4537, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/token-builder.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/token-builder.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CustomPatternMatcherFunc, ILexingError, TokenPattern, TokenType, TokenVocabulary } from 'chevrotain';\r\nimport type { AbstractRule, Grammar, Keyword, TerminalRule } from '../languages/generated/ast.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { Lexer } from 'chevrotain';\r\nimport { isKeyword, isParserRule, isTerminalRule } from '../languages/generated/ast.js';\r\nimport { streamAllContents } from '../utils/ast-utils.js';\r\nimport { getAllReachableRules, terminalRegex } from '../utils/grammar-utils.js';\r\nimport { getCaseInsensitivePattern, isWhitespace, partialMatches } from '../utils/regexp-utils.js';\r\nimport { stream } from '../utils/stream.js';\r\n\r\nexport interface TokenBuilderOptions {\r\n    caseInsensitive?: boolean\r\n}\r\n\r\nexport interface TokenBuilder {\r\n    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary;\r\n    /**\r\n     * Produces a lexing report for the given text that was just tokenized using the tokens provided by this builder.\r\n     *\r\n     * @param text The text that was tokenized.\r\n     */\r\n    flushLexingReport?(text: string): LexingReport;\r\n}\r\n\r\n/**\r\n * A custom lexing report that can be produced by the token builder during the lexing process.\r\n * Adopters need to ensure that the any custom fields are serializable so they can be sent across worker threads.\r\n */\r\nexport interface LexingReport {\r\n    diagnostics: LexingDiagnostic[];\r\n}\r\n\r\nexport type LexingDiagnosticSeverity = 'error' | 'warning' | 'info' | 'hint';\r\n\r\nexport interface LexingDiagnostic extends ILexingError {\r\n    severity?: LexingDiagnosticSeverity;\r\n}\r\n\r\nexport class DefaultTokenBuilder implements TokenBuilder {\r\n    /**\r\n     * The list of diagnostics stored during the lexing process of a single text.\r\n     */\r\n    protected diagnostics: LexingDiagnostic[] = [];\r\n\r\n    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary {\r\n        const reachableRules = stream(getAllReachableRules(grammar, false));\r\n        const terminalTokens: TokenType[] = this.buildTerminalTokens(reachableRules);\r\n        const tokens: TokenType[] = this.buildKeywordTokens(reachableRules, terminalTokens, options);\r\n\r\n        terminalTokens.forEach(terminalToken => {\r\n            const pattern = terminalToken.PATTERN;\r\n            if (typeof pattern === 'object' && pattern && 'test' in pattern && isWhitespace(pattern)) {\r\n                tokens.unshift(terminalToken);\r\n            } else {\r\n                tokens.push(terminalToken);\r\n            }\r\n        });\r\n        // We don't need to add the EOF token explicitly.\r\n        // It is automatically available at the end of the token stream.\r\n        return tokens;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    flushLexingReport(text: string): LexingReport {\r\n        return { diagnostics: this.popDiagnostics() };\r\n    }\r\n\r\n    protected popDiagnostics(): LexingDiagnostic[] {\r\n        const diagnostics = [...this.diagnostics];\r\n        this.diagnostics = [];\r\n        return diagnostics;\r\n    }\r\n\r\n    protected buildTerminalTokens(rules: Stream<AbstractRule>): TokenType[] {\r\n        return rules.filter(isTerminalRule).filter(e => !e.fragment)\r\n            .map(terminal => this.buildTerminalToken(terminal)).toArray();\r\n    }\r\n\r\n    protected buildTerminalToken(terminal: TerminalRule): TokenType {\r\n        const regex = terminalRegex(terminal);\r\n        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\r\n        const tokenType: TokenType = {\r\n            name: terminal.name,\r\n            PATTERN: pattern,\r\n        };\r\n        if (typeof pattern === 'function') {\r\n            tokenType.LINE_BREAKS = true;\r\n        }\r\n        if (terminal.hidden) {\r\n            // Only skip tokens that are able to accept whitespace\r\n            tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : 'hidden';\r\n        }\r\n        return tokenType;\r\n    }\r\n\r\n    protected requiresCustomPattern(regex: RegExp): boolean {\r\n        if (regex.flags.includes('u') || regex.flags.includes('s')) {\r\n            // Unicode and dotall regexes are not supported by Chevrotain.\r\n            return true;\r\n        } else if (regex.source.includes('?<=') || regex.source.includes('?<!')) {\r\n            // Negative and positive lookbehind are not supported by Chevrotain yet.\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    protected regexPatternFunction(regex: RegExp): CustomPatternMatcherFunc {\r\n        const stickyRegex = new RegExp(regex, regex.flags + 'y');\r\n        return (text, offset) => {\r\n            stickyRegex.lastIndex = offset;\r\n            const execResult = stickyRegex.exec(text);\r\n            return execResult;\r\n        };\r\n    }\r\n\r\n    protected buildKeywordTokens(rules: Stream<AbstractRule>, terminalTokens: TokenType[], options?: TokenBuilderOptions): TokenType[] {\r\n        return rules\r\n            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens\r\n            .filter(isParserRule)\r\n            .flatMap(rule => streamAllContents(rule).filter(isKeyword))\r\n            .distinct(e => e.value).toArray()\r\n            // Sort keywords by descending length\r\n            .sort((a, b) => b.value.length - a.value.length)\r\n            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options?.caseInsensitive)));\r\n    }\r\n\r\n    protected buildKeywordToken(keyword: Keyword, terminalTokens: TokenType[], caseInsensitive: boolean): TokenType {\r\n        const keywordPattern = this.buildKeywordPattern(keyword, caseInsensitive);\r\n        const tokenType: TokenType = {\r\n            name: keyword.value,\r\n            PATTERN: keywordPattern,\r\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\r\n        };\r\n\r\n        if (typeof keywordPattern === 'function') {\r\n            tokenType.LINE_BREAKS = true;\r\n        }\r\n\r\n        return tokenType;\r\n    }\r\n\r\n    protected buildKeywordPattern(keyword: Keyword, caseInsensitive: boolean): TokenPattern {\r\n        return caseInsensitive ?\r\n            new RegExp(getCaseInsensitivePattern(keyword.value)) :\r\n            keyword.value;\r\n    }\r\n\r\n    protected findLongerAlt(keyword: Keyword, terminalTokens: TokenType[]): TokenType[] {\r\n        return terminalTokens.reduce((longerAlts: TokenType[], token) => {\r\n            const pattern = token?.PATTERN as RegExp;\r\n            if (pattern?.source && partialMatches('^' + pattern.source + '$', keyword.value)) {\r\n                longerAlts.push(token);\r\n            }\r\n            return longerAlts;\r\n        }, []);\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4665, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/value-converter.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/value-converter.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AbstractElement, AbstractRule } from '../languages/generated/ast.js';\r\nimport type { CstNode } from '../syntax-tree.js';\r\nimport { isCrossReference, isRuleCall } from '../languages/generated/ast.js';\r\nimport { getCrossReferenceTerminal, getRuleType } from '../utils/grammar-utils.js';\r\n\r\n/**\r\n * Language-specific service for converting string values from the source text format into a value to be held in the AST.\r\n */\r\nexport interface ValueConverter {\r\n    /**\r\n     * Converts a string value from the source text format into a value to be held in the AST.\r\n     */\r\n    convert(input: string, cstNode: CstNode): ValueType;\r\n}\r\n\r\nexport type ValueType = string | number | boolean | bigint | Date;\r\n\r\nexport class DefaultValueConverter implements ValueConverter {\r\n\r\n    convert(input: string, cstNode: CstNode): ValueType {\r\n        let feature: AbstractElement | undefined = cstNode.grammarSource;\r\n        if (isCrossReference(feature)) {\r\n            feature = getCrossReferenceTerminal(feature);\r\n        }\r\n        if (isRuleCall(feature)) {\r\n            const rule = feature.rule.ref;\r\n            if (!rule) {\r\n                throw new Error('This cst node was not parsed by a rule.');\r\n            }\r\n            return this.runConverter(rule, input, cstNode);\r\n        }\r\n        return input;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected runConverter(rule: AbstractRule, input: string, cstNode: CstNode): ValueType {\r\n        switch (rule.name.toUpperCase()) {\r\n            case 'INT': return ValueConverter.convertInt(input);\r\n            case 'STRING': return ValueConverter.convertString(input);\r\n            case 'ID': return ValueConverter.convertID(input);\r\n        }\r\n        switch (getRuleType(rule)?.toLowerCase()) {\r\n            case 'number': return ValueConverter.convertNumber(input);\r\n            case 'boolean': return ValueConverter.convertBoolean(input);\r\n            case 'bigint': return ValueConverter.convertBigint(input);\r\n            case 'date': return ValueConverter.convertDate(input);\r\n            default: return input;\r\n        }\r\n    }\r\n}\r\n\r\nexport namespace ValueConverter {\r\n\r\n    export function convertString(input: string): string {\r\n        let result = '';\r\n        for (let i = 1; i < input.length - 1; i++) {\r\n            const c = input.charAt(i);\r\n            if (c === '\\\\') {\r\n                const c1 = input.charAt(++i);\r\n                result += convertEscapeCharacter(c1);\r\n            } else {\r\n                result += c;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function convertEscapeCharacter(char: string): string {\r\n        switch (char) {\r\n            case 'b': return '\\b';\r\n            case 'f': return '\\f';\r\n            case 'n': return '\\n';\r\n            case 'r': return '\\r';\r\n            case 't': return '\\t';\r\n            case 'v': return '\\v';\r\n            case '0': return '\\0';\r\n            default: return char;\r\n        }\r\n    }\r\n\r\n    export function convertID(input: string): string {\r\n        if (input.charAt(0) === '^') {\r\n            return input.substring(1);\r\n        } else {\r\n            return input;\r\n        }\r\n    }\r\n\r\n    export function convertInt(input: string): number {\r\n        return parseInt(input);\r\n    }\r\n\r\n    export function convertBigint(input: string): bigint {\r\n        return BigInt(input);\r\n    }\r\n\r\n    export function convertDate(input: string): Date {\r\n        return new Date(input);\r\n    }\r\n\r\n    export function convertNumber(input: string): number {\r\n        return Number(input);\r\n    }\r\n\r\n    export function convertBoolean(input: string): boolean {\r\n        return input.toLowerCase() === 'true';\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4788, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/promise-utils.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/promise-utils.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { CancellationToken, CancellationTokenSource, type AbstractCancellationTokenSource } from '../utils/cancellation.js';\r\n\r\nexport type MaybePromise<T> = T | Promise<T>\r\n\r\n/**\r\n * Delays the execution of the current code to the next tick of the event loop.\r\n * Don't call this method directly in a tight loop to prevent too many promises from being created.\r\n */\r\nexport function delayNextTick(): Promise<void> {\r\n    return new Promise(resolve => {\r\n        // In case we are running in a non-node environment, `setImmediate` isn't available.\r\n        // Using `setTimeout` of the browser API accomplishes the same result.\r\n        if (typeof setImmediate === 'undefined') {\r\n            setTimeout(resolve, 0);\r\n        } else {\r\n            setImmediate(resolve);\r\n        }\r\n    });\r\n}\r\n\r\nlet lastTick = 0;\r\nlet globalInterruptionPeriod = 10;\r\n\r\n/**\r\n * Reset the global interruption period and create a cancellation token source.\r\n */\r\nexport function startCancelableOperation(): AbstractCancellationTokenSource {\r\n    lastTick = performance.now();\r\n    return new CancellationTokenSource();\r\n}\r\n\r\n/**\r\n * Change the period duration for `interruptAndCheck` to the given number of milliseconds.\r\n * The default value is 10ms.\r\n */\r\nexport function setInterruptionPeriod(period: number): void {\r\n    globalInterruptionPeriod = period;\r\n}\r\n\r\n/**\r\n * This symbol may be thrown in an asynchronous context by any Langium service that receives\r\n * a `CancellationToken`. This means that the promise returned by such a service is rejected with\r\n * this symbol as rejection reason.\r\n */\r\nexport const OperationCancelled = Symbol('OperationCancelled');\r\n\r\n/**\r\n * Use this in a `catch` block to check whether the thrown object indicates that the operation\r\n * has been cancelled.\r\n */\r\nexport function isOperationCancelled(err: unknown): err is typeof OperationCancelled {\r\n    return err === OperationCancelled;\r\n}\r\n\r\n/**\r\n * This function does two things:\r\n *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined\r\n *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.\r\n *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation\r\n *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.\r\n *\r\n * All services in Langium that receive a `CancellationToken` may potentially call this function, so the\r\n * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to\r\n * the promise) to avoid that event being exposed as an error.\r\n */\r\nexport async function interruptAndCheck(token: CancellationToken): Promise<void> {\r\n    if (token === CancellationToken.None) {\r\n        // Early exit in case cancellation was disabled by the caller\r\n        return;\r\n    }\r\n    const current = performance.now();\r\n    if (current - lastTick >= globalInterruptionPeriod) {\r\n        lastTick = current;\r\n        await delayNextTick();\r\n        // prevent calling delayNextTick every iteration of loop\r\n        // where delayNextTick takes up the majority or all of the\r\n        // globalInterruptionPeriod itself\r\n        lastTick = performance.now();\r\n    }\r\n    if (token.isCancellationRequested) {\r\n        throw OperationCancelled;\r\n    }\r\n}\r\n\r\n/**\r\n * Simple implementation of the deferred pattern.\r\n * An object that exposes a promise and functions to resolve and reject it.\r\n */\r\nexport class Deferred<T = void> {\r\n    resolve: (value: T) => this;\r\n    reject: (err?: unknown) => this;\r\n\r\n    promise = new Promise<T>((resolve, reject) => {\r\n        this.resolve = (arg) => {\r\n            resolve(arg);\r\n            return this;\r\n        };\r\n        this.reject = (err) => {\r\n            reject(err);\r\n            return this;\r\n        };\r\n    });\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;;;;;;;;;;;AAEhF,OAAO,EAAE,iBAAiB,EAAE,uBAAuB,EAAwC,MAAM,0BAA0B,CAAC;;AAQtH,SAAU,aAAa;IACzB,OAAO,IAAI,OAAO,EAAC,OAAO,CAAC,EAAE;QACzB,oFAAoF;QACpF,sEAAsE;QACtE,IAAI,OAAO,YAAY,KAAK,WAAW,EAAE,CAAC;YACtC,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAC3B,CAAC,MAAM,CAAC;YACJ,YAAY,CAAC,OAAO,CAAC,CAAC;QAC1B,CAAC;IACL,CAAC,CAAC,CAAC;AACP,CAAC;AAED,IAAI,QAAQ,GAAG,CAAC,CAAC;AACjB,IAAI,wBAAwB,GAAG,EAAE,CAAC;AAK5B,SAAU,wBAAwB;IACpC,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IAC7B,OAAO,IAAI,2PAAuB,EAAE,CAAC;AACzC,CAAC;AAMK,SAAU,qBAAqB,CAAC,MAAc;IAChD,wBAAwB,GAAG,MAAM,CAAC;AACtC,CAAC;AAOM,MAAM,kBAAkB,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC;AAMzD,SAAU,oBAAoB,CAAC,GAAY;IAC7C,OAAO,GAAG,KAAK,kBAAkB,CAAC;AACtC,CAAC;AAaM,KAAK,UAAU,iBAAiB,CAAC,KAAwB;IAC5D,IAAI,KAAK,KAAK,qPAAiB,CAAC,IAAI,EAAE,CAAC;QACnC,6DAA6D;QAC7D,OAAO;IACX,CAAC;IACD,MAAM,OAAO,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IAClC,IAAI,OAAO,GAAG,QAAQ,IAAI,wBAAwB,EAAE,CAAC;QACjD,QAAQ,GAAG,OAAO,CAAC;QACnB,MAAM,aAAa,EAAE,CAAC;QACtB,wDAAwD;QACxD,0DAA0D;QAC1D,kCAAkC;QAClC,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IACjC,CAAC;IACD,IAAI,KAAK,CAAC,uBAAuB,EAAE,CAAC;QAChC,MAAM,kBAAkB,CAAC;IAC7B,CAAC;AACL,CAAC;AAMK,MAAO,QAAQ;IAArB,aAAA;QAII,IAAA,CAAA,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACzC,IAAI,CAAC,OAAO,GAAG,CAAC,GAAG,EAAE,EAAE;gBACnB,OAAO,CAAC,GAAG,CAAC,CAAC;gBACb,OAAO,IAAI,CAAC;YAChB,CAAC,CAAC;YACF,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE,EAAE;gBAClB,MAAM,CAAC,GAAG,CAAC,CAAC;gBACZ,OAAO,IAAI,CAAC;YAChB,CAAC,CAAC;QACN,CAAC,CAAC,CAAC;IACP,CAAC;CAAA"}},
    {"offset": {"line": 4870, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/documents.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/documents.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/**\r\n * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,\r\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\r\n *  the overhead is very small, just a few kilobytes.\r\n * Everything else of that package (at the time contributing) is also defined\r\n *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.\r\n */\r\nexport { TextDocument } from 'vscode-languageserver-textdocument';\r\n\r\nimport type { Diagnostic, Range } from 'vscode-languageserver-types';\r\nimport type { FileSystemProvider } from './file-system-provider.js';\r\nimport type { ParseResult, ParserOptions } from '../parser/langium-parser.js';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, Mutable, Reference } from '../syntax-tree.js';\r\nimport type { MultiMap } from '../utils/collections.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { TextDocument } from './documents.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { URI } from '../utils/uri-utils.js';\r\n\r\n/**\r\n * A Langium document holds the parse result (AST and CST) and any additional state that is derived\r\n * from the AST, e.g. the result of scope precomputation.\r\n */\r\nexport interface LangiumDocument<T extends AstNode = AstNode> {\r\n    /** The Uniform Resource Identifier (URI) of the document */\r\n    readonly uri: URI;\r\n    /** The text document used to convert between offsets and positions */\r\n    readonly textDocument: TextDocument;\r\n    /** The current state of the document */\r\n    state: DocumentState;\r\n    /** The parse result holds the Abstract Syntax Tree (AST) and potentially also parser / lexer errors */\r\n    parseResult: ParseResult<T>;\r\n    /** Result of the scope precomputation phase */\r\n    precomputedScopes?: PrecomputedScopes;\r\n    /** An array of all cross-references found in the AST while linking */\r\n    references: Reference[];\r\n    /** Result of the validation phase */\r\n    diagnostics?: Diagnostic[]\r\n}\r\n\r\n/**\r\n * A document is subject to several phases that are run in predefined order. Any state value implies that\r\n * smaller state values are finished as well.\r\n */\r\nexport enum DocumentState {\r\n    /**\r\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\r\n     * document instance is no longer valid.\r\n     */\r\n    Changed = 0,\r\n    /**\r\n     * An AST has been created from the text content. The document structure can be traversed,\r\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\r\n     * at this stage as a preprocessing step.\r\n     */\r\n    Parsed = 1,\r\n    /**\r\n     * The `IndexManager` service has processed AST nodes of this document. This means the\r\n     * exported symbols are available in the global scope and can be resolved from other documents.\r\n     */\r\n    IndexedContent = 2,\r\n    /**\r\n     * The `ScopeComputation` service has processed this document. This means the local symbols\r\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\r\n     * Once a document has reached this state, you may follow every reference - it will lazily\r\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\r\n     * the target is not in scope.\r\n     */\r\n    ComputedScopes = 3,\r\n    /**\r\n     * The `Linker` service has processed this document. All outgoing references have been\r\n     * resolved or marked as erroneous.\r\n     */\r\n    Linked = 4,\r\n    /**\r\n     * The `IndexManager` service has processed AST node references of this document. This is\r\n     * necessary to determine which documents are affected by a change in one of the workspace\r\n     * documents.\r\n     */\r\n    IndexedReferences = 5,\r\n    /**\r\n     * The `DocumentValidator` service has processed this document. The language server listens\r\n     * to the results of this phase and sends diagnostics to the client.\r\n     */\r\n    Validated = 6\r\n}\r\n\r\n/**\r\n * Result of the scope precomputation phase (`ScopeComputation` service).\r\n * It maps every AST node to the set of symbols that are visible in the subtree of that node.\r\n */\r\nexport type PrecomputedScopes = MultiMap<AstNode, AstNodeDescription>\r\n\r\nexport interface DocumentSegment {\r\n    readonly range: Range\r\n    readonly offset: number\r\n    readonly length: number\r\n    readonly end: number\r\n}\r\n\r\n/**\r\n * Surrogate definition of the `TextDocuments` interface from the `vscode-languageserver` package.\r\n * No implementation object is expected to be offered by `LangiumCoreServices`, but only by `LangiumLSPServices`.\r\n */\r\nexport type TextDocumentProvider = {\r\n    get(uri: string | URI): TextDocument | undefined\r\n}\r\n\r\n/**\r\n * Shared service for creating `LangiumDocument` instances.\r\n *\r\n * Register a custom implementation if special (additional) behavior is required for your language(s).\r\n * Note: If you specialize {@link fromString} or {@link fromTextDocument} you probably might want to\r\n * specialize {@link update}, too!\r\n */\r\nexport interface LangiumDocumentFactory {\r\n    /**\r\n     * Create a Langium document from a `TextDocument` (usually associated with a file).\r\n     */\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, options?: ParserOptions): LangiumDocument<T>;\r\n    /**\r\n     * Create a Langium document from a `TextDocument` asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.\r\n     */\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI | undefined, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\r\n\r\n    /**\r\n     * Create an Langium document from an in-memory string.\r\n     */\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, options?: ParserOptions): LangiumDocument<T>;\r\n    /**\r\n     * Create a Langium document from an in-memory string asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.\r\n     */\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\r\n\r\n    /**\r\n     * Create an Langium document from a model that has been constructed in memory.\r\n     */\r\n    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T>;\r\n\r\n    /**\r\n     * Create an Langium document from a specified `URI`. The factory will use the `FileSystemAccess` service to read the file.\r\n     */\r\n    fromUri<T extends AstNode = AstNode>(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument<T>>;\r\n\r\n    /**\r\n     * Update the given document after changes in the corresponding textual representation.\r\n     * Method is called by the document builder after it has been requested to build an existing\r\n     * document and the document's state is {@link DocumentState.Changed}.\r\n     * The text parsing is expected to be done the same way as in {@link fromTextDocument}\r\n     * and {@link fromString}.\r\n     */\r\n    update<T extends AstNode = AstNode>(document: LangiumDocument<T>, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>\r\n}\r\n\r\nexport class DefaultLangiumDocumentFactory implements LangiumDocumentFactory {\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly textDocuments?: TextDocumentProvider;\r\n    protected readonly fileSystemProvider: FileSystemProvider;\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.textDocuments = services.workspace.TextDocuments;\r\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\r\n    }\r\n\r\n    async fromUri<T extends AstNode = AstNode>(uri: URI, cancellationToken = CancellationToken.None): Promise<LangiumDocument<T>> {\r\n        const content = await this.fileSystemProvider.readFile(uri);\r\n        return this.createAsync<T>(uri, content, cancellationToken);\r\n    }\r\n\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, options?: ParserOptions): LangiumDocument<T>;\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI | undefined, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, token?: CancellationToken | ParserOptions): LangiumDocument<T> | Promise<LangiumDocument<T>> {\r\n        uri = uri ?? URI.parse(textDocument.uri);\r\n        if (CancellationToken.is(token)) {\r\n            return this.createAsync<T>(uri, textDocument, token);\r\n        } else {\r\n            return this.create<T>(uri, textDocument, token);\r\n        }\r\n    }\r\n\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, options?: ParserOptions): LangiumDocument<T>;\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, token?: CancellationToken | ParserOptions): LangiumDocument<T> | Promise<LangiumDocument<T>> {\r\n        if (CancellationToken.is(token)) {\r\n            return this.createAsync<T>(uri, text, token);\r\n        } else {\r\n            return this.create<T>(uri, text, token);\r\n        }\r\n    }\r\n\r\n    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T> {\r\n        return this.create<T>(uri, { $model: model });\r\n    }\r\n\r\n    protected create<T extends AstNode = AstNode>(uri: URI, content: string | TextDocument | { $model: T }, options?: ParserOptions): LangiumDocument<T> {\r\n        if (typeof content === 'string') {\r\n            const parseResult = this.parse<T>(uri, content, options);\r\n            return this.createLangiumDocument<T>(parseResult, uri, undefined, content);\r\n\r\n        } else if ('$model' in content) {\r\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\r\n            return this.createLangiumDocument<T>(parseResult, uri);\r\n\r\n        } else {\r\n            const parseResult = this.parse<T>(uri, content.getText(), options);\r\n            return this.createLangiumDocument(parseResult, uri, content);\r\n        }\r\n    }\r\n\r\n    protected async createAsync<T extends AstNode = AstNode>(uri: URI, content: string | TextDocument, cancelToken: CancellationToken): Promise<LangiumDocument<T>> {\r\n        if (typeof content === 'string') {\r\n            const parseResult = await this.parseAsync<T>(uri, content, cancelToken);\r\n            return this.createLangiumDocument<T>(parseResult, uri, undefined, content);\r\n        } else {\r\n            const parseResult = await this.parseAsync<T>(uri, content.getText(), cancelToken);\r\n            return this.createLangiumDocument(parseResult, uri, content);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a LangiumDocument from a given parse result.\r\n     *\r\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\r\n     * should not be necessary because the main purpose of the TextDocument is to convert between\r\n     * text ranges and offsets, which is done solely in LSP request handling.\r\n     *\r\n     * With the introduction of {@link update} below this method is supposed to be mainly called\r\n     * during workspace initialization and on addition/recognition of new files, while changes in\r\n     * existing documents are processed via {@link update}.\r\n     */\r\n    protected createLangiumDocument<T extends AstNode = AstNode>(parseResult: ParseResult<T>, uri: URI, textDocument?: TextDocument, text?: string): LangiumDocument<T> {\r\n        let document: LangiumDocument<T>;\r\n        if (textDocument) {\r\n            document = {\r\n                parseResult,\r\n                uri,\r\n                state: DocumentState.Parsed,\r\n                references: [],\r\n                textDocument\r\n            };\r\n        } else {\r\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\r\n            document = {\r\n                parseResult,\r\n                uri,\r\n                state: DocumentState.Parsed,\r\n                references: [],\r\n                get textDocument() {\r\n                    return textDocumentGetter();\r\n                }\r\n            };\r\n        }\r\n        (parseResult.value as Mutable<AstNode>).$document = document;\r\n        return document;\r\n    }\r\n\r\n    async update<T extends AstNode = AstNode>(document: Mutable<LangiumDocument<T>>, cancellationToken: CancellationToken): Promise<LangiumDocument<T>> {\r\n        // The CST full text property contains the original text that was used to create the AST.\r\n        const oldText = document.parseResult.value.$cstNode?.root.fullText;\r\n        const textDocument = this.textDocuments?.get(document.uri.toString());\r\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\r\n\r\n        if (textDocument) {\r\n            Object.defineProperty(\r\n                document,\r\n                'textDocument',\r\n                {\r\n                    value: textDocument\r\n                }\r\n            );\r\n        } else {\r\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\r\n            Object.defineProperty(\r\n                document,\r\n                'textDocument',\r\n                {\r\n                    get: textDocumentGetter\r\n                }\r\n            );\r\n        }\r\n\r\n        // Some of these documents can be pretty large, so parsing them again can be quite expensive.\r\n        // Therefore, we only parse if the text has actually changed.\r\n        if (oldText !== text) {\r\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\r\n            (document.parseResult.value as Mutable<AstNode>).$document = document;\r\n        }\r\n        document.state = DocumentState.Parsed;\r\n        return document;\r\n    }\r\n\r\n    protected parse<T extends AstNode>(uri: URI, text: string, options?: ParserOptions): ParseResult<T> {\r\n        const services = this.serviceRegistry.getServices(uri);\r\n        return services.parser.LangiumParser.parse<T>(text, options);\r\n    }\r\n\r\n    protected parseAsync<T extends AstNode>(uri: URI, text: string, cancellationToken: CancellationToken): Promise<ParseResult<T>> {\r\n        const services = this.serviceRegistry.getServices(uri);\r\n        return services.parser.AsyncParser.parse<T>(text, cancellationToken);\r\n    }\r\n\r\n    protected createTextDocumentGetter(uri: URI, text?: string): () => TextDocument {\r\n        const serviceRegistry = this.serviceRegistry;\r\n        let textDoc: TextDocument | undefined = undefined;\r\n        return () => {\r\n            return textDoc ??= TextDocument.create(\r\n                uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text ?? ''\r\n            );\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Shared service for managing Langium documents.\r\n */\r\nexport interface LangiumDocuments {\r\n\r\n    /**\r\n     * A stream of all documents managed under this service.\r\n     */\r\n    readonly all: Stream<LangiumDocument>\r\n\r\n    /**\r\n     * Manage a new document under this service.\r\n     * @throws an error if a document with the same URI is already present.\r\n     */\r\n    addDocument(document: LangiumDocument): void;\r\n\r\n    /**\r\n     * Retrieve the document with the given URI, if present. Otherwise returns `undefined`.\r\n     */\r\n    getDocument(uri: URI): LangiumDocument | undefined;\r\n\r\n    /**\r\n     * Retrieve the document with the given URI. If not present, a new one will be created using the file system access.\r\n     * The new document will be added to the list of documents managed under this service.\r\n     */\r\n    getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument>;\r\n\r\n    /**\r\n     * Creates a new document with the given URI and text content.\r\n     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.\r\n     *\r\n     * @throws an error if a document with the same URI is already present.\r\n     */\r\n    createDocument(uri: URI, text: string): LangiumDocument;\r\n\r\n    /**\r\n     * Creates a new document with the given URI and text content asynchronously.\r\n     * The process can be interrupted with a cancellation token.\r\n     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.\r\n     *\r\n     * @throws an error if a document with the same URI is already present.\r\n     */\r\n    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;\r\n\r\n    /**\r\n     * Returns `true` if a document with the given URI is managed under this service.\r\n     */\r\n    hasDocument(uri: URI): boolean;\r\n\r\n    /**\r\n     * Flag the document with the given URI as `Changed`, if present, meaning that its content\r\n     * is no longer valid. The content (parseResult) stays untouched, while internal data may\r\n     * be dropped to reduce memory footprint.\r\n     *\r\n     * @returns the affected {@link LangiumDocument} if existing for convenience\r\n     */\r\n    invalidateDocument(uri: URI): LangiumDocument | undefined;\r\n\r\n    /**\r\n     * Remove the document with the given URI, if present, and mark it as `Changed`, meaning\r\n     * that its content is no longer valid. The next call to `getOrCreateDocument` with the same\r\n     * URI will create a new document instance.\r\n     *\r\n     * @returns the affected {@link LangiumDocument} if existing for convenience\r\n     */\r\n    deleteDocument(uri: URI): LangiumDocument | undefined;\r\n}\r\n\r\nexport class DefaultLangiumDocuments implements LangiumDocuments {\r\n\r\n    protected readonly langiumDocumentFactory: LangiumDocumentFactory;\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n\r\n    protected readonly documentMap: Map<string, LangiumDocument> = new Map();\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n    }\r\n\r\n    get all(): Stream<LangiumDocument> {\r\n        return stream(this.documentMap.values());\r\n    }\r\n\r\n    addDocument(document: LangiumDocument): void {\r\n        const uriString = document.uri.toString();\r\n        if (this.documentMap.has(uriString)) {\r\n            throw new Error(`A document with the URI '${uriString}' is already present.`);\r\n        }\r\n        this.documentMap.set(uriString, document);\r\n    }\r\n\r\n    getDocument(uri: URI): LangiumDocument | undefined {\r\n        const uriString = uri.toString();\r\n        return this.documentMap.get(uriString);\r\n    }\r\n\r\n    async getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument> {\r\n        let document = this.getDocument(uri);\r\n        if (document) {\r\n            return document;\r\n        }\r\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\r\n        this.addDocument(document);\r\n        return document;\r\n    }\r\n\r\n    createDocument(uri: URI, text: string): LangiumDocument;\r\n    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;\r\n    createDocument(uri: URI, text: string, cancellationToken?: CancellationToken): LangiumDocument | Promise<LangiumDocument> {\r\n        if (cancellationToken) {\r\n            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\r\n                this.addDocument(document);\r\n                return document;\r\n            });\r\n        } else {\r\n            const document = this.langiumDocumentFactory.fromString(text, uri);\r\n            this.addDocument(document);\r\n            return document;\r\n        }\r\n    }\r\n\r\n    hasDocument(uri: URI): boolean {\r\n        return this.documentMap.has(uri.toString());\r\n    }\r\n\r\n    invalidateDocument(uri: URI): LangiumDocument | undefined {\r\n        const uriString = uri.toString();\r\n        const langiumDoc = this.documentMap.get(uriString);\r\n        if (langiumDoc) {\r\n            const linker = this.serviceRegistry.getServices(uri).references.Linker;\r\n            linker.unlink(langiumDoc);\r\n            langiumDoc.state = DocumentState.Changed;\r\n            langiumDoc.precomputedScopes = undefined;\r\n            langiumDoc.diagnostics = undefined;\r\n        }\r\n        return langiumDoc;\r\n    }\r\n\r\n    deleteDocument(uri: URI): LangiumDocument | undefined {\r\n        const uriString = uri.toString();\r\n        const langiumDoc = this.documentMap.get(uriString);\r\n        if (langiumDoc) {\r\n            langiumDoc.state = DocumentState.Changed;\r\n            this.documentMap.delete(uriString);\r\n        }\r\n        return langiumDoc;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5134, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/references/linker.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/references/linker.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection, CstNode, LinkingError, Reference, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\r\nimport type { LangiumDocument, LangiumDocuments } from '../workspace/documents.js';\r\nimport type { ScopeProvider } from './scope-provider.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';\r\nimport { findRootNode, streamAst, streamReferences } from '../utils/ast-utils.js';\r\nimport { interruptAndCheck } from '../utils/promise-utils.js';\r\nimport { DocumentState } from '../workspace/documents.js';\r\n\r\n/**\r\n * Language-specific service for resolving cross-references in the AST.\r\n */\r\nexport interface Linker {\r\n\r\n    /**\r\n     * Links all cross-references within the specified document. The default implementation loads only target\r\n     * elements from documents that are present in the `LangiumDocuments` service. The linked references are\r\n     * stored in the document's `references` property.\r\n     *\r\n     * @param document A LangiumDocument that shall be linked.\r\n     * @param cancelToken A token for cancelling the operation.\r\n     *\r\n     * @throws `OperationCancelled` if a cancellation event is detected\r\n     */\r\n    link(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Unlinks all references within the specified document and removes them from the list of `references`.\r\n     *\r\n     * @param document A LangiumDocument that shall be unlinked.\r\n     */\r\n    unlink(document: LangiumDocument): void;\r\n\r\n    /**\r\n     * Determines a candidate AST node description for linking the given reference.\r\n     *\r\n     * @param refInfo Information about the reference.\r\n     */\r\n    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError;\r\n\r\n    /**\r\n     * Creates a cross reference node being aware of its containing AstNode, the corresponding CstNode,\r\n     * the cross reference text denoting the target AstNode being already extracted of the document text,\r\n     * as well as the unique cross reference identifier.\r\n     *\r\n     * Default behavior:\r\n     *  - The returned Reference's 'ref' property pointing to the target AstNode is populated lazily on its\r\n     *    first visit.\r\n     *  - If the target AstNode cannot be resolved on the first visit, an error indicator will be installed\r\n     *    and further resolution attempts will *not* be performed.\r\n     *\r\n     * @param node The containing AST node\r\n     * @param property The AST node property being referenced\r\n     * @param refNode The corresponding CST node\r\n     * @param refText The cross reference text denoting the target AstNode\r\n     * @returns the desired Reference node, whose behavior wrt. resolving the cross reference is implementation specific.\r\n     */\r\n    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference;\r\n\r\n}\r\n\r\nconst ref_resolving = Symbol('ref_resolving');\r\n\r\ninterface DefaultReference extends Reference {\r\n    _ref?: AstNode | LinkingError | typeof ref_resolving;\r\n    _nodeDescription?: AstNodeDescription;\r\n}\r\n\r\nexport class DefaultLinker implements Linker {\r\n    protected readonly reflection: AstReflection;\r\n    protected readonly scopeProvider: ScopeProvider;\r\n    protected readonly astNodeLocator: AstNodeLocator;\r\n    protected readonly langiumDocuments: () => LangiumDocuments;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\r\n        this.scopeProvider = services.references.ScopeProvider;\r\n        this.astNodeLocator = services.workspace.AstNodeLocator;\r\n    }\r\n\r\n    async link(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        for (const node of streamAst(document.parseResult.value)) {\r\n            await interruptAndCheck(cancelToken);\r\n            streamReferences(node).forEach(ref => this.doLink(ref, document));\r\n        }\r\n    }\r\n\r\n    protected doLink(refInfo: ReferenceInfo, document: LangiumDocument): void {\r\n        const ref = refInfo.reference as DefaultReference;\r\n        // The reference may already have been resolved lazily by accessing its `ref` property.\r\n        if (ref._ref === undefined) {\r\n            ref._ref = ref_resolving;\r\n            try {\r\n                const description = this.getCandidate(refInfo);\r\n                if (isLinkingError(description)) {\r\n                    ref._ref = description;\r\n                } else {\r\n                    ref._nodeDescription = description;\r\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\r\n                        // The target document is already loaded\r\n                        const linkedNode = this.loadAstNode(description);\r\n                        ref._ref = linkedNode ?? this.createLinkingError(refInfo, description);\r\n                    } else {\r\n                        // Try to load the target AST node later using the already provided description\r\n                        ref._ref = undefined;\r\n                    }\r\n                }\r\n            } catch (err) {\r\n                console.error(`An error occurred while resolving reference to '${ref.$refText}':`, err);\r\n                const errorMessage = (err as Error).message ?? String(err);\r\n                ref._ref = {\r\n                    ...refInfo,\r\n                    message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}`\r\n                };\r\n            }\r\n            // Add the reference to the document's array of references\r\n            // Only add if the reference has been not been resolved earlier\r\n            // Otherwise we end up with duplicates\r\n            // See also implementation of `buildReference`\r\n            document.references.push(ref);\r\n        }\r\n    }\r\n\r\n    unlink(document: LangiumDocument): void {\r\n        for (const ref of document.references) {\r\n            delete (ref as DefaultReference)._ref;\r\n            delete (ref as DefaultReference)._nodeDescription;\r\n        }\r\n        document.references = [];\r\n    }\r\n\r\n    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError {\r\n        const scope = this.scopeProvider.getScope(refInfo);\r\n        const description = scope.getElement(refInfo.reference.$refText);\r\n        return description ?? this.createLinkingError(refInfo);\r\n    }\r\n\r\n    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference {\r\n        // See behavior description in doc of Linker, update that on changes in here.\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const linker = this;\r\n        const reference: DefaultReference = {\r\n            $refNode: refNode,\r\n            $refText: refText,\r\n\r\n            get ref() {\r\n                if (isAstNode(this._ref)) {\r\n                    // Most frequent case: the target is already resolved.\r\n                    return this._ref;\r\n                } else if (isAstNodeDescription(this._nodeDescription)) {\r\n                    // A candidate has been found before, but it is not loaded yet.\r\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\r\n                    this._ref = linkedNode ??\r\n                        linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\r\n                } else if (this._ref === undefined) {\r\n                    // The reference has not been linked yet, so do that now.\r\n                    this._ref = ref_resolving;\r\n                    const document = findRootNode(node).$document;\r\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\r\n                    if (refData.error && document && document.state < DocumentState.ComputedScopes) {\r\n                        // Document scope is not ready, don't set `this._ref` so linker can retry later.\r\n                        return this._ref = undefined;\r\n                    }\r\n                    this._ref = refData.node ?? refData.error;\r\n                    this._nodeDescription = refData.descr;\r\n                    document?.references.push(this);\r\n                } else if (this._ref === ref_resolving) {\r\n                    throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);\r\n                }\r\n                return isAstNode(this._ref) ? this._ref : undefined;\r\n            },\r\n            get $nodeDescription() {\r\n                return this._nodeDescription;\r\n            },\r\n            get error() {\r\n                return isLinkingError(this._ref) ? this._ref : undefined;\r\n            }\r\n        };\r\n        return reference;\r\n    }\r\n\r\n    protected getLinkedNode(refInfo: ReferenceInfo): { node?: AstNode, descr?: AstNodeDescription, error?: LinkingError } {\r\n        try {\r\n            const description = this.getCandidate(refInfo);\r\n            if (isLinkingError(description)) {\r\n                return { error: description };\r\n            }\r\n            const linkedNode = this.loadAstNode(description);\r\n            if (linkedNode) {\r\n                return { node: linkedNode, descr: description };\r\n            }\r\n            else {\r\n                return {\r\n                    descr: description,\r\n                    error:\r\n                        this.createLinkingError(refInfo, description)\r\n                };\r\n            }\r\n        } catch (err) {\r\n            console.error(`An error occurred while resolving reference to '${refInfo.reference.$refText}':`, err);\r\n            const errorMessage = (err as Error).message ?? String(err);\r\n            return {\r\n                error: {\r\n                    ...refInfo,\r\n                    message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}`\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    protected loadAstNode(nodeDescription: AstNodeDescription): AstNode | undefined {\r\n        if (nodeDescription.node) {\r\n            return nodeDescription.node;\r\n        }\r\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\r\n        if (!doc) {\r\n            return undefined;\r\n        }\r\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\r\n    }\r\n\r\n    protected createLinkingError(refInfo: ReferenceInfo, targetDescription?: AstNodeDescription): LinkingError {\r\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\r\n        // in the language implementation.\r\n        const document = findRootNode(refInfo.container).$document;\r\n        if (document && document.state < DocumentState.ComputedScopes) {\r\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\r\n        }\r\n        const referenceType = this.reflection.getReferenceType(refInfo);\r\n        return {\r\n            ...refInfo,\r\n            message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`,\r\n            targetDescription\r\n        };\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5322, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/references/name-provider.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/references/name-provider.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode, CstNode } from '../syntax-tree.js';\r\nimport { findNodeForProperty } from '../utils/grammar-utils.js';\r\n\r\nexport interface NamedAstNode extends AstNode {\r\n    name: string;\r\n}\r\n\r\nexport function isNamed(node: AstNode): node is NamedAstNode {\r\n    return typeof (node as NamedAstNode).name === 'string';\r\n}\r\n\r\n/**\r\n * Utility service for retrieving the `name` of an `AstNode` or the `CstNode` containing a `name`.\r\n */\r\nexport interface NameProvider {\r\n    /**\r\n     * Returns the `name` of a given AstNode.\r\n     * @param node Specified `AstNode` whose name node shall be retrieved.\r\n     */\r\n    getName(node: AstNode): string | undefined;\r\n    /**\r\n     * Returns the `CstNode` which contains the parsed value of the `name` assignment.\r\n     * @param node Specified `AstNode` whose name node shall be retrieved.\r\n     */\r\n    getNameNode(node: AstNode): CstNode | undefined;\r\n}\r\n\r\nexport class DefaultNameProvider implements NameProvider {\r\n    getName(node: AstNode): string | undefined {\r\n        if (isNamed(node)) {\r\n            return node.name;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    getNameNode(node: AstNode): CstNode | undefined {\r\n        return findNodeForProperty(node.$cstNode, 'name');\r\n    }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;AAGhF,OAAO,EAAE,mBAAmB,EAAE,MAAM,2BAA2B,CAAC;;AAM1D,SAAU,OAAO,CAAC,IAAa;IACjC,OAAO,OAAQ,IAAqB,CAAC,IAAI,KAAK,QAAQ,CAAC;AAC3D,CAAC;AAkBK,MAAO,mBAAmB;IAC5B,OAAO,CAAC,IAAa,EAAA;QACjB,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;YAChB,OAAO,IAAI,CAAC,IAAI,CAAC;QACrB,CAAC;QACD,OAAO,SAAS,CAAC;IACrB,CAAC;IAED,WAAW,CAAC,IAAa,EAAA;QACrB,WAAO,sOAAmB,EAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACtD,CAAC;CACJ"}},
    {"offset": {"line": 5352, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/uri-utils.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/uri-utils.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { URI, Utils } from 'vscode-uri';\r\n\r\nexport { URI };\r\n\r\nexport namespace UriUtils {\r\n\r\n    export const basename = Utils.basename;\r\n    export const dirname = Utils.dirname;\r\n    export const extname = Utils.extname;\r\n    export const joinPath = Utils.joinPath;\r\n    export const resolvePath = Utils.resolvePath;\r\n\r\n    export function equals(a?: URI | string, b?: URI | string): boolean {\r\n        return a?.toString() === b?.toString();\r\n    }\r\n\r\n    export function relative(from: URI | string, to: URI | string): string {\r\n        const fromPath = typeof from === 'string' ? from : from.path;\r\n        const toPath = typeof to === 'string' ? to : to.path;\r\n        const fromParts = fromPath.split('/').filter(e => e.length > 0);\r\n        const toParts = toPath.split('/').filter(e => e.length > 0);\r\n        let i = 0;\r\n        for (; i < fromParts.length; i++) {\r\n            if (fromParts[i] !== toParts[i]) {\r\n                break;\r\n            }\r\n        }\r\n        const backPart = '../'.repeat(fromParts.length - i);\r\n        const toPart = toParts.slice(i).join('/');\r\n        return backPart + toPart;\r\n    }\r\n\r\n    export function normalize(uri: URI | string): string {\r\n        return URI.parse(uri.toString()).toString();\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAEhF,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;;;AAIlC,IAAW,QAAQ,CAgCxB;AAhCD,CAAA,SAAiB,QAAQ;IAER,SAAA,QAAQ,GAAG,wNAAK,CAAC,QAAQ,CAAC;IAC1B,SAAA,OAAO,GAAG,wNAAK,CAAC,OAAO,CAAC;IACxB,SAAA,OAAO,GAAG,wNAAK,CAAC,OAAO,CAAC;IACxB,SAAA,QAAQ,GAAG,wNAAK,CAAC,QAAQ,CAAC;IAC1B,SAAA,WAAW,GAAG,wNAAK,CAAC,WAAW,CAAC;IAE7C,SAAgB,MAAM,CAAC,CAAgB,EAAE,CAAgB;QACrD,OAAO,CAAA,CAAC,KAAA,QAAD,CAAC,KAAA,KAAA,IAAA,KAAA,IAAD,CAAC,CAAE,QAAQ,EAAE,MAAA,CAAK,CAAC,KAAA,QAAD,CAAC,KAAA,KAAA,IAAA,KAAA,IAAD,CAAC,CAAE,QAAQ,EAAE,CAAA,CAAC;IAC3C,CAAC;IAFe,SAAA,MAAM,GAAA,MAErB,CAAA;IAED,SAAgB,QAAQ,CAAC,IAAkB,EAAE,EAAgB;QACzD,MAAM,QAAQ,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAC7D,MAAM,MAAM,GAAG,OAAO,EAAE,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC;QACrD,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAChE,MAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC5D,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,MAAO,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;YAC/B,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC9B,MAAM;YACV,CAAC;QACL,CAAC;QACD,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACpD,MAAM,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC1C,OAAO,QAAQ,GAAG,MAAM,CAAC;IAC7B,CAAC;IAde,SAAA,QAAQ,GAAA,QAcvB,CAAA;IAED,SAAgB,SAAS,CAAC,GAAiB;QACvC,OAAO,sNAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC;IAChD,CAAC;IAFe,SAAA,SAAS,GAAA,SAExB,CAAA;AAEL,CAAC,EAhCgB,QAAQ,IAAA,CAAR,QAAQ,GAAA,CAAA,CAAA,GAgCxB"}},
    {"offset": {"line": 5399, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/references/references.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/references/references.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, CstNode, GenericAstNode } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { ReferenceDescription } from '../workspace/ast-descriptions.js';\r\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { NameProvider } from './name-provider.js';\r\nimport type { URI } from '../utils/uri-utils.js';\r\nimport { findAssignment } from '../utils/grammar-utils.js';\r\nimport { isReference } from '../syntax-tree.js';\r\nimport { getDocument } from '../utils/ast-utils.js';\r\nimport { isChildNode, toDocumentSegment } from '../utils/cst-utils.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { UriUtils } from '../utils/uri-utils.js';\r\n\r\n/**\r\n * Language-specific service for finding references and declaration of a given `CstNode`.\r\n */\r\nexport interface References {\r\n\r\n    /**\r\n     * If the CstNode is a reference node the target CstNode will be returned.\r\n     * If the CstNode is a significant node of the CstNode this CstNode will be returned.\r\n     *\r\n     * @param sourceCstNode CstNode that points to a AstNode\r\n     */\r\n    findDeclaration(sourceCstNode: CstNode): AstNode | undefined;\r\n\r\n    /**\r\n     * If the CstNode is a reference node the target CstNode will be returned.\r\n     * If the CstNode is a significant node of the CstNode this CstNode will be returned.\r\n     *\r\n     * @param sourceCstNode CstNode that points to a AstNode\r\n     */\r\n    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined;\r\n\r\n    /**\r\n     * Finds all references to the target node as references (local references) or reference descriptions.\r\n     *\r\n     * @param targetNode Specified target node whose references should be returned\r\n     */\r\n    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription>;\r\n}\r\n\r\nexport interface FindReferencesOptions {\r\n    /**\r\n     * @deprecated Since v1.2.0. Please use `documentUri` instead.\r\n     */\r\n    onlyLocal?: boolean;\r\n    /**\r\n     * When set, the `findReferences` method will only return references/declarations from the specified document.\r\n     */\r\n    documentUri?: URI;\r\n    /**\r\n     * Whether the returned list of references should include the declaration.\r\n     */\r\n    includeDeclaration?: boolean;\r\n}\r\n\r\nexport class DefaultReferences implements References {\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly index: IndexManager;\r\n    protected readonly nodeLocator: AstNodeLocator;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.index = services.shared.workspace.IndexManager;\r\n        this.nodeLocator = services.workspace.AstNodeLocator;\r\n    }\r\n\r\n    findDeclaration(sourceCstNode: CstNode): AstNode | undefined {\r\n        if (sourceCstNode) {\r\n            const assignment = findAssignment(sourceCstNode);\r\n            const nodeElem = sourceCstNode.astNode;\r\n            if (assignment && nodeElem) {\r\n                const reference = (nodeElem as GenericAstNode)[assignment.feature];\r\n\r\n                if (isReference(reference)) {\r\n                    return reference.ref;\r\n                } else if (Array.isArray(reference)) {\r\n                    for (const ref of reference) {\r\n                        if (isReference(ref) && ref.$refNode\r\n                            && ref.$refNode.offset <= sourceCstNode.offset\r\n                            && ref.$refNode.end >= sourceCstNode.end) {\r\n                            return ref.ref;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (nodeElem) {\r\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\r\n                // Only return the targeted node in case the targeted cst node is the name node or part of it\r\n                if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {\r\n                    return nodeElem;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined {\r\n        const astNode = this.findDeclaration(sourceCstNode);\r\n        if (astNode?.$cstNode) {\r\n            const targetNode = this.nameProvider.getNameNode(astNode);\r\n            return targetNode ?? astNode.$cstNode;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription> {\r\n        const refs: ReferenceDescription[] = [];\r\n        if (options.includeDeclaration) {\r\n            const ref = this.getReferenceToSelf(targetNode);\r\n            if (ref) {\r\n                refs.push(ref);\r\n            }\r\n        }\r\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\r\n        if (options.documentUri) {\r\n            indexReferences = indexReferences.filter(ref => UriUtils.equals(ref.sourceUri, options.documentUri));\r\n        }\r\n        refs.push(...indexReferences);\r\n        return stream(refs);\r\n    }\r\n\r\n    protected getReferenceToSelf(targetNode: AstNode): ReferenceDescription | undefined {\r\n        const nameNode = this.nameProvider.getNameNode(targetNode);\r\n        if (nameNode) {\r\n            const doc = getDocument(targetNode);\r\n            const path = this.nodeLocator.getAstNodePath(targetNode);\r\n            return {\r\n                sourceUri: doc.uri,\r\n                sourcePath: path,\r\n                targetUri: doc.uri,\r\n                targetPath: path,\r\n                segment: toDocumentSegment(nameNode),\r\n                local: true\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5495, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/collections.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/collections.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Stream } from './stream.js';\r\nimport { Reduction, stream } from './stream.js';\r\n\r\n/**\r\n * A multimap is a variation of a Map that has potentially multiple values for every key.\r\n */\r\nexport class MultiMap<K, V> {\r\n\r\n    private map = new Map<K, V[]>();\r\n\r\n    constructor()\r\n    constructor(elements: Array<[K, V]>)\r\n    constructor(elements?: Array<[K, V]>) {\r\n        if (elements) {\r\n            for (const [key, value] of elements) {\r\n                this.add(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The total number of values in the multimap.\r\n     */\r\n    get size(): number {\r\n        return Reduction.sum(stream(this.map.values()).map(a => a.length));\r\n    }\r\n\r\n    /**\r\n     * Clear all entries in the multimap.\r\n     */\r\n    clear(): void {\r\n        this.map.clear();\r\n    }\r\n\r\n    /**\r\n     * Operates differently depending on whether a `value` is given:\r\n     *  * With a value, this method deletes the specific key / value pair from the multimap.\r\n     *  * Without a value, all values associated with the given key are deleted.\r\n     *\r\n     * @returns `true` if a value existed and has been removed, or `false` if the specified\r\n     *     key / value does not exist.\r\n     */\r\n    delete(key: K, value?: V): boolean {\r\n        if (value === undefined) {\r\n            return this.map.delete(key);\r\n        } else {\r\n            const values = this.map.get(key);\r\n            if (values) {\r\n                const index = values.indexOf(value);\r\n                if (index >= 0) {\r\n                    if (values.length === 1) {\r\n                        this.map.delete(key);\r\n                    } else {\r\n                        values.splice(index, 1);\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of all values associated with the given key. If no value exists,\r\n     * an empty array is returned.\r\n     *\r\n     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\r\n     * value and `delete` to remove a value from the multimap.\r\n     */\r\n    get(key: K): readonly V[] {\r\n        return this.map.get(key) ?? [];\r\n    }\r\n\r\n    /**\r\n     * Operates differently depending on whether a `value` is given:\r\n     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\r\n     *  * Without a value, this method returns `true` if the given key is present in the multimap.\r\n     */\r\n    has(key: K, value?: V): boolean {\r\n        if (value === undefined) {\r\n            return this.map.has(key);\r\n        } else {\r\n            const values = this.map.get(key);\r\n            if (values) {\r\n                return values.indexOf(value) >= 0;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the given key / value pair to the multimap.\r\n     */\r\n    add(key: K, value: V): this {\r\n        if (this.map.has(key)) {\r\n            this.map.get(key)!.push(value);\r\n        } else {\r\n            this.map.set(key, [value]);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add the given set of key / value pairs to the multimap.\r\n     */\r\n    addAll(key: K, values: Iterable<V>): this {\r\n        if (this.map.has(key)) {\r\n            this.map.get(key)!.push(...values);\r\n        } else {\r\n            this.map.set(key, Array.from(values));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Invokes the given callback function for every key / value pair in the multimap.\r\n     */\r\n    forEach(callbackfn: (value: V, key: K, map: this) => void): void {\r\n        this.map.forEach((array, key) =>\r\n            array.forEach(value => callbackfn(value, key, this))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns an iterator of key, value pairs for every entry in the map.\r\n     */\r\n    [Symbol.iterator](): Iterator<[K, V]> {\r\n        return this.entries().iterator();\r\n    }\r\n\r\n    /**\r\n     * Returns a stream of key, value pairs for every entry in the map.\r\n     */\r\n    entries(): Stream<[K, V]> {\r\n        return stream(this.map.entries())\r\n            .flatMap(([key, array]) => array.map(value => [key, value] as [K, V]));\r\n    }\r\n\r\n    /**\r\n     * Returns a stream of keys in the map.\r\n     */\r\n    keys(): Stream<K> {\r\n        return stream(this.map.keys());\r\n    }\r\n\r\n    /**\r\n     * Returns a stream of values in the map.\r\n     */\r\n    values(): Stream<V> {\r\n        return stream(this.map.values()).flat();\r\n    }\r\n\r\n    /**\r\n     * Returns a stream of key, value set pairs for every key in the map.\r\n     */\r\n    entriesGroupedByKey(): Stream<[K, V[]]> {\r\n        return stream(this.map.entries());\r\n    }\r\n\r\n}\r\n\r\nexport class BiMap<K, V> {\r\n\r\n    private map = new Map<K, V>();\r\n    private inverse = new Map<V, K>();\r\n\r\n    get size(): number {\r\n        return this.map.size;\r\n    }\r\n\r\n    constructor()\r\n    constructor(elements: Array<[K, V]>)\r\n    constructor(elements?: Array<[K, V]>) {\r\n        if (elements) {\r\n            for (const [key, value] of elements) {\r\n                this.set(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        this.map.clear();\r\n        this.inverse.clear();\r\n    }\r\n\r\n    set(key: K, value: V): this {\r\n        this.map.set(key, value);\r\n        this.inverse.set(value, key);\r\n        return this;\r\n    }\r\n\r\n    get(key: K): V | undefined {\r\n        return this.map.get(key);\r\n    }\r\n\r\n    getKey(value: V): K | undefined {\r\n        return this.inverse.get(value);\r\n    }\r\n\r\n    delete(key: K): boolean {\r\n        const value = this.map.get(key);\r\n        if (value !== undefined) {\r\n            this.map.delete(key);\r\n            this.inverse.delete(value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5675, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/references/scope-computation.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/references/scope-computation.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021-2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription } from '../syntax-tree.js';\r\nimport type { AstNodeDescriptionProvider } from '../workspace/ast-descriptions.js';\r\nimport type { LangiumDocument, PrecomputedScopes } from '../workspace/documents.js';\r\nimport type { NameProvider } from './name-provider.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { streamAllContents, streamContents } from '../utils/ast-utils.js';\r\nimport { MultiMap } from '../utils/collections.js';\r\nimport { interruptAndCheck } from '../utils/promise-utils.js';\r\n\r\n/**\r\n * Language-specific service for precomputing global and local scopes. The service methods are executed\r\n * as the first and second phase in the `DocumentBuilder`.\r\n */\r\nexport interface ScopeComputation {\r\n\r\n    /**\r\n     * Creates descriptions of all AST nodes that shall be exported into the _global_ scope from the given\r\n     * document. These descriptions are gathered by the `IndexManager` and stored in the global index so\r\n     * they can be referenced from other documents.\r\n     *\r\n     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference resolution\r\n     * depends on the scope computation phase to be completed (`computeScope` method), which runs after the\r\n     * initial indexing where this method is used.\r\n     *\r\n     * @param document The document from which to gather exported AST nodes.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    computeExports(document: LangiumDocument, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;\r\n\r\n    /**\r\n     * Precomputes the _local_ scopes for a document, which are necessary for the default way of\r\n     * resolving references to symbols in the same document. The result is a multimap assigning a\r\n     * set of AST node descriptions to every level of the AST. These data are used by the `ScopeProvider`\r\n     * service to determine which target nodes are visible in the context of a specific cross-reference.\r\n     *\r\n     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference\r\n     * resolution depends on the scope computation phase to be completed.\r\n     *\r\n     * @param document The document in which to compute scopes.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken): Promise<PrecomputedScopes>;\r\n\r\n}\r\n\r\n/**\r\n * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the\r\n * _global_ scope from the given document. By default those are the document's root AST node and its directly\r\n * contained child nodes.\r\n *\r\n * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them\r\n * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,\r\n * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)\r\n * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)\r\n * are _invisible_ by default, but that can be changed by customizing this service.\r\n */\r\nexport class DefaultScopeComputation implements ScopeComputation {\r\n\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly descriptions: AstNodeDescriptionProvider;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\r\n    }\r\n\r\n    async computeExports(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<AstNodeDescription[]> {\r\n        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);\r\n    }\r\n\r\n    /**\r\n     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\r\n     * The list of children to be considered is determined by the function parameter {@link children}.\r\n     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\r\n     *\r\n     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\r\n     * @param document The document containing the AST node to be exported.\r\n     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCancelled` if a user action occurs during execution.\r\n     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\r\n     */\r\n    async computeExportsForNode(parentNode: AstNode, document: LangiumDocument<AstNode>, children: (root: AstNode) => Iterable<AstNode> = streamContents, cancelToken: CancellationToken = CancellationToken.None): Promise<AstNodeDescription[]> {\r\n        const exports: AstNodeDescription[] = [];\r\n\r\n        this.exportNode(parentNode, exports, document);\r\n        for (const node of children(parentNode)) {\r\n            await interruptAndCheck(cancelToken);\r\n            this.exportNode(node, exports, document);\r\n        }\r\n        return exports;\r\n    }\r\n\r\n    /**\r\n     * Add a single node to the list of exports if it has a name. Override this method to change how\r\n     * symbols are exported, e.g. by modifying their exported name.\r\n     */\r\n    protected exportNode(node: AstNode, exports: AstNodeDescription[], document: LangiumDocument): void {\r\n        const name = this.nameProvider.getName(node);\r\n        if (name) {\r\n            exports.push(this.descriptions.createDescription(node, name, document));\r\n        }\r\n    }\r\n\r\n    async computeLocalScopes(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<PrecomputedScopes> {\r\n        const rootNode = document.parseResult.value;\r\n        const scopes = new MultiMap<AstNode, AstNodeDescription>();\r\n        // Here we navigate the full AST - local scopes shall be available in the whole document\r\n        for (const node of streamAllContents(rootNode)) {\r\n            await interruptAndCheck(cancelToken);\r\n            this.processNode(node, document, scopes);\r\n        }\r\n        return scopes;\r\n    }\r\n\r\n    /**\r\n     * Process a single node during scopes computation. The default implementation makes the node visible\r\n     * in the subtree of its container (if the node has a name). Override this method to change this,\r\n     * e.g. by increasing the visibility to a higher level in the AST.\r\n     */\r\n    protected processNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void {\r\n        const container = node.$container;\r\n        if (container) {\r\n            const name = this.nameProvider.getName(node);\r\n            if (name) {\r\n                scopes.add(container, this.descriptions.createDescription(node, name, document));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAOhF,OAAO,EAAE,iBAAiB,EAAE,MAAM,0BAA0B,CAAC;AAC7D,OAAO,EAAE,iBAAiB,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAC;AAC1E,OAAO,EAAE,QAAQ,EAAE,MAAM,yBAAyB,CAAC;AACnD,OAAO,EAAE,iBAAiB,EAAE,MAAM,2BAA2B,CAAC;;;;;AAmDxD,MAAO,uBAAuB;IAKhC,YAAY,QAA6B,CAAA;QACrC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC;QACrD,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,SAAS,CAAC,0BAA0B,CAAC;IACtE,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,QAAyB,EAAE,WAAW,GAAG,qPAAiB,CAAC,IAAI,EAAA;QAChF,OAAO,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,WAAW,CAAC,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;IACpG,CAAC;IAED;;;;;;;;;;;OAWG,CACH,KAAK,CAAC,qBAAqB,CAAC,UAAmB,EAAE,QAAkC,EAAE,WAAiD,6NAAc,EAAE,cAAiC,qPAAiB,CAAC,IAAI,EAAA;QACzM,MAAM,OAAO,GAAyB,EAAE,CAAC;QAEzC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC/C,KAAK,MAAM,IAAI,IAAI,QAAQ,CAAC,UAAU,CAAC,CAAE,CAAC;YACtC,UAAM,oOAAiB,EAAC,WAAW,CAAC,CAAC;YACrC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC7C,CAAC;QACD,OAAO,OAAO,CAAC;IACnB,CAAC;IAED;;;OAGG,CACO,UAAU,CAAC,IAAa,EAAE,OAA6B,EAAE,QAAyB,EAAA;QACxF,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC7C,IAAI,IAAI,EAAE,CAAC;YACP,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC5E,CAAC;IACL,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,QAAyB,EAAE,WAAW,GAAG,qPAAiB,CAAC,IAAI,EAAA;QACpF,MAAM,QAAQ,GAAG,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC;QAC5C,MAAM,MAAM,GAAG,IAAI,sNAAQ,EAA+B,CAAC;QAC3D,wFAAwF;QACxF,KAAK,MAAM,IAAI,QAAI,gOAAiB,EAAC,QAAQ,CAAC,CAAE,CAAC;YAC7C,UAAM,oOAAiB,EAAC,WAAW,CAAC,CAAC;YACrC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;QAC7C,CAAC;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;;;OAIG,CACO,WAAW,CAAC,IAAa,EAAE,QAAyB,EAAE,MAAyB,EAAA;QACrF,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,IAAI,SAAS,EAAE,CAAC;YACZ,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC7C,IAAI,IAAI,EAAE,CAAC;gBACP,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;YACrF,CAAC;QACL,CAAC;IACL,CAAC;CAEJ"}},
    {"offset": {"line": 5756, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/references/scope.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/references/scope.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNodeDescription } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { EMPTY_STREAM, stream } from '../utils/stream.js';\r\n\r\n/**\r\n * A scope describes what target elements are visible from a specific cross-reference context.\r\n */\r\nexport interface Scope {\r\n\r\n    /**\r\n     * Find a target element matching the given name. If no element is found, `undefined` is returned.\r\n     * If multiple matching elements are present, the selection of the returned element should be done\r\n     * according to the semantics of your language. Usually it is the element that is most closely defined.\r\n     *\r\n     * @param name Name of the cross-reference target as it appears in the source text.\r\n     */\r\n    getElement(name: string): AstNodeDescription | undefined;\r\n\r\n    /**\r\n     * Create a stream of all elements in the scope. This is used to compute completion proposals to be\r\n     * shown in the editor.\r\n     */\r\n    getAllElements(): Stream<AstNodeDescription>;\r\n\r\n}\r\n\r\nexport interface ScopeOptions {\r\n    caseInsensitive?: boolean;\r\n}\r\n\r\n/**\r\n * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing\r\n * the next level of elements, which are queried when a target element is not found in the stream provided\r\n * to this scope.\r\n */\r\nexport class StreamScope implements Scope {\r\n    readonly elements: Stream<AstNodeDescription>;\r\n    readonly outerScope?: Scope;\r\n    readonly caseInsensitive: boolean;\r\n\r\n    constructor(elements: Stream<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions) {\r\n        this.elements = elements;\r\n        this.outerScope = outerScope;\r\n        this.caseInsensitive = options?.caseInsensitive ?? false;\r\n    }\r\n\r\n    getAllElements(): Stream<AstNodeDescription> {\r\n        if (this.outerScope) {\r\n            return this.elements.concat(this.outerScope.getAllElements());\r\n        } else {\r\n            return this.elements;\r\n        }\r\n    }\r\n\r\n    getElement(name: string): AstNodeDescription | undefined {\r\n        const local = this.caseInsensitive\r\n            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())\r\n            : this.elements.find(e => e.name === name);\r\n        if (local) {\r\n            return local;\r\n        }\r\n        if (this.outerScope) {\r\n            return this.outerScope.getElement(name);\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport class MapScope implements Scope {\r\n    readonly elements: Map<string, AstNodeDescription>;\r\n    readonly outerScope?: Scope;\r\n    readonly caseInsensitive: boolean;\r\n\r\n    constructor(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions) {\r\n        this.elements = new Map();\r\n        this.caseInsensitive = options?.caseInsensitive ?? false;\r\n        for (const element of elements) {\r\n            const name = this.caseInsensitive\r\n                ? element.name.toLowerCase()\r\n                : element.name;\r\n            this.elements.set(name, element);\r\n        }\r\n        this.outerScope = outerScope;\r\n    }\r\n\r\n    getElement(name: string): AstNodeDescription | undefined {\r\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\r\n        const local = this.elements.get(localName);\r\n        if (local) {\r\n            return local;\r\n        }\r\n        if (this.outerScope) {\r\n            return this.outerScope.getElement(name);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    getAllElements(): Stream<AstNodeDescription> {\r\n        let elementStream = stream(this.elements.values());\r\n        if (this.outerScope) {\r\n            elementStream = elementStream.concat(this.outerScope.getAllElements());\r\n        }\r\n        return elementStream;\r\n    }\r\n\r\n}\r\n\r\nexport const EMPTY_SCOPE: Scope = {\r\n    getElement(): undefined {\r\n        return undefined;\r\n    },\r\n    getAllElements(): Stream<AstNodeDescription> {\r\n        return EMPTY_STREAM;\r\n    }\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5837, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/caching.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/caching.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Disposable } from './disposable.js';\r\nimport type { URI } from './uri-utils.js';\r\nimport type { LangiumSharedCoreServices } from '../services.js';\r\nimport type { DocumentState } from '../workspace/documents.js';\r\n\r\nexport abstract class DisposableCache implements Disposable {\r\n\r\n    protected toDispose: Disposable[] = [];\r\n    protected isDisposed = false;\r\n\r\n    onDispose(disposable: Disposable): void {\r\n        this.toDispose.push(disposable);\r\n    }\r\n\r\n    dispose(): void {\r\n        this.throwIfDisposed();\r\n        this.clear();\r\n        this.isDisposed = true;\r\n        this.toDispose.forEach(disposable => disposable.dispose());\r\n    }\r\n\r\n    protected throwIfDisposed(): void {\r\n        if (this.isDisposed) {\r\n            throw new Error('This cache has already been disposed');\r\n        }\r\n    }\r\n\r\n    abstract clear(): void;\r\n}\r\n\r\nexport class SimpleCache<K, V> extends DisposableCache {\r\n    protected readonly cache = new Map<K, V>();\r\n\r\n    has(key: K): boolean {\r\n        this.throwIfDisposed();\r\n        return this.cache.has(key);\r\n    }\r\n\r\n    set(key: K, value: V): void {\r\n        this.throwIfDisposed();\r\n        this.cache.set(key, value);\r\n    }\r\n\r\n    get(key: K): V | undefined;\r\n    get(key: K, provider: () => V): V;\r\n    get(key: K, provider?: () => V): V | undefined {\r\n        this.throwIfDisposed();\r\n        if (this.cache.has(key)) {\r\n            return this.cache.get(key);\r\n        } else if (provider) {\r\n            const value = provider();\r\n            this.cache.set(key, value);\r\n            return value;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    delete(key: K): boolean {\r\n        this.throwIfDisposed();\r\n        return this.cache.delete(key);\r\n    }\r\n\r\n    clear(): void {\r\n        this.throwIfDisposed();\r\n        this.cache.clear();\r\n    }\r\n}\r\n\r\nexport class ContextCache<Context, Key, Value, ContextKey = Context> extends DisposableCache {\r\n\r\n    private readonly cache = new Map<ContextKey | Context, Map<Key, Value>>();\r\n    private readonly converter: (input: Context) => ContextKey | Context;\r\n\r\n    constructor(converter?: (input: Context) => ContextKey) {\r\n        super();\r\n        this.converter = converter ?? (value => value);\r\n    }\r\n\r\n    has(contextKey: Context, key: Key): boolean {\r\n        this.throwIfDisposed();\r\n        return this.cacheForContext(contextKey).has(key);\r\n    }\r\n\r\n    set(contextKey: Context, key: Key, value: Value): void {\r\n        this.throwIfDisposed();\r\n        this.cacheForContext(contextKey).set(key, value);\r\n    }\r\n\r\n    get(contextKey: Context, key: Key): Value | undefined;\r\n    get(contextKey: Context, key: Key, provider: () => Value): Value;\r\n    get(contextKey: Context, key: Key, provider?: () => Value): Value | undefined {\r\n        this.throwIfDisposed();\r\n        const contextCache = this.cacheForContext(contextKey);\r\n        if (contextCache.has(key)) {\r\n            return contextCache.get(key);\r\n        } else if (provider) {\r\n            const value = provider();\r\n            contextCache.set(key, value);\r\n            return value;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    delete(contextKey: Context, key: Key): boolean {\r\n        this.throwIfDisposed();\r\n        return this.cacheForContext(contextKey).delete(key);\r\n    }\r\n\r\n    clear(): void;\r\n    clear(contextKey: Context): void;\r\n    clear(contextKey?: Context): void {\r\n        this.throwIfDisposed();\r\n        if (contextKey) {\r\n            const mapKey = this.converter(contextKey);\r\n            this.cache.delete(mapKey);\r\n        } else {\r\n            this.cache.clear();\r\n        }\r\n    }\r\n\r\n    protected cacheForContext(contextKey: Context): Map<Key, Value> {\r\n        const mapKey = this.converter(contextKey);\r\n        let documentCache = this.cache.get(mapKey);\r\n        if (!documentCache) {\r\n            documentCache = new Map();\r\n            this.cache.set(mapKey, documentCache);\r\n        }\r\n        return documentCache;\r\n    }\r\n}\r\n\r\n/**\r\n * Every key/value pair in this cache is scoped to a document.\r\n * If this document is changed or deleted, all associated key/value pairs are deleted.\r\n */\r\nexport class DocumentCache<K, V> extends ContextCache<URI | string, K, V, string> {\r\n\r\n    /**\r\n     * Creates a new document cache.\r\n     *\r\n     * @param sharedServices Service container instance to hook into document lifecycle events.\r\n     * @param state Optional document state on which the cache should evict.\r\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\r\n     * *Deleted* documents are considered in both cases.\r\n     *\r\n     * Providing a state here will use `DocumentBuilder#onDocumentPhase` instead,\r\n     * which triggers on all documents that have been affected by this change, assuming that the\r\n     * state is `DocumentState.Linked` or a later state.\r\n     */\r\n    constructor(sharedServices: LangiumSharedCoreServices, state?: DocumentState) {\r\n        super(uri => uri.toString());\r\n        if (state) {\r\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onDocumentPhase(state, document => {\r\n                this.clear(document.uri.toString());\r\n            }));\r\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\r\n                for (const uri of deleted) { // react only on deleted documents\r\n                    this.clear(uri);\r\n                }\r\n            }));\r\n        } else {\r\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\r\n                const allUris = changed.concat(deleted); // react on both changed and deleted documents\r\n                for (const uri of allUris) {\r\n                    this.clear(uri);\r\n                }\r\n            }));\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Every key/value pair in this cache is scoped to the whole workspace.\r\n * If any document in the workspace is added, changed or deleted, the whole cache is evicted.\r\n */\r\nexport class WorkspaceCache<K, V> extends SimpleCache<K, V> {\r\n\r\n    /**\r\n     * Creates a new workspace cache.\r\n     *\r\n     * @param sharedServices Service container instance to hook into document lifecycle events.\r\n     * @param state Optional document state on which the cache should evict.\r\n     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\r\n     * *Deleted* documents are considered in both cases.\r\n     */\r\n    constructor(sharedServices: LangiumSharedCoreServices, state?: DocumentState) {\r\n        super();\r\n        if (state) {\r\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onBuildPhase(state, () => {\r\n                this.clear();\r\n            }));\r\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\r\n                if (deleted.length > 0) { // react only on deleted documents\r\n                    this.clear();\r\n                }\r\n            }));\r\n        } else {\r\n            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate(() => { // react on both changed and deleted documents\r\n                this.clear();\r\n            }));\r\n        }\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6020, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/references/scope-provider.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/references/scope-provider.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021-2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { AstNodeDescriptionProvider } from '../workspace/ast-descriptions.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { NameProvider } from './name-provider.js';\r\nimport type { Scope, ScopeOptions} from './scope.js';\r\nimport { MapScope, StreamScope } from './scope.js';\r\nimport { getDocument } from '../utils/ast-utils.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { WorkspaceCache } from '../utils/caching.js';\r\n\r\n/**\r\n * Language-specific service for determining the scope of target elements visible in a specific cross-reference context.\r\n */\r\nexport interface ScopeProvider {\r\n\r\n    /**\r\n     * Return a scope describing what elements are visible for the given AST node and cross-reference\r\n     * identifier.\r\n     *\r\n     * @param context Information about the reference for which a scope is requested.\r\n     */\r\n    getScope(context: ReferenceInfo): Scope;\r\n\r\n}\r\n\r\nexport class DefaultScopeProvider implements ScopeProvider {\r\n\r\n    protected readonly reflection: AstReflection;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly descriptions: AstNodeDescriptionProvider;\r\n    protected readonly indexManager: IndexManager;\r\n\r\n    protected readonly globalScopeCache: WorkspaceCache<string, Scope>;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\r\n        this.indexManager = services.shared.workspace.IndexManager;\r\n        this.globalScopeCache = new WorkspaceCache<string, Scope>(services.shared);\r\n    }\r\n\r\n    getScope(context: ReferenceInfo): Scope {\r\n        const scopes: Array<Stream<AstNodeDescription>> = [];\r\n        const referenceType = this.reflection.getReferenceType(context);\r\n\r\n        const precomputed = getDocument(context.container).precomputedScopes;\r\n        if (precomputed) {\r\n            let currentNode: AstNode | undefined = context.container;\r\n            do {\r\n                const allDescriptions = precomputed.get(currentNode);\r\n                if (allDescriptions.length > 0) {\r\n                    scopes.push(stream(allDescriptions).filter(\r\n                        desc => this.reflection.isSubtype(desc.type, referenceType)));\r\n                }\r\n                currentNode = currentNode.$container;\r\n            } while (currentNode);\r\n        }\r\n\r\n        let result: Scope = this.getGlobalScope(referenceType, context);\r\n        for (let i = scopes.length - 1; i >= 0; i--) {\r\n            result = this.createScope(scopes[i], result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a scope for the given collection of AST node descriptions.\r\n     */\r\n    protected createScope(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions): Scope {\r\n        return new StreamScope(stream(elements), outerScope, options);\r\n    }\r\n\r\n    /**\r\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\r\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\r\n     */\r\n    protected createScopeForNodes(elements: Iterable<AstNode>, outerScope?: Scope, options?: ScopeOptions): Scope {\r\n        const s = stream(elements).map(e => {\r\n            const name = this.nameProvider.getName(e);\r\n            if (name) {\r\n                return this.descriptions.createDescription(e, name);\r\n            }\r\n            return undefined;\r\n        }).nonNullable();\r\n        return new StreamScope(s, outerScope, options);\r\n    }\r\n\r\n    /**\r\n     * Create a global scope filtered for the given reference type.\r\n     */\r\n    protected getGlobalScope(referenceType: string, _context: ReferenceInfo): Scope {\r\n        return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6092, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/serializer/json-serializer.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/serializer/json-serializer.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { URI } from 'vscode-uri';\r\nimport type { CommentProvider } from '../documentation/comment-provider.js';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, CstNode, GenericAstNode, Mutable, Reference } from '../syntax-tree.js';\r\nimport { isAstNode, isReference } from '../syntax-tree.js';\r\nimport { getDocument } from '../utils/ast-utils.js';\r\nimport { findNodesForProperty } from '../utils/grammar-utils.js';\r\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\r\nimport type { DocumentSegment, LangiumDocument, LangiumDocuments } from '../workspace/documents.js';\r\n\r\nexport interface JsonSerializeOptions {\r\n    /** The space parameter for `JSON.stringify`, controlling whether and how to pretty-print the output. */\r\n    space?: string | number;\r\n    /** Whether to include the `$refText` property for references (the name used to identify the target node). */\r\n    refText?: boolean;\r\n    /** Whether to include the `$sourceText` property, which holds the full source text from which an AST node was parsed. */\r\n    sourceText?: boolean;\r\n    /** Whether to include the `$textRegion` property, which holds information to trace AST node properties to their respective source text regions. */\r\n    textRegions?: boolean;\r\n    /** Whether to include the `$comment` property, which holds comments according to the CommentProvider service. */\r\n    comments?: boolean;\r\n    /** The replacer parameter for `JSON.stringify`; the default replacer given as parameter should be used to apply basic replacements. */\r\n    replacer?: (key: string, value: unknown, defaultReplacer: (key: string, value: unknown) => unknown) => unknown\r\n    /** Used to convert and serialize URIs when the target of a cross-reference is in a different document. */\r\n    uriConverter?: (uri: URI, reference: Reference) => string\r\n}\r\n\r\nexport interface JsonDeserializeOptions {\r\n    /** Used to parse and convert URIs when the target of a cross-reference is in a different document. */\r\n    uriConverter?: (uri: string) => URI\r\n}\r\n\r\n/**\r\n * {@link AstNode}s that may carry information on their definition area within the DSL text.\r\n */\r\nexport interface AstNodeWithTextRegion extends AstNode {\r\n    $sourceText?: string;\r\n    $textRegion?: AstNodeRegionWithAssignments;\r\n}\r\n\r\n/**\r\n * {@link AstNode}s that may carry a semantically relevant comment.\r\n */\r\nexport interface AstNodeWithComment extends AstNode {\r\n    $comment?: string;\r\n}\r\n\r\nexport function isAstNodeWithComment(node: AstNode): node is AstNodeWithComment {\r\n    return typeof (node as AstNodeWithComment).$comment === 'string';\r\n}\r\n\r\n/**\r\n * A {@link DocumentSegment} representing the definition area of an AstNode within the DSL text.\r\n * Usually contains text region information on all assigned property values of the AstNode,\r\n * and may contain the defining file's URI as string.\r\n */\r\nexport interface AstNodeRegionWithAssignments extends DocumentSegment {\r\n    /**\r\n     * A record containing an entry for each assigned property of the AstNode.\r\n     * The key is equal to the property name and the value is an array of the property values'\r\n     * text regions, regardless of whether the property is a single value or list property.\r\n     */\r\n    assignments?: Record<string, DocumentSegment[]>;\r\n    /**\r\n     * The AstNode defining file's URI as string\r\n     */\r\n    documentURI?: string;\r\n}\r\n\r\n/**\r\n * Utility service for transforming an `AstNode` into a JSON string and vice versa.\r\n */\r\nexport interface JsonSerializer {\r\n    /**\r\n     * Serialize an `AstNode` into a JSON `string`.\r\n     * @param node The `AstNode` to be serialized.\r\n     * @param options Serialization options\r\n     */\r\n    serialize(node: AstNode, options?: JsonSerializeOptions): string;\r\n    /**\r\n     * Deserialize (parse) a JSON `string` into an `AstNode`.\r\n     */\r\n    deserialize<T extends AstNode = AstNode>(content: string, options?: JsonDeserializeOptions): T;\r\n}\r\n\r\n/**\r\n * A cross-reference in the serialized JSON representation of an AstNode.\r\n */\r\ninterface IntermediateReference {\r\n    /** URI pointing to the target element. This is either `#${path}` if the target is in the same document, or `${documentURI}#${path}` otherwise. */\r\n    $ref?: string\r\n    /** The actual text used to look up the reference target in the surrounding scope. */\r\n    $refText?: string\r\n    /** If any problem occurred while resolving the reference, it is described by this property. */\r\n    $error?: string\r\n}\r\n\r\nfunction isIntermediateReference(obj: unknown): obj is IntermediateReference {\r\n    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);\r\n}\r\n\r\nexport class DefaultJsonSerializer implements JsonSerializer {\r\n\r\n    /** The set of AstNode properties to be ignored by the serializer. */\r\n    ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);\r\n\r\n    /** The document that is currently processed by the serializer; this is used by the replacer function.  */\r\n    protected currentDocument: LangiumDocument | undefined;\r\n\r\n    protected readonly langiumDocuments: LangiumDocuments;\r\n    protected readonly astNodeLocator: AstNodeLocator;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly commentProvider: CommentProvider;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\r\n        this.astNodeLocator = services.workspace.AstNodeLocator;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.commentProvider = services.documentation.CommentProvider;\r\n    }\r\n\r\n    serialize(node: AstNode, options?: JsonSerializeOptions): string {\r\n        const serializeOptions = options ?? {};\r\n        const specificReplacer = options?.replacer;\r\n        const defaultReplacer = (key: string, value: unknown) => this.replacer(key, value, serializeOptions);\r\n        const replacer = specificReplacer ? (key: string, value: unknown) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\r\n\r\n        try {\r\n            this.currentDocument = getDocument(node);\r\n            return JSON.stringify(node, replacer, options?.space);\r\n        } finally {\r\n            this.currentDocument = undefined;\r\n        }\r\n    }\r\n\r\n    deserialize<T extends AstNode = AstNode>(content: string, options?: JsonDeserializeOptions): T {\r\n        const deserializeOptions = options ?? {};\r\n        const root = JSON.parse(content);\r\n        this.linkNode(root, root, deserializeOptions);\r\n        return root;\r\n    }\r\n\r\n    protected replacer(key: string, value: unknown, { refText, sourceText, textRegions, comments, uriConverter }: JsonSerializeOptions): unknown {\r\n        if (this.ignoreProperties.has(key)) {\r\n            return undefined;\r\n        } else if (isReference(value)) {\r\n            const refValue = value.ref;\r\n            const $refText = refText ? value.$refText : undefined;\r\n            if (refValue) {\r\n                const targetDocument = getDocument(refValue);\r\n                let targetUri = '';\r\n                if (this.currentDocument && this.currentDocument !== targetDocument) {\r\n                    if (uriConverter) {\r\n                        targetUri = uriConverter(targetDocument.uri, value);\r\n                    } else {\r\n                        targetUri = targetDocument.uri.toString();\r\n                    }\r\n                }\r\n                const targetPath = this.astNodeLocator.getAstNodePath(refValue);\r\n                return {\r\n                    $ref: `${targetUri}#${targetPath}`,\r\n                    $refText\r\n                } satisfies IntermediateReference;\r\n            } else {\r\n                return {\r\n                    $error: value.error?.message ?? 'Could not resolve reference',\r\n                    $refText\r\n                } satisfies IntermediateReference;\r\n            }\r\n        } else if (isAstNode(value)) {\r\n            let astNode: AstNodeWithTextRegion | undefined = undefined;\r\n            if (textRegions) {\r\n                astNode = this.addAstNodeRegionWithAssignmentsTo({ ...value });\r\n                if ((!key || value.$document) && astNode?.$textRegion) {\r\n                    // The document URI is added to the root node of the resulting JSON tree\r\n                    astNode.$textRegion.documentURI = this.currentDocument?.uri.toString();\r\n                }\r\n            }\r\n            if (sourceText && !key) {\r\n                astNode ??= { ...value };\r\n                astNode.$sourceText = value.$cstNode?.text;\r\n            }\r\n            if (comments) {\r\n                astNode ??= { ...value };\r\n                const comment = this.commentProvider.getComment(value);\r\n                if (comment) {\r\n                    (astNode as AstNodeWithComment).$comment = comment.replace(/\\r/g, '');\r\n                }\r\n            }\r\n            return astNode ?? value;\r\n        } else {\r\n            return value;\r\n        }\r\n    }\r\n\r\n    protected addAstNodeRegionWithAssignmentsTo(node: AstNodeWithTextRegion) {\r\n        const createDocumentSegment: (cstNode: CstNode) => AstNodeRegionWithAssignments = cstNode => <DocumentSegment>{\r\n            offset: cstNode.offset,\r\n            end: cstNode.end,\r\n            length: cstNode.length,\r\n            range: cstNode.range,\r\n        };\r\n\r\n        if (node.$cstNode) {\r\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\r\n            const assignments: Record<string, DocumentSegment[]> = textRegion.assignments = {};\r\n\r\n            Object.keys(node).filter(key => !key.startsWith('$')).forEach(key => {\r\n                const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\r\n                if (propertyAssignments.length !== 0) {\r\n                    assignments[key] = propertyAssignments;\r\n                }\r\n            });\r\n\r\n            return node;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected linkNode(node: GenericAstNode, root: AstNode, options: JsonDeserializeOptions, container?: AstNode, containerProperty?: string, containerIndex?: number) {\r\n        for (const [propertyName, item] of Object.entries(node)) {\r\n            if (Array.isArray(item)) {\r\n                for (let index = 0; index < item.length; index++) {\r\n                    const element = item[index];\r\n                    if (isIntermediateReference(element)) {\r\n                        item[index] = this.reviveReference(node, propertyName, root, element, options);\r\n                    } else if (isAstNode(element)) {\r\n                        this.linkNode(element as GenericAstNode, root, options, node, propertyName, index);\r\n                    }\r\n                }\r\n            } else if (isIntermediateReference(item)) {\r\n                node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\r\n            } else if (isAstNode(item)) {\r\n                this.linkNode(item as GenericAstNode, root, options, node, propertyName);\r\n            }\r\n        }\r\n        const mutable = node as Mutable<AstNode>;\r\n        mutable.$container = container;\r\n        mutable.$containerProperty = containerProperty;\r\n        mutable.$containerIndex = containerIndex;\r\n    }\r\n\r\n    protected reviveReference(container: AstNode, property: string, root: AstNode, reference: IntermediateReference, options: JsonDeserializeOptions): Reference | undefined {\r\n        let refText = reference.$refText;\r\n        let error = reference.$error;\r\n        if (reference.$ref) {\r\n            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\r\n            if (isAstNode(ref)) {\r\n                if (!refText) {\r\n                    refText = this.nameProvider.getName(ref);\r\n                }\r\n                return {\r\n                    $refText: refText ?? '',\r\n                    ref\r\n                };\r\n            } else {\r\n                error = ref;\r\n            }\r\n        }\r\n        if (error) {\r\n            const ref: Mutable<Reference> = {\r\n                $refText: refText ?? ''\r\n            };\r\n            ref.error = {\r\n                container,\r\n                property,\r\n                message: error,\r\n                reference: ref\r\n            };\r\n            return ref;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    protected getRefNode(root: AstNode, uri: string, uriConverter?: (uri: string) => URI): AstNode | string {\r\n        try {\r\n            const fragmentIndex = uri.indexOf('#');\r\n            if (fragmentIndex === 0) {\r\n                const node = this.astNodeLocator.getAstNode(root, uri.substring(1));\r\n                if (!node) {\r\n                    return 'Could not resolve path: ' + uri;\r\n                }\r\n                return node;\r\n            }\r\n            if (fragmentIndex < 0) {\r\n                const documentUri = uriConverter ? uriConverter(uri) : URI.parse(uri);\r\n                const document = this.langiumDocuments.getDocument(documentUri);\r\n                if (!document) {\r\n                    return 'Could not find document for URI: ' + uri;\r\n                }\r\n                return document.parseResult.value;\r\n            }\r\n            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI.parse(uri.substring(0, fragmentIndex));\r\n            const document = this.langiumDocuments.getDocument(documentUri);\r\n            if (!document) {\r\n                return 'Could not find document for URI: ' + uri;\r\n            }\r\n            if (fragmentIndex === uri.length - 1) {\r\n                return document.parseResult.value;\r\n            }\r\n            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\r\n            if (!node) {\r\n                return 'Could not resolve URI: ' + uri;\r\n            }\r\n            return node;\r\n        } catch (err) {\r\n            return String(err);\r\n        }\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6315, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/service-registry.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/service-registry.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices, LangiumSharedCoreServices } from './services.js';\r\nimport type { TextDocumentProvider } from './workspace/documents.js';\r\nimport { UriUtils, type URI } from './utils/uri-utils.js';\r\n\r\n/**\r\n * The service registry provides access to the language-specific {@link LangiumCoreServices} optionally including LSP-related services.\r\n * These are resolved via the URI of a text document.\r\n */\r\nexport interface ServiceRegistry {\r\n\r\n    /**\r\n     * Register a language via its injected services.\r\n     */\r\n    register(language: LangiumCoreServices): void;\r\n\r\n    /**\r\n     * Retrieve the language-specific services for the given URI. In case only one language is\r\n     * registered, it may be used regardless of the URI format.\r\n     */\r\n    getServices(uri: URI): LangiumCoreServices;\r\n\r\n    /**\r\n     * Check whether services are available for the given URI.\r\n     */\r\n    hasServices(uri: URI): boolean;\r\n\r\n    /**\r\n     * The full set of registered language services.\r\n     */\r\n    readonly all: readonly LangiumCoreServices[];\r\n}\r\n\r\n/**\r\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\r\n */\r\nexport class DefaultServiceRegistry implements ServiceRegistry {\r\n\r\n    protected singleton?: LangiumCoreServices;\r\n    protected readonly languageIdMap = new Map<string, LangiumCoreServices>();\r\n    protected readonly fileExtensionMap = new Map<string, LangiumCoreServices>();\r\n\r\n    /**\r\n     * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.\r\n     */\r\n    protected get map(): Map<string, LangiumCoreServices> | undefined {\r\n        return this.fileExtensionMap;\r\n    }\r\n\r\n    protected readonly textDocuments?: TextDocumentProvider;\r\n\r\n    constructor(services?: LangiumSharedCoreServices) {\r\n        this.textDocuments = services?.workspace.TextDocuments;\r\n    }\r\n\r\n    register(language: LangiumCoreServices): void {\r\n        const data = language.LanguageMetaData;\r\n        for (const ext of data.fileExtensions) {\r\n            if (this.fileExtensionMap.has(ext)) {\r\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);\r\n            }\r\n            this.fileExtensionMap.set(ext, language);\r\n        }\r\n        this.languageIdMap.set(data.languageId, language);\r\n        if (this.languageIdMap.size === 1) {\r\n            this.singleton = language;\r\n        } else {\r\n            this.singleton = undefined;\r\n        }\r\n    }\r\n\r\n    getServices(uri: URI): LangiumCoreServices {\r\n        if (this.singleton !== undefined) {\r\n            return this.singleton;\r\n        }\r\n        if (this.languageIdMap.size === 0) {\r\n            throw new Error('The service registry is empty. Use `register` to register the services of a language.');\r\n        }\r\n        const languageId = this.textDocuments?.get(uri)?.languageId;\r\n        if (languageId !== undefined) {\r\n            const services = this.languageIdMap.get(languageId);\r\n            if (services) {\r\n                return services;\r\n            }\r\n        }\r\n        const ext = UriUtils.extname(uri);\r\n        const services = this.fileExtensionMap.get(ext);\r\n        if (!services) {\r\n            if (languageId) {\r\n                throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);\r\n            } else {\r\n                throw new Error(`The service registry contains no services for the extension '${ext}'.`);\r\n            }\r\n        }\r\n        return services;\r\n    }\r\n\r\n    hasServices(uri: URI): boolean {\r\n        try {\r\n            this.getServices(uri);\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    get all(): readonly LangiumCoreServices[] {\r\n        return Array.from(this.languageIdMap.values());\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6393, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/validation/validation-registry.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/validation/validation-registry.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CodeDescription, DiagnosticRelatedInformation, DiagnosticTag, integer, Range } from 'vscode-languageserver-types';\r\nimport { assertUnreachable } from '../index.js';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstReflection, Properties } from '../syntax-tree.js';\r\nimport type { CancellationToken } from '../utils/cancellation.js';\r\nimport { MultiMap } from '../utils/collections.js';\r\nimport type { MaybePromise } from '../utils/promise-utils.js';\r\nimport { isOperationCancelled } from '../utils/promise-utils.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport type { DocumentSegment } from '../workspace/documents.js';\r\n\r\nexport type DiagnosticInfo<N extends AstNode, P extends string = Properties<N>> = {\r\n    /** The AST node to which the diagnostic is attached. */\r\n    node: N;\r\n    /** If a property name is given, the diagnostic is restricted to the corresponding text region. */\r\n    property?: P;\r\n    /** If the value of a keyword is given, the diagnostic will appear at its corresponding text region */\r\n    keyword?: string;\r\n    /** In case of a multi-value property (array), an index can be given to select a specific element. */\r\n    index?: number;\r\n    /** If you want to create a diagnostic independent to any property, use the range property. */\r\n    range?: Range;\r\n    /** The diagnostic's code, which usually appear in the user interface. */\r\n    code?: integer | string;\r\n    /** An optional property to describe the error code. */\r\n    codeDescription?: CodeDescription;\r\n    /** Additional metadata about the diagnostic. */\r\n    tags?: DiagnosticTag[];\r\n    /** An array of related diagnostic information, e.g. when symbol-names within a scope collide all definitions can be marked via this property. */\r\n    relatedInformation?: DiagnosticRelatedInformation[];\r\n    /** A data entry field that is preserved between a `textDocument/publishDiagnostics` notification and `textDocument/codeAction` request. */\r\n    data?: unknown;\r\n}\r\n\r\n/**\r\n * Shape of information commonly used in the `data` field of diagnostics.\r\n */\r\nexport interface DiagnosticData {\r\n    /** Diagnostic code for identifying which code action to apply. This code is _not_ shown in the user interface. */\r\n    code: string\r\n    /** Specifies where to apply the code action in the form of a `DocumentSegment`. */\r\n    actionSegment?: DocumentSegment\r\n    /** Specifies where to apply the code action in the form of a `Range`. */\r\n    actionRange?: Range\r\n}\r\n\r\n/**\r\n * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.\r\n */\r\nexport function diagnosticData(code: string): DiagnosticData {\r\n    return { code };\r\n}\r\n\r\nexport type ValidationSeverity = 'error' | 'warning' | 'info' | 'hint';\r\n\r\nexport type ValidationAcceptor = <N extends AstNode>(severity: ValidationSeverity, message: string, info: DiagnosticInfo<N>) => void\r\n\r\nexport type ValidationCheck<T extends AstNode = AstNode> = (node: T, accept: ValidationAcceptor, cancelToken: CancellationToken) => MaybePromise<void>;\r\n\r\n/**\r\n * A utility type for describing functions which will be called once before or after all the AstNodes of an AST/Langium document are validated.\r\n *\r\n * The AST is represented by its root AstNode.\r\n *\r\n * The given validation acceptor helps to report some early or lately detected issues.\r\n *\r\n * The 'categories' indicate, which validation categories are executed for all the AstNodes.\r\n * This helps to tailor the preparations/tear-down logic to the actually executed checks on the nodes.\r\n *\r\n * It is recommended to support interrupts during long-running logic with 'interruptAndCheck(cancelToken)'.\r\n */\r\nexport type ValidationPreparation = (rootNode: AstNode, accept: ValidationAcceptor, categories: ValidationCategory[], cancelToken: CancellationToken) => MaybePromise<void>;\r\n\r\n/**\r\n * A utility type for associating non-primitive AST types to corresponding validation checks. For example:\r\n *\r\n * ```ts\r\n *   const checks: ValidationChecks<StatemachineAstType> = {\r\n *       State: validator.checkStateNameStartsWithCapital\r\n *    };\r\n * ```\r\n *\r\n * If an AST type does not extend AstNode, e.g. if it describes a union of string literals, that type's name must not occur as a key in objects of type `ValidationCheck<...>`.\r\n *\r\n * @param T a type definition mapping language specific type names (keys) to the corresponding types (values)\r\n */\r\nexport type ValidationChecks<T> = {\r\n    [K in keyof T]?: T[K] extends AstNode ? ValidationCheck<T[K]> | Array<ValidationCheck<T[K]>> : never\r\n} & {\r\n    AstNode?: ValidationCheck<AstNode> | Array<ValidationCheck<AstNode>>;\r\n}\r\n\r\n/**\r\n * `fast` checks can be executed after every document change (i.e. as the user is typing). If a check\r\n * is too slow it can delay the response to document changes, yielding bad user experience. By marking\r\n * it as `slow`, it will be skipped for normal as-you-type validation. Then it's up to you when to\r\n * schedule these long-running checks: after the fast checks are done, or after saving a document,\r\n * or with an explicit command, etc.\r\n *\r\n * `built-in` checks are errors produced by the lexer, the parser, or the linker. They cannot be used\r\n * for custom validation checks.\r\n */\r\nexport type ValidationCategory = 'fast' | 'slow' | 'built-in'\r\n\r\nexport namespace ValidationCategory {\r\n    export const all: readonly ValidationCategory[] = ['fast', 'slow', 'built-in'];\r\n}\r\n\r\ntype ValidationCheckEntry = {\r\n    check: ValidationCheck\r\n    category: ValidationCategory\r\n}\r\n\r\n/**\r\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\r\n */\r\nexport class ValidationRegistry {\r\n    private readonly entries = new MultiMap<string, ValidationCheckEntry>();\r\n    private readonly reflection: AstReflection;\r\n\r\n    private entriesBefore: ValidationPreparation[] = [];\r\n    private entriesAfter: ValidationPreparation[] = [];\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n    }\r\n\r\n    /**\r\n     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\r\n     * or an array of validation checks.\r\n     *\r\n     * @param checksRecord Set of validation checks to register.\r\n     * @param category Optional category for the validation checks (defaults to `'fast'`).\r\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\r\n     */\r\n    register<T>(checksRecord: ValidationChecks<T>, thisObj: ThisParameterType<unknown> = this, category: ValidationCategory = 'fast'): void {\r\n        if (category === 'built-in') {\r\n            throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\r\n        }\r\n        for (const [type, ch] of Object.entries(checksRecord)) {\r\n            const callbacks = ch as ValidationCheck | ValidationCheck[];\r\n            if (Array.isArray(callbacks)) {\r\n                for (const check of callbacks) {\r\n                    const entry: ValidationCheckEntry = {\r\n                        check: this.wrapValidationException(check, thisObj),\r\n                        category\r\n                    };\r\n                    this.addEntry(type, entry);\r\n                }\r\n            } else if (typeof callbacks === 'function') {\r\n                const entry: ValidationCheckEntry = {\r\n                    check: this.wrapValidationException(callbacks, thisObj),\r\n                    category\r\n                };\r\n                this.addEntry(type, entry);\r\n            } else {\r\n                assertUnreachable(callbacks);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected wrapValidationException(check: ValidationCheck, thisObj: unknown): ValidationCheck {\r\n        return async (node, accept, cancelToken) => {\r\n            await this.handleException(() => check.call(thisObj, node, accept, cancelToken), 'An error occurred during validation', accept, node);\r\n        };\r\n    }\r\n\r\n    protected async handleException(functionality: () => MaybePromise<void>, messageContext: string, accept: ValidationAcceptor, node: AstNode): Promise<void> {\r\n        try {\r\n            await functionality();\r\n        } catch (err) {\r\n            if (isOperationCancelled(err)) {\r\n                throw err;\r\n            }\r\n            console.error(`${messageContext}:`, err);\r\n            if (err instanceof Error && err.stack) {\r\n                console.error(err.stack);\r\n            }\r\n            const messageDetails = err instanceof Error ? err.message : String(err);\r\n            accept('error', `${messageContext}: ${messageDetails}`, { node });\r\n        }\r\n    }\r\n\r\n    protected addEntry(type: string, entry: ValidationCheckEntry): void {\r\n        if (type === 'AstNode') {\r\n            this.entries.add('AstNode', entry);\r\n            return;\r\n        }\r\n        for (const subtype of this.reflection.getAllSubTypes(type)) {\r\n            this.entries.add(subtype, entry);\r\n        }\r\n    }\r\n\r\n    getChecks(type: string, categories?: ValidationCategory[]): Stream<ValidationCheck> {\r\n        let checks = stream(this.entries.get(type))\r\n            .concat(this.entries.get('AstNode'));\r\n        if (categories) {\r\n            checks = checks.filter(entry => categories.includes(entry.category));\r\n        }\r\n        return checks.map(entry => entry.check);\r\n    }\r\n\r\n    /**\r\n     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.\r\n     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.\r\n     *\r\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\r\n     * here the map for mapping names to nodes could be established.\r\n     * During the usual checks on the nodes, they are put into this map with their name.\r\n     *\r\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\r\n     * Therefore it is recommended to clear stored information\r\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\r\n     * AND _after_ validating the AST to free memory by information which are no longer used.\r\n     *\r\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\r\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\r\n     */\r\n    registerBeforeDocument(checkBefore: ValidationPreparation, thisObj: ThisParameterType<unknown> = this): void {\r\n        this.entriesBefore.push(this.wrapPreparationException(checkBefore, 'An error occurred during set-up of the validation', thisObj));\r\n    }\r\n\r\n    /**\r\n     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.\r\n     * This helps to finally evaluate information which are collected during the checks on the AstNodes.\r\n     *\r\n     * As an example, for validating unique fully-qualified names of nodes in the AST,\r\n     * here the map with all the collected nodes and their names is checked\r\n     * and validation hints are created for all nodes with the same name.\r\n     *\r\n     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\r\n     * Therefore it is recommended to clear stored information\r\n     * _before_ validating an AST to validate each AST unaffected from other ASTs\r\n     * AND _after_ validating the AST to free memory by information which are no longer used.\r\n     *\r\n     * @param checkBefore a set-up function which will be called once before actually validating an AST\r\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\r\n     */\r\n    registerAfterDocument(checkAfter: ValidationPreparation, thisObj: ThisParameterType<unknown> = this): void {\r\n        this.entriesAfter.push(this.wrapPreparationException(checkAfter, 'An error occurred during tear-down of the validation', thisObj));\r\n    }\r\n\r\n    protected wrapPreparationException(check: ValidationPreparation, messageContext: string, thisObj: unknown): ValidationPreparation {\r\n        return async (rootNode, accept, categories, cancelToken) => {\r\n            await this.handleException(() => check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);\r\n        };\r\n    }\r\n\r\n    get checksBefore(): ValidationPreparation[] {\r\n        return this.entriesBefore;\r\n    }\r\n\r\n    get checksAfter(): ValidationPreparation[] {\r\n        return this.entriesAfter;\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6555, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/validation/document-validator.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/validation/document-validator.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { MismatchedTokenException } from 'chevrotain';\r\nimport type { DiagnosticSeverity, Position, Range, Diagnostic } from 'vscode-languageserver-types';\r\nimport type { LanguageMetaData } from '../languages/language-meta-data.js';\r\nimport type { ParseResult } from '../parser/langium-parser.js';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, CstNode } from '../syntax-tree.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport type { DiagnosticData, DiagnosticInfo, ValidationAcceptor, ValidationCategory, ValidationRegistry, ValidationSeverity } from './validation-registry.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { findNodeForKeyword, findNodeForProperty } from '../utils/grammar-utils.js';\r\nimport { streamAst } from '../utils/ast-utils.js';\r\nimport { tokenToRange } from '../utils/cst-utils.js';\r\nimport { interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\r\nimport { diagnosticData } from './validation-registry.js';\r\nimport type { LexingDiagnostic, LexingDiagnosticSeverity } from '../parser/token-builder.js';\r\n\r\nexport interface ValidationOptions {\r\n    /**\r\n     * If this is set, only the checks associated with these categories are executed; otherwise\r\n     * all checks are executed. The default category if not specified to the registry is `'fast'`.\r\n     */\r\n    categories?: ValidationCategory[];\r\n    /** If true, no further diagnostics are reported if there are lexing errors. */\r\n    stopAfterLexingErrors?: boolean\r\n    /** If true, no further diagnostics are reported if there are parsing errors. */\r\n    stopAfterParsingErrors?: boolean\r\n    /** If true, no further diagnostics are reported if there are linking errors. */\r\n    stopAfterLinkingErrors?: boolean\r\n}\r\n\r\n/**\r\n * Language-specific service for validating `LangiumDocument`s.\r\n */\r\nexport interface DocumentValidator {\r\n    /**\r\n     * Validates the whole specified document.\r\n     *\r\n     * @param document specified document to validate\r\n     * @param options options to control the validation process\r\n     * @param cancelToken allows to cancel the current operation\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    validateDocument(document: LangiumDocument, options?: ValidationOptions, cancelToken?: CancellationToken): Promise<Diagnostic[]>;\r\n}\r\n\r\nexport class DefaultDocumentValidator implements DocumentValidator {\r\n\r\n    protected readonly validationRegistry: ValidationRegistry;\r\n    protected readonly metadata: LanguageMetaData;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.validationRegistry = services.validation.ValidationRegistry;\r\n        this.metadata = services.LanguageMetaData;\r\n    }\r\n\r\n    async validateDocument(document: LangiumDocument, options: ValidationOptions = {}, cancelToken = CancellationToken.None): Promise<Diagnostic[]> {\r\n        const parseResult = document.parseResult;\r\n        const diagnostics: Diagnostic[] = [];\r\n\r\n        await interruptAndCheck(cancelToken);\r\n\r\n        if (!options.categories || options.categories.includes('built-in')) {\r\n            this.processLexingErrors(parseResult, diagnostics, options);\r\n            if (options.stopAfterLexingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.LexingError)) {\r\n                return diagnostics;\r\n            }\r\n\r\n            this.processParsingErrors(parseResult, diagnostics, options);\r\n            if (options.stopAfterParsingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.ParsingError)) {\r\n                return diagnostics;\r\n            }\r\n\r\n            this.processLinkingErrors(document, diagnostics, options);\r\n            if (options.stopAfterLinkingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.LinkingError)) {\r\n                return diagnostics;\r\n            }\r\n        }\r\n\r\n        // Process custom validations\r\n        try {\r\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\r\n        } catch (err) {\r\n            if (isOperationCancelled(err)) {\r\n                throw err;\r\n            }\r\n            console.error('An error occurred during validation:', err);\r\n        }\r\n\r\n        await interruptAndCheck(cancelToken);\r\n\r\n        return diagnostics;\r\n    }\r\n\r\n    protected processLexingErrors(parseResult: ParseResult, diagnostics: Diagnostic[], _options: ValidationOptions): void {\r\n        const lexerDiagnostics = [...parseResult.lexerErrors, ...parseResult.lexerReport?.diagnostics ?? []] as LexingDiagnostic[];\r\n        for (const lexerDiagnostic of lexerDiagnostics) {\r\n            const severity = lexerDiagnostic.severity ?? 'error';\r\n            const diagnostic: Diagnostic = {\r\n                severity: toDiagnosticSeverity(severity),\r\n                range: {\r\n                    start: {\r\n                        line: lexerDiagnostic.line! - 1,\r\n                        character: lexerDiagnostic.column! - 1\r\n                    },\r\n                    end: {\r\n                        line: lexerDiagnostic.line! - 1,\r\n                        character: lexerDiagnostic.column! + lexerDiagnostic.length - 1\r\n                    }\r\n                },\r\n                message: lexerDiagnostic.message,\r\n                data: toDiagnosticData(severity),\r\n                source: this.getSource()\r\n            };\r\n            diagnostics.push(diagnostic);\r\n        }\r\n    }\r\n\r\n    protected processParsingErrors(parseResult: ParseResult, diagnostics: Diagnostic[], _options: ValidationOptions): void {\r\n        for (const parserError of parseResult.parserErrors) {\r\n            let range: Range | undefined = undefined;\r\n            // We can run into the chevrotain error recovery here\r\n            // The token contained in the parser error might be automatically inserted\r\n            // In this case every position value will be `NaN`\r\n            if (isNaN(parserError.token.startOffset)) {\r\n                // Some special parser error types contain a `previousToken`\r\n                // We can simply append our diagnostic to that token\r\n                if ('previousToken' in parserError) {\r\n                    const token = (parserError as MismatchedTokenException).previousToken;\r\n                    if (!isNaN(token.startOffset)) {\r\n                        const position: Position = { line: token.endLine! - 1, character: token.endColumn! };\r\n                        range = { start: position, end: position};\r\n                    } else {\r\n                        // No valid prev token. Might be empty document or containing only hidden tokens.\r\n                        // Point to document start\r\n                        const position: Position = { line: 0, character: 0 };\r\n                        range = { start: position, end: position};\r\n                    }\r\n                }\r\n            } else {\r\n                range = tokenToRange(parserError.token);\r\n            }\r\n            if (range) {\r\n                const diagnostic: Diagnostic = {\r\n                    severity: toDiagnosticSeverity('error'),\r\n                    range,\r\n                    message: parserError.message,\r\n                    data: diagnosticData(DocumentValidator.ParsingError),\r\n                    source: this.getSource()\r\n                };\r\n                diagnostics.push(diagnostic);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected processLinkingErrors(document: LangiumDocument, diagnostics: Diagnostic[], _options: ValidationOptions): void {\r\n        for (const reference of document.references) {\r\n            const linkingError = reference.error;\r\n            if (linkingError) {\r\n                const info: DiagnosticInfo<AstNode, string> = {\r\n                    node: linkingError.container,\r\n                    property: linkingError.property,\r\n                    index: linkingError.index,\r\n                    data: {\r\n                        code: DocumentValidator.LinkingError,\r\n                        containerType: linkingError.container.$type,\r\n                        property: linkingError.property,\r\n                        refText: linkingError.reference.$refText\r\n                    } satisfies LinkingErrorData\r\n                };\r\n                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async validateAst(rootNode: AstNode, options: ValidationOptions, cancelToken = CancellationToken.None): Promise<Diagnostic[]> {\r\n        const validationItems: Diagnostic[] = [];\r\n        const acceptor: ValidationAcceptor = <N extends AstNode>(severity: ValidationSeverity, message: string, info: DiagnosticInfo<N>) => {\r\n            validationItems.push(this.toDiagnostic(severity, message, info));\r\n        };\r\n\r\n        await this.validateAstBefore(rootNode, options, acceptor, cancelToken);\r\n        await this.validateAstNodes(rootNode, options, acceptor, cancelToken);\r\n        await this.validateAstAfter(rootNode, options, acceptor, cancelToken);\r\n\r\n        return validationItems;\r\n    }\r\n\r\n    protected async validateAstBefore(rootNode: AstNode, options: ValidationOptions, acceptor: ValidationAcceptor, cancelToken = CancellationToken.None): Promise<void> {\r\n        const checksBefore = this.validationRegistry.checksBefore;\r\n        for (const checkBefore of checksBefore) {\r\n            await interruptAndCheck(cancelToken);\r\n            await checkBefore(rootNode, acceptor, options.categories ?? [], cancelToken);\r\n        }\r\n    }\r\n\r\n    protected async validateAstNodes(rootNode: AstNode, options: ValidationOptions, acceptor: ValidationAcceptor, cancelToken = CancellationToken.None): Promise<void> {\r\n        await Promise.all(streamAst(rootNode).map(async node => {\r\n            await interruptAndCheck(cancelToken);\r\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\r\n            for (const check of checks) {\r\n                await check(node, acceptor, cancelToken);\r\n            }\r\n        }));\r\n    }\r\n\r\n    protected async validateAstAfter(rootNode: AstNode, options: ValidationOptions, acceptor: ValidationAcceptor, cancelToken = CancellationToken.None): Promise<void> {\r\n        const checksAfter = this.validationRegistry.checksAfter;\r\n        for (const checkAfter of checksAfter) {\r\n            await interruptAndCheck(cancelToken);\r\n            await checkAfter(rootNode, acceptor, options.categories ?? [], cancelToken);\r\n        }\r\n    }\r\n\r\n    protected toDiagnostic<N extends AstNode>(severity: ValidationSeverity, message: string, info: DiagnosticInfo<N, string>): Diagnostic {\r\n        return {\r\n            message,\r\n            range: getDiagnosticRange(info),\r\n            severity: toDiagnosticSeverity(severity),\r\n            code: info.code,\r\n            codeDescription: info.codeDescription,\r\n            tags: info.tags,\r\n            relatedInformation: info.relatedInformation,\r\n            data: info.data,\r\n            source: this.getSource()\r\n        };\r\n    }\r\n\r\n    protected getSource(): string | undefined {\r\n        return this.metadata.languageId;\r\n    }\r\n}\r\n\r\nexport function getDiagnosticRange<N extends AstNode>(info: DiagnosticInfo<N, string>): Range {\r\n    if (info.range) {\r\n        return info.range;\r\n    }\r\n    let cstNode: CstNode | undefined;\r\n    if (typeof info.property === 'string') {\r\n        cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\r\n    } else if (typeof info.keyword === 'string') {\r\n        cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\r\n    }\r\n    cstNode ??= info.node.$cstNode;\r\n    if (!cstNode) {\r\n        return {\r\n            start: { line: 0, character: 0 },\r\n            end: { line: 0, character: 0 }\r\n        };\r\n    }\r\n    return cstNode.range;\r\n}\r\n\r\n/**\r\n * Transforms the diagnostic severity from the {@link LexingDiagnosticSeverity} format to LSP's `DiagnosticSeverity` format.\r\n *\r\n * @param severity The lexing diagnostic severity\r\n * @returns Diagnostic severity according to `vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity`\r\n */\r\nexport function toDiagnosticSeverity(severity: LexingDiagnosticSeverity): DiagnosticSeverity {\r\n    switch (severity) {\r\n        case 'error':\r\n            return 1 satisfies typeof DiagnosticSeverity.Error;\r\n        case 'warning':\r\n            return 2 satisfies typeof DiagnosticSeverity.Warning;\r\n        case 'info':\r\n            return 3 satisfies typeof DiagnosticSeverity.Information;\r\n        case 'hint':\r\n            return 4 satisfies typeof DiagnosticSeverity.Hint;\r\n        default:\r\n            throw new Error('Invalid diagnostic severity: ' + severity);\r\n    }\r\n}\r\n\r\nexport function toDiagnosticData(severity: LexingDiagnosticSeverity): DiagnosticData {\r\n    switch (severity) {\r\n        case 'error':\r\n            return diagnosticData(DocumentValidator.LexingError);\r\n        case 'warning':\r\n            return diagnosticData(DocumentValidator.LexingWarning);\r\n        case 'info':\r\n            return diagnosticData(DocumentValidator.LexingInfo);\r\n        case 'hint':\r\n            return diagnosticData(DocumentValidator.LexingHint);\r\n        default:\r\n            throw new Error('Invalid diagnostic severity: ' + severity);\r\n    }\r\n}\r\n\r\nexport namespace DocumentValidator {\r\n    export const LexingError = 'lexing-error';\r\n    export const LexingWarning = 'lexing-warning';\r\n    export const LexingInfo = 'lexing-info';\r\n    export const LexingHint = 'lexing-hint';\r\n    export const ParsingError = 'parsing-error';\r\n    export const LinkingError = 'linking-error';\r\n}\r\n\r\nexport interface LinkingErrorData extends DiagnosticData {\r\n    containerType: string\r\n    property: string\r\n    refText: string\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6839, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/ast-descriptions.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/ast-descriptions.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { URI } from '../utils/uri-utils.js';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { AstNodeLocator } from './ast-node-locator.js';\r\nimport type { DocumentSegment, LangiumDocument } from './documents.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { isLinkingError } from '../syntax-tree.js';\r\nimport { getDocument, streamAst, streamReferences } from '../utils/ast-utils.js';\r\nimport { toDocumentSegment } from '../utils/cst-utils.js';\r\nimport { interruptAndCheck } from '../utils/promise-utils.js';\r\nimport { UriUtils } from '../utils/uri-utils.js';\r\n\r\n/**\r\n * Language-specific service for creating descriptions of AST nodes to be used for cross-reference resolutions.\r\n */\r\nexport interface AstNodeDescriptionProvider {\r\n\r\n    /**\r\n     * Create a description for the given AST node. This service method is typically used while indexing\r\n     * the contents of a document and during scope computation.\r\n     *\r\n     * @param node An AST node.\r\n     * @param name The name to be used to refer to the AST node. By default, this is determined by the\r\n     *     `NameProvider` service, but alternative names may be provided according to the semantics\r\n     *     of your language.\r\n     * @param document The document containing the AST node. If omitted, it is taken from the root AST node.\r\n     */\r\n    createDescription(node: AstNode, name: string | undefined, document?: LangiumDocument): AstNodeDescription;\r\n\r\n}\r\n\r\nexport class DefaultAstNodeDescriptionProvider implements AstNodeDescriptionProvider {\r\n\r\n    protected readonly astNodeLocator: AstNodeLocator;\r\n    protected readonly nameProvider: NameProvider;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.astNodeLocator = services.workspace.AstNodeLocator;\r\n        this.nameProvider = services.references.NameProvider;\r\n    }\r\n\r\n    createDescription(node: AstNode, name: string | undefined, document?: LangiumDocument): AstNodeDescription {\r\n        const doc = document ?? getDocument(node);\r\n        name ??= this.nameProvider.getName(node);\r\n        const path = this.astNodeLocator.getAstNodePath(node);\r\n        if (!name) {\r\n            throw new Error(`Node at path ${path} has no name.`);\r\n        }\r\n        let nameNodeSegment: DocumentSegment | undefined;\r\n        const nameSegmentGetter = () => nameNodeSegment ??= toDocumentSegment(this.nameProvider.getNameNode(node) ?? node.$cstNode);\r\n        return {\r\n            node,\r\n            name,\r\n            get nameSegment() {\r\n                return nameSegmentGetter();\r\n            },\r\n            selectionSegment: toDocumentSegment(node.$cstNode),\r\n            type: node.$type,\r\n            documentUri: doc.uri,\r\n            path\r\n        };\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Describes a cross-reference within a document or between two documents.\r\n */\r\nexport interface ReferenceDescription {\r\n    /** URI of the document that holds a reference */\r\n    sourceUri: URI\r\n    /** Path to AstNode that holds a reference */\r\n    sourcePath: string\r\n    /** Target document uri */\r\n    targetUri: URI\r\n    /** Path to the target AstNode inside the document */\r\n    targetPath: string\r\n    /** Segment of the reference text. */\r\n    segment: DocumentSegment\r\n    /** Marks a local reference i.e. a cross reference inside a document.   */\r\n    local?: boolean\r\n}\r\n\r\n/**\r\n * Language-specific service to create descriptions of all cross-references in a document. These are used by the `IndexManager`\r\n * to determine which documents are affected and should be rebuilt when a document is changed.\r\n */\r\nexport interface ReferenceDescriptionProvider {\r\n    /**\r\n     * Create descriptions of all cross-references found in the given document. These descriptions are\r\n     * gathered by the `IndexManager` and stored in the global index so they can be considered when\r\n     * a document change is reported by the client.\r\n     *\r\n     * @param document The document in which to gather cross-references.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    createDescriptions(document: LangiumDocument, cancelToken?: CancellationToken): Promise<ReferenceDescription[]>;\r\n}\r\n\r\nexport class DefaultReferenceDescriptionProvider implements ReferenceDescriptionProvider {\r\n\r\n    protected readonly nodeLocator: AstNodeLocator;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.nodeLocator = services.workspace.AstNodeLocator;\r\n    }\r\n\r\n    async createDescriptions(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<ReferenceDescription[]> {\r\n        const descr: ReferenceDescription[] = [];\r\n        const rootNode = document.parseResult.value;\r\n        for (const astNode of streamAst(rootNode)) {\r\n            await interruptAndCheck(cancelToken);\r\n            streamReferences(astNode).filter(refInfo => !isLinkingError(refInfo)).forEach(refInfo => {\r\n                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked\r\n                const description = this.createDescription(refInfo);\r\n                if (description) {\r\n                    descr.push(description);\r\n                }\r\n            });\r\n        }\r\n        return descr;\r\n    }\r\n\r\n    protected createDescription(refInfo: ReferenceInfo): ReferenceDescription | undefined {\r\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\r\n        const refCstNode = refInfo.reference.$refNode;\r\n        if (!targetNodeDescr || !refCstNode) {\r\n            return undefined;\r\n        }\r\n        const docUri = getDocument(refInfo.container).uri;\r\n        return {\r\n            sourceUri: docUri,\r\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\r\n            targetUri: targetNodeDescr.documentUri,\r\n            targetPath: targetNodeDescr.path,\r\n            segment: toDocumentSegment(refCstNode),\r\n            local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\r\n        };\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6931, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/ast-node-locator.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/ast-node-locator.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode } from '../syntax-tree.js';\r\n\r\n/**\r\n * Language-specific service for locating an `AstNode` in a document.\r\n */\r\nexport interface AstNodeLocator {\r\n\r\n    /**\r\n     * Creates a path represented by a `string` that identifies an `AstNode` inside its document.\r\n     * It must be possible to retrieve exactly the same `AstNode` from the document using this path.\r\n     *\r\n     * @param node The `AstNode` for which to create the path.\r\n     * @returns a path represented by a `string` that identifies `node` inside its document.\r\n     * @see AstNodeLocator.getAstNode\r\n     */\r\n    getAstNodePath(node: AstNode): string;\r\n\r\n    /**\r\n     * Locates an `AstNode` inside another node by following the given path.\r\n     *\r\n     * @param node Parent element.\r\n     * @param path Describes how to locate the `AstNode` inside the given `node`.\r\n     * @returns The `AstNode` located under the given path, or `undefined` if the path cannot be resolved.\r\n     * @see AstNodeLocator.getAstNodePath\r\n     */\r\n    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined;\r\n\r\n}\r\n\r\nexport class DefaultAstNodeLocator implements AstNodeLocator {\r\n    protected segmentSeparator = '/';\r\n    protected indexSeparator = '@';\r\n\r\n    getAstNodePath(node: AstNode): string {\r\n        if (node.$container) {\r\n            const containerPath = this.getAstNodePath(node.$container);\r\n            const newSegment = this.getPathSegment(node);\r\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\r\n            return nodePath;\r\n        }\r\n        return '';\r\n    }\r\n\r\n    protected getPathSegment({ $containerProperty, $containerIndex }: AstNode): string {\r\n        if (!$containerProperty) {\r\n            throw new Error(\"Missing '$containerProperty' in AST node.\");\r\n        }\r\n        if ($containerIndex !== undefined) {\r\n            return $containerProperty + this.indexSeparator + $containerIndex;\r\n        }\r\n        return $containerProperty;\r\n    }\r\n\r\n    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined {\r\n        const segments = path.split(this.segmentSeparator);\r\n        return segments.reduce((previousValue, currentValue) => {\r\n            if (!previousValue || currentValue.length === 0) {\r\n                return previousValue;\r\n            }\r\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\r\n            if (propertyIndex > 0) {\r\n                const property = currentValue.substring(0, propertyIndex);\r\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\r\n                const array = (previousValue as unknown as Record<string, AstNode[]>)[property];\r\n                return array?.[arrayIndex];\r\n            }\r\n            return (previousValue as unknown as Record<string, AstNode>)[currentValue];\r\n        }, node) as T;\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AA+B1E,MAAO,qBAAqB;IAAlC,aAAA;QACc,IAAA,CAAA,gBAAgB,GAAG,GAAG,CAAC;QACvB,IAAA,CAAA,cAAc,GAAG,GAAG,CAAC;IAuCnC,CAAC;IArCG,cAAc,CAAC,IAAa,EAAA;QACxB,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YAClB,MAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC3D,MAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YAC7C,MAAM,QAAQ,GAAG,aAAa,GAAG,IAAI,CAAC,gBAAgB,GAAG,UAAU,CAAC;YACpE,OAAO,QAAQ,CAAC;QACpB,CAAC;QACD,OAAO,EAAE,CAAC;IACd,CAAC;IAES,cAAc,CAAC,EAAE,kBAAkB,EAAE,eAAe,EAAW,EAAA;QACrE,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACtB,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;QACjE,CAAC;QACD,IAAI,eAAe,KAAK,SAAS,EAAE,CAAC;YAChC,OAAO,kBAAkB,GAAG,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC;QACtE,CAAC;QACD,OAAO,kBAAkB,CAAC;IAC9B,CAAC;IAED,UAAU,CAA8B,IAAa,EAAE,IAAY,EAAA;QAC/D,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACnD,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,aAAa,EAAE,YAAY,EAAE,EAAE;YACnD,IAAI,CAAC,aAAa,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC9C,OAAO,aAAa,CAAC;YACzB,CAAC;YACD,MAAM,aAAa,GAAG,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YAChE,IAAI,aAAa,GAAG,CAAC,EAAE,CAAC;gBACpB,MAAM,QAAQ,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;gBAC1D,MAAM,UAAU,GAAG,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;gBACvE,MAAM,KAAK,GAAI,aAAsD,CAAC,QAAQ,CAAC,CAAC;gBAChF,OAAO,KAAK,KAAA,QAAL,KAAK,KAAA,KAAA,IAAA,KAAA,IAAL,KAAK,CAAG,UAAU,CAAC,CAAC;YAC/B,CAAC;YACD,OAAQ,aAAoD,CAAC,YAAY,CAAC,CAAC;QAC/E,CAAC,EAAE,IAAI,CAAM,CAAC;IAClB,CAAC;CAEJ"}},
    {"offset": {"line": 6983, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/configuration.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/configuration.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { Emitter } from '../utils/event.js';\r\nimport type {\r\n    ConfigurationItem,\r\n    DidChangeConfigurationParams,\r\n    DidChangeConfigurationRegistrationOptions,\r\n    Disposable,\r\n    Event,\r\n    InitializeParams,\r\n    InitializedParams\r\n} from 'vscode-languageserver-protocol';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedCoreServices } from '../services.js';\r\nimport { Deferred } from '../utils/promise-utils.js';\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nexport interface ConfigurationProvider {\r\n\r\n    /**\r\n     * A promise that resolves when the configuration provider is ready to be used.\r\n     */\r\n    readonly ready: Promise<void>;\r\n\r\n    /**\r\n     * When used in a language server context, this method is called when the server receives\r\n     * the `initialize` request.\r\n     */\r\n    initialize(params: InitializeParams): void;\r\n\r\n    /**\r\n     * When used in a language server context, this method is called when the server receives\r\n     * the `initialized` notification.\r\n     */\r\n    initialized(params: ConfigurationInitializedParams): Promise<void>;\r\n\r\n    /**\r\n     * Returns a configuration value stored for the given language.\r\n     *\r\n     * @param language The language id\r\n     * @param configuration Configuration name\r\n     */\r\n    getConfiguration(language: string, configuration: string): Promise<any>;\r\n\r\n    /**\r\n     *  Updates the cached configurations using the `change` notification parameters.\r\n     *\r\n     * @param change The parameters of a change configuration notification.\r\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\r\n     */\r\n    updateConfiguration(change: DidChangeConfigurationParams): void;\r\n\r\n    /**\r\n     * Get notified after a configuration section has been updated.\r\n     */\r\n    onConfigurationSectionUpdate(callback: ConfigurationSectionUpdateListener): Disposable\r\n}\r\n\r\nexport interface ConfigurationInitializedParams extends InitializedParams {\r\n    register?: (params: DidChangeConfigurationRegistrationOptions) => void,\r\n    fetchConfiguration?: (configuration: ConfigurationItem[]) => Promise<any>\r\n}\r\n\r\nexport interface ConfigurationSectionUpdate {\r\n    /**\r\n     * The name of the configuration section that has been updated.\r\n     */\r\n    section: string;\r\n\r\n    /**\r\n     * The updated configuration section.\r\n     */\r\n    configuration: any;\r\n}\r\n\r\nexport type ConfigurationSectionUpdateListener = (update: ConfigurationSectionUpdate) => void;\r\n\r\n/**\r\n * Base configuration provider for building up other configuration providers\r\n */\r\nexport class DefaultConfigurationProvider implements ConfigurationProvider {\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly _ready = new Deferred<void>();\r\n    protected settings: Record<string, Record<string, any>> = {};\r\n    protected workspaceConfig = false;\r\n    protected onConfigurationSectionUpdateEmitter = new Emitter<ConfigurationSectionUpdate>();\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n    }\r\n\r\n    get ready(): Promise<void> {\r\n        return this._ready.promise;\r\n    }\r\n\r\n    initialize(params: InitializeParams): void {\r\n        this.workspaceConfig = params.capabilities.workspace?.configuration ?? false;\r\n    }\r\n\r\n    async initialized(params: ConfigurationInitializedParams): Promise<void> {\r\n        if (this.workspaceConfig) {\r\n            if (params.register) {\r\n                // params.register(...) is a function to be provided by the calling language server for the sake of\r\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\r\n\r\n                const languages = this.serviceRegistry.all;\r\n                params.register({\r\n                    // Listen to configuration changes for all languages\r\n                    section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))\r\n                });\r\n            }\r\n\r\n            if (params.fetchConfiguration) {\r\n                // params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of\r\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\r\n                const configToUpdate = this.serviceRegistry.all.map(lang => <ConfigurationItem>{\r\n                    // Fetch the configuration changes for all languages\r\n                    section: this.toSectionName(lang.LanguageMetaData.languageId)\r\n                });\r\n\r\n                // get workspace configurations (default scope URI)\r\n                const configs = await params.fetchConfiguration(configToUpdate);\r\n                configToUpdate.forEach((conf, idx) => {\r\n                    this.updateSectionConfiguration(conf.section!, configs[idx]);\r\n                });\r\n            }\r\n        }\r\n        this._ready.resolve();\r\n    }\r\n\r\n    /**\r\n     *  Updates the cached configurations using the `change` notification parameters.\r\n     *\r\n     * @param change The parameters of a change configuration notification.\r\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\r\n     */\r\n    updateConfiguration(change: DidChangeConfigurationParams): void {\r\n        if (!change.settings) {\r\n            return;\r\n        }\r\n        Object.keys(change.settings).forEach(section => {\r\n            const configuration = change.settings[section];\r\n            this.updateSectionConfiguration(section, configuration);\r\n            this.onConfigurationSectionUpdateEmitter.fire({ section, configuration });\r\n        });\r\n    }\r\n\r\n    protected updateSectionConfiguration(section: string, configuration: any): void {\r\n        this.settings[section] = configuration;\r\n    }\r\n\r\n    /**\r\n    * Returns a configuration value stored for the given language.\r\n    *\r\n    * @param language The language id\r\n    * @param configuration Configuration name\r\n    */\r\n    async getConfiguration(language: string, configuration: string): Promise<any> {\r\n        await this.ready;\r\n\r\n        const sectionName = this.toSectionName(language);\r\n        if (this.settings[sectionName]) {\r\n            return this.settings[sectionName][configuration];\r\n        }\r\n    }\r\n\r\n    protected toSectionName(languageId: string): string {\r\n        return `${languageId}`;\r\n    }\r\n\r\n    get onConfigurationSectionUpdate(): Event<ConfigurationSectionUpdate> {\r\n        return this.onConfigurationSectionUpdateEmitter.event;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7081, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/disposable.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/disposable.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nexport interface Disposable {\r\n    /**\r\n     * Dispose this object.\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\nexport interface AsyncDisposable {\r\n    /**\r\n     * Dispose this object.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport namespace Disposable {\r\n    export function create(callback: () => Promise<void>): AsyncDisposable;\r\n    export function create(callback: () => void): Disposable;\r\n    export function create(callback: () => void | Promise<void>): Disposable | AsyncDisposable {\r\n        return {\r\n            dispose: async () => await callback()\r\n        };\r\n    }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAgB1E,IAAW,UAAU,CAQ1B;AARD,CAAA,SAAiB,UAAU;IAGvB,SAAgB,MAAM,CAAC,QAAoC;QACvD,OAAO;YACH,OAAO,EAAE,KAAK,IAAI,CAAG,CAAD,KAAO,QAAQ,EAAE;SACxC,CAAC;IACN,CAAC;IAJe,WAAA,MAAM,GAAA,MAIrB,CAAA;AACL,CAAC,EARgB,UAAU,IAAA,CAAV,UAAU,GAAA,CAAA,CAAA,GAQ1B"}},
    {"offset": {"line": 7102, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/document-builder.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/document-builder.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { Disposable } from '../utils/disposable.js';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedCoreServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-utils.js';\r\nimport type { Deferred } from '../utils/promise-utils.js';\r\nimport type { ValidationOptions } from '../validation/document-validator.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { LangiumDocument, LangiumDocuments, LangiumDocumentFactory, TextDocumentProvider } from './documents.js';\r\nimport { MultiMap } from '../utils/collections.js';\r\nimport { OperationCancelled, interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport type { URI } from '../utils/uri-utils.js';\r\nimport { ValidationCategory } from '../validation/validation-registry.js';\r\nimport { DocumentState } from './documents.js';\r\n\r\nexport interface BuildOptions {\r\n    /**\r\n     * Control the validation phase with this option:\r\n     *  - `true` enables all validation checks and forces revalidating the documents\r\n     *  - `false` or `undefined` disables all validation checks\r\n     *  - An object runs only the necessary validation checks; the `categories` property restricts this to a specific subset\r\n     */\r\n    validation?: boolean | ValidationOptions\r\n}\r\n\r\nexport interface DocumentBuildState {\r\n    /** Whether a document has completed its last build process. */\r\n    completed: boolean\r\n    /** The options used for the last build process. */\r\n    options: BuildOptions\r\n    /** Additional information about the last build result. */\r\n    result?: {\r\n        validationChecks?: ValidationCategory[]\r\n    }\r\n}\r\n\r\n/**\r\n * Shared-service for building and updating `LangiumDocument`s.\r\n */\r\nexport interface DocumentBuilder {\r\n\r\n    /** The options used for rebuilding documents after an update. */\r\n    updateBuildOptions: BuildOptions;\r\n\r\n    /**\r\n     * Execute all necessary build steps for the given documents.\r\n     *\r\n     * @param documents Set of documents to be built.\r\n     * @param options Options for the document builder.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options?: BuildOptions, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * This method is called when a document change is detected. It updates the state of all\r\n     * affected documents, including those with references to the changed ones, so they are rebuilt.\r\n     *\r\n     * @param changed URIs of changed or created documents\r\n     * @param deleted URIs of deleted documents\r\n     * @param cancelToken allows to cancel the current operation\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     */\r\n    update(changed: URI[], deleted: URI[], cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Notify the given callback when a document update was triggered, but before any document\r\n     * is rebuilt. Listeners to this event should not perform any long-running task.\r\n     */\r\n    onUpdate(callback: DocumentUpdateListener): Disposable;\r\n\r\n    /**\r\n     * Notify the given callback when a set of documents has been built reaching the specified target state.\r\n     */\r\n    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable;\r\n\r\n    /**\r\n     * Notify the specified callback when a document has been built reaching the specified target state.\r\n     * Unlike {@link onBuildPhase} the listener is called for every single document.\r\n     *\r\n     * There are two main advantages compared to {@link onBuildPhase}:\r\n     * 1. If the build is cancelled, {@link onDocumentPhase} will still fire for documents that have reached a specific state.\r\n     *    Meanwhile, {@link onBuildPhase} won't fire for that state.\r\n     * 2. The {@link DocumentBuilder} ensures that all {@link DocumentPhaseListener} instances are called for a built document.\r\n     *    Even if the build is cancelled before those listeners were called.\r\n     */\r\n    onDocumentPhase(targetState: DocumentState, callback: DocumentPhaseListener): Disposable;\r\n\r\n    /**\r\n     * Wait until the workspace has reached the specified state for all documents.\r\n     *\r\n     * @param state The desired state. The promise won't resolve until all documents have reached this state\r\n     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process\r\n     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached\r\n     */\r\n    waitUntil(state: DocumentState, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Wait until the document specified by the {@link uri} has reached the specified state.\r\n     *\r\n     * @param state The desired state. The promise won't resolve until the document has reached this state.\r\n     * @param uri The specified URI that points to the document. If the URI does not exist, the promise will resolve once the workspace has reached the specified state.\r\n     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process.\r\n     * @return The URI of the document that has reached the desired state, or `undefined` if the document does not exist.\r\n     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached\r\n     */\r\n    waitUntil(state: DocumentState, uri?: URI, cancelToken?: CancellationToken): Promise<URI | undefined>;\r\n}\r\n\r\nexport type DocumentUpdateListener = (changed: URI[], deleted: URI[]) => void | Promise<void>\r\nexport type DocumentBuildListener = (built: LangiumDocument[], cancelToken: CancellationToken) => void | Promise<void>\r\nexport type DocumentPhaseListener = (built: LangiumDocument, cancelToken: CancellationToken) => void | Promise<void>\r\nexport class DefaultDocumentBuilder implements DocumentBuilder {\r\n\r\n    updateBuildOptions: BuildOptions = {\r\n        // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\r\n        validation: {\r\n            categories: ['built-in', 'fast']\r\n        }\r\n    };\r\n\r\n    protected readonly langiumDocuments: LangiumDocuments;\r\n    protected readonly langiumDocumentFactory: LangiumDocumentFactory;\r\n    protected readonly textDocuments: TextDocumentProvider | undefined;\r\n    protected readonly indexManager: IndexManager;\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly updateListeners: DocumentUpdateListener[] = [];\r\n    protected readonly buildPhaseListeners = new MultiMap<DocumentState, DocumentBuildListener>();\r\n    protected readonly documentPhaseListeners = new MultiMap<DocumentState, DocumentPhaseListener>();\r\n    protected readonly buildState = new Map<string, DocumentBuildState>();\r\n    protected readonly documentBuildWaiters = new Map<string, Deferred<void>>();\r\n    protected currentState = DocumentState.Changed;\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.langiumDocuments = services.workspace.LangiumDocuments;\r\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\r\n        this.textDocuments = services.workspace.TextDocuments;\r\n        this.indexManager = services.workspace.IndexManager;\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n    }\r\n\r\n    async build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options: BuildOptions = {}, cancelToken = CancellationToken.None): Promise<void> {\r\n        for (const document of documents) {\r\n            const key = document.uri.toString();\r\n            if (document.state === DocumentState.Validated) {\r\n                if (typeof options.validation === 'boolean' && options.validation) {\r\n                    // Force re-running all validation checks\r\n                    document.state = DocumentState.IndexedReferences;\r\n                    document.diagnostics = undefined;\r\n                    this.buildState.delete(key);\r\n                } else if (typeof options.validation === 'object') {\r\n                    const buildState = this.buildState.get(key);\r\n                    const previousCategories = buildState?.result?.validationChecks;\r\n                    if (previousCategories) {\r\n                        // Validation with explicit options was requested for a document that has already been partly validated.\r\n                        // In this case, we need to merge the previous validation categories with the new ones.\r\n                        const newCategories = options.validation.categories ?? ValidationCategory.all as ValidationCategory[];\r\n                        const categories = newCategories.filter(c => !previousCategories.includes(c));\r\n                        if (categories.length > 0) {\r\n                            this.buildState.set(key, {\r\n                                completed: false,\r\n                                options: {\r\n                                    validation: {\r\n                                        ...options.validation,\r\n                                        categories\r\n                                    }\r\n                                },\r\n                                result: buildState.result\r\n                            });\r\n                            document.state = DocumentState.IndexedReferences;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Default: forget any previous build options\r\n                this.buildState.delete(key);\r\n            }\r\n        }\r\n        this.currentState = DocumentState.Changed;\r\n        await this.emitUpdate(documents.map(e => e.uri), []);\r\n        await this.buildDocuments(documents, options, cancelToken);\r\n    }\r\n\r\n    async update(changed: URI[], deleted: URI[], cancelToken = CancellationToken.None): Promise<void> {\r\n        this.currentState = DocumentState.Changed;\r\n        // Remove all metadata of documents that are reported as deleted\r\n        for (const deletedUri of deleted) {\r\n            this.langiumDocuments.deleteDocument(deletedUri);\r\n            this.buildState.delete(deletedUri.toString());\r\n            this.indexManager.remove(deletedUri);\r\n        }\r\n        // Set the state of all changed documents to `Changed` so they are completely rebuilt\r\n        for (const changedUri of changed) {\r\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\r\n            if (!invalidated) {\r\n                // We create an unparsed, invalid document.\r\n                // This will be parsed as soon as we reach the first document builder phase.\r\n                // This allows to cancel the parsing process later in case we need it.\r\n                const newDocument = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, changedUri);\r\n                newDocument.state = DocumentState.Changed;\r\n                this.langiumDocuments.addDocument(newDocument);\r\n            }\r\n            this.buildState.delete(changedUri.toString());\r\n        }\r\n        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)\r\n        const allChangedUris = stream(changed).concat(deleted).map(uri => uri.toString()).toSet();\r\n        this.langiumDocuments.all\r\n            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))\r\n            .forEach(doc => {\r\n                const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\r\n                linker.unlink(doc);\r\n                doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\r\n                doc.diagnostics = undefined;\r\n            });\r\n        // Notify listeners of the update\r\n        await this.emitUpdate(changed, deleted);\r\n        // Only allow interrupting the execution after all state changes are done\r\n        await interruptAndCheck(cancelToken);\r\n\r\n        // Collect and sort all documents that we should rebuild\r\n        const rebuildDocuments = this.sortDocuments(\r\n            this.langiumDocuments.all\r\n                .filter(doc =>\r\n                    // This includes those that were reported as changed and those that we selected for relinking\r\n                    doc.state < DocumentState.Linked\r\n                    // This includes those for which a previous build has been cancelled\r\n                    || !this.buildState.get(doc.uri.toString())?.completed\r\n                )\r\n                .toArray()\r\n        );\r\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\r\n    }\r\n\r\n    protected async emitUpdate(changed: URI[], deleted: URI[]): Promise<void> {\r\n        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));\r\n    }\r\n\r\n    /**\r\n     * Sort the given documents by priority. By default, documents with an open text document are prioritized.\r\n     * This is useful to ensure that visible documents show their diagnostics before all other documents.\r\n     *\r\n     * This improves the responsiveness in large workspaces as users usually don't care about diagnostics\r\n     * in files that are currently not opened in the editor.\r\n     */\r\n    protected sortDocuments(documents: LangiumDocument[]): LangiumDocument[] {\r\n        let left = 0;\r\n        let right = documents.length - 1;\r\n\r\n        while (left < right) {\r\n            while (left < documents.length && this.hasTextDocument(documents[left])) {\r\n                left++;\r\n            }\r\n\r\n            while (right >= 0 && !this.hasTextDocument(documents[right])) {\r\n                right--;\r\n            }\r\n\r\n            if (left < right) {\r\n                [documents[left], documents[right]] = [documents[right], documents[left]];\r\n            }\r\n        }\r\n\r\n        return documents;\r\n    }\r\n\r\n    private hasTextDocument(doc: LangiumDocument): boolean {\r\n        return Boolean(this.textDocuments?.get(doc.uri));\r\n    }\r\n\r\n    /**\r\n     * Check whether the given document should be relinked after changes were found in the given URIs.\r\n     */\r\n    protected shouldRelink(document: LangiumDocument, changedUris: Set<string>): boolean {\r\n        // Relink documents with linking errors -- maybe those references can be resolved now\r\n        if (document.references.some(ref => ref.error !== undefined)) {\r\n            return true;\r\n        }\r\n        // Check whether the document is affected by any of the changed URIs\r\n        return this.indexManager.isAffected(document, changedUris);\r\n    }\r\n\r\n    onUpdate(callback: DocumentUpdateListener): Disposable {\r\n        this.updateListeners.push(callback);\r\n        return Disposable.create(() => {\r\n            const index = this.updateListeners.indexOf(callback);\r\n            if (index >= 0) {\r\n                this.updateListeners.splice(index, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Build the given documents by stepping through all build phases. If a document's state indicates\r\n     * that a certain build phase is already done, the phase is skipped for that document.\r\n     *\r\n     * @param documents The documents to build.\r\n     * @param options the {@link BuildOptions} to use.\r\n     * @param cancelToken A cancellation token that can be used to cancel the build.\r\n     * @returns A promise that resolves when the build is done.\r\n     */\r\n    protected async buildDocuments(documents: LangiumDocument[], options: BuildOptions, cancelToken: CancellationToken): Promise<void> {\r\n        this.prepareBuild(documents, options);\r\n        // 0. Parse content\r\n        await this.runCancelable(documents, DocumentState.Parsed, cancelToken, doc =>\r\n            this.langiumDocumentFactory.update(doc, cancelToken)\r\n        );\r\n        // 1. Index content\r\n        await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, doc =>\r\n            this.indexManager.updateContent(doc, cancelToken)\r\n        );\r\n        // 2. Compute scopes\r\n        await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async doc => {\r\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\r\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\r\n        });\r\n        // 3. Linking\r\n        await this.runCancelable(documents, DocumentState.Linked, cancelToken, doc => {\r\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\r\n            return linker.link(doc, cancelToken);\r\n        });\r\n        // 4. Index references\r\n        await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, doc =>\r\n            this.indexManager.updateReferences(doc, cancelToken)\r\n        );\r\n        // 5. Validation\r\n        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));\r\n        await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, doc =>\r\n            this.validate(doc, cancelToken)\r\n        );\r\n\r\n        // If we've made it to this point without being cancelled, we can mark the build state as completed.\r\n        for (const doc of documents) {\r\n            const state = this.buildState.get(doc.uri.toString());\r\n            if (state) {\r\n                state.completed = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document\r\n     *\r\n     * @param documents collection of documents to be built\r\n     * @param options the {@link BuildOptions} to use\r\n     */\r\n    protected prepareBuild(documents: LangiumDocument[], options: BuildOptions): void {\r\n        for (const doc of documents) {\r\n            const key = doc.uri.toString();\r\n            const state = this.buildState.get(key);\r\n            // If the document has no previous build state, we set it. If it has one, but it's already marked\r\n            // as completed, we overwrite it. If the previous build was not completed, we keep its state\r\n            // and continue where it was cancelled.\r\n            if (!state || state.completed) {\r\n                this.buildState.set(key, {\r\n                    completed: false,\r\n                    options,\r\n                    result: state?.result\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.\r\n     *\r\n     * @param documents The array of documents to process.\r\n     * @param targetState The target {@link DocumentState} to bring the documents to.\r\n     * @param cancelToken A token that can be used to cancel the operation.\r\n     * @param callback A function to be called for each document.\r\n     * @returns A promise that resolves when all documents have been processed or the operation is canceled.\r\n     * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.\r\n     */\r\n    protected async runCancelable(documents: LangiumDocument[], targetState: DocumentState, cancelToken: CancellationToken,\r\n        callback: (document: LangiumDocument) => MaybePromise<unknown>): Promise<void> {\r\n        const filtered = documents.filter(doc => doc.state < targetState);\r\n        for (const document of filtered) {\r\n            await interruptAndCheck(cancelToken);\r\n            await callback(document);\r\n            document.state = targetState;\r\n            await this.notifyDocumentPhase(document, targetState, cancelToken);\r\n        }\r\n\r\n        // Do not use `filtered` here, as that will miss documents that have previously reached the current target state\r\n        // For example, this happens in case the cancellation triggers between the processing of two documents\r\n        // Or files that were picked up during the workspace initialization\r\n        const targetStateDocs = documents.filter(doc => doc.state === targetState);\r\n        await this.notifyBuildPhase(targetStateDocs, targetState, cancelToken);\r\n        this.currentState = targetState;\r\n    }\r\n\r\n    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable {\r\n        this.buildPhaseListeners.add(targetState, callback);\r\n        return Disposable.create(() => {\r\n            this.buildPhaseListeners.delete(targetState, callback);\r\n        });\r\n    }\r\n\r\n    onDocumentPhase(targetState: DocumentState, callback: DocumentPhaseListener): Disposable {\r\n        this.documentPhaseListeners.add(targetState, callback);\r\n        return Disposable.create(() => {\r\n            this.documentPhaseListeners.delete(targetState, callback);\r\n        });\r\n    }\r\n\r\n    waitUntil(state: DocumentState, cancelToken?: CancellationToken): Promise<void>;\r\n    waitUntil(state: DocumentState, uri?: URI, cancelToken?: CancellationToken): Promise<URI | undefined>;\r\n    waitUntil(state: DocumentState, uriOrToken?: URI | CancellationToken, cancelToken?: CancellationToken): Promise<URI | undefined | void> {\r\n        let uri: URI | undefined = undefined;\r\n        if (uriOrToken && 'path' in uriOrToken) {\r\n            uri = uriOrToken;\r\n        } else {\r\n            cancelToken = uriOrToken;\r\n        }\r\n        cancelToken ??= CancellationToken.None;\r\n        if (uri) {\r\n            const document = this.langiumDocuments.getDocument(uri);\r\n            if (document && document.state > state) {\r\n                return Promise.resolve(uri);\r\n            }\r\n        }\r\n        if (this.currentState >= state) {\r\n            return Promise.resolve(undefined);\r\n        } else if (cancelToken.isCancellationRequested) {\r\n            return Promise.reject(OperationCancelled);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const buildDisposable = this.onBuildPhase(state, () => {\r\n                buildDisposable.dispose();\r\n                cancelDisposable.dispose();\r\n                if (uri) {\r\n                    const document = this.langiumDocuments.getDocument(uri);\r\n                    resolve(document?.uri);\r\n                } else {\r\n                    resolve(undefined);\r\n                }\r\n            });\r\n            const cancelDisposable = cancelToken!.onCancellationRequested(() => {\r\n                buildDisposable.dispose();\r\n                cancelDisposable.dispose();\r\n                reject(OperationCancelled);\r\n            });\r\n        });\r\n    }\r\n\r\n    protected async notifyDocumentPhase(document: LangiumDocument, state: DocumentState, cancelToken: CancellationToken): Promise<void> {\r\n        const listeners = this.documentPhaseListeners.get(state);\r\n        const listenersCopy = listeners.slice();\r\n        for (const listener of listenersCopy) {\r\n            try {\r\n                await listener(document, cancelToken);\r\n            } catch (err) {\r\n                // Ignore cancellation errors\r\n                // We want to finish the listeners before throwing\r\n                if (!isOperationCancelled(err)) {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async notifyBuildPhase(documents: LangiumDocument[], state: DocumentState, cancelToken: CancellationToken): Promise<void> {\r\n        if (documents.length === 0) {\r\n            // Don't notify when no document has been processed\r\n            return;\r\n        }\r\n        const listeners = this.buildPhaseListeners.get(state);\r\n        const listenersCopy = listeners.slice();\r\n        for (const listener of listenersCopy) {\r\n            await interruptAndCheck(cancelToken);\r\n            await listener(documents, cancelToken);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine whether the given document should be validated during a build. The default\r\n     * implementation checks the `validation` property of the build options. If it's set to `true`\r\n     * or a `ValidationOptions` object, the document is included in the validation phase.\r\n     */\r\n    protected shouldValidate(document: LangiumDocument): boolean {\r\n        return Boolean(this.getBuildOptions(document).validation);\r\n    }\r\n\r\n    /**\r\n     * Run validation checks on the given document and store the resulting diagnostics in the document.\r\n     * If the document already contains diagnostics, the new ones are added to the list.\r\n     */\r\n    protected async validate(document: LangiumDocument, cancelToken: CancellationToken): Promise<void> {\r\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\r\n        const validationSetting = this.getBuildOptions(document).validation;\r\n        const options = typeof validationSetting === 'object' ? validationSetting : undefined;\r\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\r\n        if (document.diagnostics) {\r\n            document.diagnostics.push(...diagnostics);\r\n        } else {\r\n            document.diagnostics = diagnostics;\r\n        }\r\n\r\n        // Store information about the executed validation in the build state\r\n        const state = this.buildState.get(document.uri.toString());\r\n        if (state) {\r\n            state.result ??= {};\r\n            const newCategories = options?.categories ?? ValidationCategory.all;\r\n            if (state.result.validationChecks) {\r\n                state.result.validationChecks.push(...newCategories);\r\n            } else {\r\n                state.result.validationChecks = [...newCategories];\r\n            }\r\n        }\r\n    }\r\n\r\n    protected getBuildOptions(document: LangiumDocument): BuildOptions {\r\n        return this.buildState.get(document.uri.toString())?.options ?? {};\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7484, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/index-manager.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/index-manager.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection } from '../syntax-tree.js';\r\nimport { getDocument } from '../utils/ast-utils.js';\r\nimport { ContextCache } from '../utils/caching.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport type { URI } from '../utils/uri-utils.js';\r\nimport { UriUtils } from '../utils/uri-utils.js';\r\nimport type { ReferenceDescription } from './ast-descriptions.js';\r\nimport type { LangiumDocument, LangiumDocuments } from './documents.js';\r\n\r\n/**\r\n * The index manager is responsible for keeping metadata about symbols and cross-references\r\n * in the workspace. It is used to look up symbols in the global scope, mostly during linking\r\n * and completion. This service is shared between all languages of a language server.\r\n */\r\nexport interface IndexManager {\r\n\r\n    /**\r\n     * Removes the specified document URI from the index.\r\n     * Necessary when documents are deleted and not referenceable anymore.\r\n     *\r\n     * @param uri The URI of the document for which index data shall be removed\r\n     */\r\n    remove(uri: URI): void;\r\n\r\n    /**\r\n     * Updates the information about the exportable content of a document inside the index.\r\n     *\r\n     * @param document Document to be updated\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    updateContent(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Updates the information about the cross-references of a document inside the index.\r\n     *\r\n     * @param document Document to be updated\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Determine whether the given document could be affected by changes of the documents\r\n     * identified by the given URIs (second parameter). The document is typically regarded as\r\n     * affected if it contains a reference to any of the changed files.\r\n     *\r\n     * @param document Document to check whether it's affected\r\n     * @param changedUris URIs of the changed documents\r\n     */\r\n    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;\r\n\r\n    /**\r\n     * Compute a list of all exported elements, optionally filtered using a type identifier and document URIs.\r\n     *\r\n     * @param nodeType The type to filter with, or `undefined` to return descriptions of all types.\r\n     * @param uris If specified, only returns elements from the given URIs.\r\n     * @returns a `Stream` containing all globally visible nodes (of a given type).\r\n     */\r\n    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;\r\n\r\n    /**\r\n     * Returns all known references that are pointing to the given `targetNode`.\r\n     *\r\n     * @param targetNode the `AstNode` to look up references for\r\n     * @param astNodePath the path that points to the `targetNode` inside the document. See also `AstNodeLocator`\r\n     *\r\n     * @returns a `Stream` of references that are targeting the `targetNode`\r\n     */\r\n    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;\r\n\r\n}\r\n\r\nexport class DefaultIndexManager implements IndexManager {\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly documents: LangiumDocuments;\r\n    protected readonly astReflection: AstReflection;\r\n\r\n    /**\r\n     * The symbol index stores all `AstNodeDescription` items exported by a document.\r\n     * The key used in this map is the string representation of the specific document URI.\r\n     */\r\n    protected readonly symbolIndex = new Map<string, AstNodeDescription[]>();\r\n    /**\r\n     * This is a cache for the `allElements()` method.\r\n     * It caches the descriptions from `symbolIndex` grouped by types.\r\n     */\r\n    protected readonly symbolByTypeIndex = new ContextCache<string, string, AstNodeDescription[]>();\r\n    /**\r\n     * This index keeps track of all `ReferenceDescription` items exported by a document.\r\n     * This is used to compute which elements are affected by a document change\r\n     * and for finding references to an AST node.\r\n     */\r\n    protected readonly referenceIndex = new Map<string, ReferenceDescription[]>();\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.documents = services.workspace.LangiumDocuments;\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.astReflection = services.AstReflection;\r\n    }\r\n\r\n    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription> {\r\n        const targetDocUri = getDocument(targetNode).uri;\r\n        const result: ReferenceDescription[] = [];\r\n        this.referenceIndex.forEach(docRefs => {\r\n            docRefs.forEach(refDescr => {\r\n                if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\r\n                    result.push(refDescr);\r\n                }\r\n            });\r\n        });\r\n        return stream(result);\r\n    }\r\n\r\n    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription> {\r\n        let documentUris = stream(this.symbolIndex.keys());\r\n        if (uris) {\r\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\r\n        }\r\n        return documentUris\r\n            .map(uri => this.getFileDescriptions(uri, nodeType))\r\n            .flat();\r\n    }\r\n\r\n    protected getFileDescriptions(uri: string, nodeType?: string): AstNodeDescription[] {\r\n        if (!nodeType) {\r\n            return this.symbolIndex.get(uri) ?? [];\r\n        }\r\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\r\n            const allFileDescriptions = this.symbolIndex.get(uri) ?? [];\r\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\r\n        });\r\n        return descriptions;\r\n    }\r\n\r\n    remove(uri: URI): void {\r\n        const uriString = uri.toString();\r\n        this.symbolIndex.delete(uriString);\r\n        this.symbolByTypeIndex.clear(uriString);\r\n        this.referenceIndex.delete(uriString);\r\n    }\r\n\r\n    async updateContent(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        const services = this.serviceRegistry.getServices(document.uri);\r\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\r\n        const uri = document.uri.toString();\r\n        this.symbolIndex.set(uri, exports);\r\n        this.symbolByTypeIndex.clear(uri);\r\n    }\r\n\r\n    async updateReferences(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        const services = this.serviceRegistry.getServices(document.uri);\r\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\r\n        this.referenceIndex.set(document.uri.toString(), indexData);\r\n    }\r\n\r\n    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean {\r\n        const references = this.referenceIndex.get(document.uri.toString());\r\n        if (!references) {\r\n            return false;\r\n        }\r\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAKhF,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AACpD,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AACnD,OAAO,EAAE,iBAAiB,EAAE,MAAM,0BAA0B,CAAC;AAE7D,OAAO,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;AAE5C,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;;;;;;AAoE3C,MAAO,mBAAmB;IAuB5B,YAAY,QAAmC,CAAA;QAjB/C;;;WAGG,CACgB,IAAA,CAAA,WAAW,GAAG,IAAI,GAAG,EAAgC,CAAC;QACzE;;;WAGG,CACgB,IAAA,CAAA,iBAAiB,GAAG,IAAI,sNAAY,EAAwC,CAAC;QAChG;;;;WAIG,CACgB,IAAA,CAAA,cAAc,GAAG,IAAI,GAAG,EAAkC,CAAC;QAG1E,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC,gBAAgB,CAAC;QACrD,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,eAAe,CAAC;QAChD,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC;IAChD,CAAC;IAED,iBAAiB,CAAC,UAAmB,EAAE,WAAmB,EAAA;QACtD,MAAM,YAAY,OAAG,0NAAW,EAAC,UAAU,CAAC,CAAC,GAAG,CAAC;QACjD,MAAM,MAAM,GAA2B,EAAE,CAAC;QAC1C,IAAI,CAAC,cAAc,CAAC,OAAO,EAAC,OAAO,CAAC,EAAE;YAClC,OAAO,CAAC,OAAO,EAAC,QAAQ,CAAC,EAAE;gBACvB,IAAI,uOAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,YAAY,CAAC,IAAI,QAAQ,CAAC,UAAU,KAAK,WAAW,EAAE,CAAC;oBAC3F,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC1B,CAAC;YACL,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QACH,WAAO,+MAAM,EAAC,MAAM,CAAC,CAAC;IAC1B,CAAC;IAED,WAAW,CAAC,QAAiB,EAAE,IAAkB,EAAA;QAC7C,IAAI,YAAY,OAAG,+MAAM,EAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC;QACnD,IAAI,IAAI,EAAE,CAAC;YACP,YAAY,GAAG,YAAY,CAAC,MAAM,EAAC,GAAG,CAAC,EAAE,AAAC,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QACtE,CAAC;QACD,OAAO,YAAY,CACd,GAAG,EAAC,GAAG,CAAC,EAAE,AAAC,IAAI,CAAC,mBAAmB,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC,CACnD,IAAI,EAAE,CAAC;IAChB,CAAC;IAES,mBAAmB,CAAC,GAAW,EAAE,QAAiB,EAAA;;QACxD,IAAI,CAAC,QAAQ,EAAE,CAAC;YACZ,OAAO,CAAA,KAAA,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE,CAAC;QAC3C,CAAC;QACD,MAAM,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE;;YAChE,MAAM,mBAAmB,GAAG,CAAA,KAAA,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE,CAAC;YAC5D,OAAO,mBAAmB,CAAC,MAAM,EAAC,CAAC,CAAC,EAAE,AAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC3F,CAAC,CAAC,CAAC;QACH,OAAO,YAAY,CAAC;IACxB,CAAC;IAED,MAAM,CAAC,GAAQ,EAAA;QACX,MAAM,SAAS,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;QACjC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QACnC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACxC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,QAAyB,EAAE,WAAW,GAAG,qPAAiB,CAAC,IAAI,EAAA;QAC/E,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAChE,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,UAAU,CAAC,gBAAgB,CAAC,cAAc,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;QACjG,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;QACpC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QACnC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACtC,CAAC;IAED,KAAK,CAAC,gBAAgB,CAAC,QAAyB,EAAE,WAAW,GAAG,qPAAiB,CAAC,IAAI,EAAA;QAClF,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAChE,MAAM,SAAS,GAAG,MAAM,QAAQ,CAAC,SAAS,CAAC,4BAA4B,CAAC,kBAAkB,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;QAClH,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,SAAS,CAAC,CAAC;IAChE,CAAC;IAED,UAAU,CAAC,QAAyB,EAAE,WAAwB,EAAA;QAC1D,MAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC;QACpE,IAAI,CAAC,UAAU,EAAE,CAAC;YACd,OAAO,KAAK,CAAC;QACjB,CAAC;QACD,OAAO,UAAU,CAAC,IAAI,EAAC,GAAG,CAAC,EAAE,AAAC,CAAC,GAAG,CAAC,KAAK,IAAI,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;IAC3F,CAAC;CAEJ"}},
    {"offset": {"line": 7582, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/workspace-manager.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/workspace-manager.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { InitializeParams, InitializedParams } from 'vscode-languageserver-protocol';\r\nimport type { WorkspaceFolder } from 'vscode-languageserver-types';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedCoreServices } from '../services.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport { Deferred, interruptAndCheck } from '../utils/promise-utils.js';\r\nimport { URI, UriUtils } from '../utils/uri-utils.js';\r\nimport type { BuildOptions, DocumentBuilder } from './document-builder.js';\r\nimport type { LangiumDocument, LangiumDocuments } from './documents.js';\r\nimport type { FileSystemNode, FileSystemProvider } from './file-system-provider.js';\r\nimport type { WorkspaceLock } from './workspace-lock.js';\r\n\r\n// export type WorkspaceFolder from 'vscode-languageserver-types' for convenience,\r\n//  is supposed to avoid confusion as 'WorkspaceFolder' might accidentally be imported via 'vscode-languageclient'\r\nexport type { WorkspaceFolder };\r\n\r\n/**\r\n * The workspace manager is responsible for finding source files in the workspace.\r\n * This service is shared between all languages of a language server.\r\n */\r\nexport interface WorkspaceManager {\r\n\r\n    /** The options used for the initial workspace build. */\r\n    initialBuildOptions: BuildOptions | undefined;\r\n\r\n    /**\r\n     * A promise that resolves when the workspace manager is ready to be used.\r\n     * Use this to ensure that the workspace manager has finished its initialization.\r\n     */\r\n    readonly ready: Promise<void>;\r\n\r\n    /**\r\n     * The workspace folders of the current workspace.\r\n     * Available only after the `ready` promise resolves.\r\n     */\r\n    get workspaceFolders(): readonly WorkspaceFolder[] | undefined;\r\n\r\n    /**\r\n     * When used in a language server context, this method is called when the server receives\r\n     * the `initialize` request.\r\n     */\r\n    initialize(params: InitializeParams): void;\r\n\r\n    /**\r\n     * When used in a language server context, this method is called when the server receives\r\n     * the `initialized` notification.\r\n     */\r\n    initialized(params: InitializedParams): Promise<void>;\r\n\r\n    /**\r\n     * Does the initial indexing of workspace folders.\r\n     * Collects information about exported and referenced AstNodes in\r\n     * each language file and stores it locally.\r\n     *\r\n     * @param folders The set of workspace folders to be indexed.\r\n     * @param cancelToken A cancellation token that can be used to cancel the operation.\r\n     *\r\n     * @throws OperationCancelled if a cancellation event has been detected\r\n     */\r\n    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken): Promise<void>;\r\n\r\n}\r\n\r\nexport class DefaultWorkspaceManager implements WorkspaceManager {\r\n\r\n    initialBuildOptions: BuildOptions = {};\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly langiumDocuments: LangiumDocuments;\r\n    protected readonly documentBuilder: DocumentBuilder;\r\n    protected readonly fileSystemProvider: FileSystemProvider;\r\n    protected readonly mutex: WorkspaceLock;\r\n    protected readonly _ready = new Deferred<void>();\r\n    protected folders?: WorkspaceFolder[];\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.langiumDocuments = services.workspace.LangiumDocuments;\r\n        this.documentBuilder = services.workspace.DocumentBuilder;\r\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\r\n        this.mutex = services.workspace.WorkspaceLock;\r\n    }\r\n\r\n    get ready(): Promise<void> {\r\n        return this._ready.promise;\r\n    }\r\n\r\n    get workspaceFolders(): readonly WorkspaceFolder[] | undefined {\r\n        return this.folders;\r\n    }\r\n\r\n    initialize(params: InitializeParams): void {\r\n        this.folders = params.workspaceFolders ?? undefined;\r\n    }\r\n\r\n    initialized(_params: InitializedParams): Promise<void> {\r\n        // Initialize the workspace even if there are no workspace folders\r\n        // We still want to load additional documents (language library or similar) during initialization\r\n        return this.mutex.write(token => this.initializeWorkspace(this.folders ?? [], token));\r\n    }\r\n\r\n    async initializeWorkspace(folders: WorkspaceFolder[], cancelToken = CancellationToken.None): Promise<void> {\r\n        const documents = await this.performStartup(folders);\r\n        // Only after creating all documents do we check whether we need to cancel the initialization\r\n        // The document builder will later pick up on all unprocessed documents\r\n        await interruptAndCheck(cancelToken);\r\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\r\n    }\r\n\r\n    /**\r\n     * Performs the uninterruptable startup sequence of the workspace manager.\r\n     * This methods loads all documents in the workspace and other documents and returns them.\r\n     */\r\n    protected async performStartup(folders: WorkspaceFolder[]): Promise<LangiumDocument[]> {\r\n        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);\r\n        const documents: LangiumDocument[] = [];\r\n        const collector = (document: LangiumDocument) => {\r\n            documents.push(document);\r\n            if (!this.langiumDocuments.hasDocument(document.uri)) {\r\n                this.langiumDocuments.addDocument(document);\r\n            }\r\n        };\r\n        // Even though we don't await the initialization of the workspace manager,\r\n        // we can still assume that all library documents and file documents are loaded by the time we start building documents.\r\n        // The mutex prevents anything from performing a workspace build until we check the cancellation token\r\n        await this.loadAdditionalDocuments(folders, collector);\r\n        await Promise.all(\r\n            folders.map(wf => [wf, this.getRootFolder(wf)] as [WorkspaceFolder, URI])\r\n                .map(async entry => this.traverseFolder(...entry, fileExtensions, collector))\r\n        );\r\n        this._ready.resolve();\r\n        return documents;\r\n    }\r\n\r\n    /**\r\n     * Load all additional documents that shall be visible in the context of the given workspace\r\n     * folders and add them to the collector. This can be used to include built-in libraries of\r\n     * your language, which can be either loaded from provided files or constructed in memory.\r\n     */\r\n    protected loadAdditionalDocuments(_folders: WorkspaceFolder[], _collector: (document: LangiumDocument) => void): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Determine the root folder of the source documents in the given workspace folder.\r\n     * The default implementation returns the URI of the workspace folder, but you can override\r\n     * this to return a subfolder like `src` instead.\r\n     */\r\n    protected getRootFolder(workspaceFolder: WorkspaceFolder): URI {\r\n        return URI.parse(workspaceFolder.uri);\r\n    }\r\n\r\n    /**\r\n     * Traverse the file system folder identified by the given URI and its subfolders. All\r\n     * contained files that match the file extensions are added to the collector.\r\n     */\r\n    protected async traverseFolder(workspaceFolder: WorkspaceFolder, folderPath: URI, fileExtensions: string[], collector: (document: LangiumDocument) => void): Promise<void> {\r\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\r\n        await Promise.all(content.map(async entry => {\r\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\r\n                if (entry.isDirectory) {\r\n                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\r\n                } else if (entry.isFile) {\r\n                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\r\n                    collector(document);\r\n                }\r\n            }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Determine whether the given folder entry shall be included while indexing the workspace.\r\n     */\r\n    protected includeEntry(_workspaceFolder: WorkspaceFolder, entry: FileSystemNode, fileExtensions: string[]): boolean {\r\n        const name = UriUtils.basename(entry.uri);\r\n        if (name.startsWith('.')) {\r\n            return false;\r\n        }\r\n        if (entry.isDirectory) {\r\n            return name !== 'node_modules' && name !== 'out';\r\n        } else if (entry.isFile) {\r\n            const extname = UriUtils.extname(entry.uri);\r\n            return fileExtensions.includes(extname);\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7705, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/lexer.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/lexer.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { ILexerErrorMessageProvider, ILexingError, IMultiModeLexerDefinition, IToken, TokenType, TokenTypeDictionary, TokenVocabulary } from 'chevrotain';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport { Lexer as ChevrotainLexer, defaultLexerErrorProvider } from 'chevrotain';\r\nimport type { LexingReport, TokenBuilder } from './token-builder.js';\r\n\r\nexport class DefaultLexerErrorMessageProvider implements ILexerErrorMessageProvider {\r\n\r\n    buildUnexpectedCharactersMessage(fullText: string, startOffset: number, length: number, line?: number, column?: number): string {\r\n        return defaultLexerErrorProvider.buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column);\r\n    }\r\n\r\n    buildUnableToPopLexerModeMessage(token: IToken): string {\r\n        return defaultLexerErrorProvider.buildUnableToPopLexerModeMessage(token);\r\n    }\r\n}\r\n\r\nexport interface LexerResult {\r\n    /**\r\n     * A list of all tokens that were lexed from the input.\r\n     *\r\n     * Note that Langium requires the optional properties\r\n     * `startLine`, `startColumn`, `endOffset`, `endLine` and `endColumn` to be set on each token.\r\n     */\r\n    tokens: IToken[];\r\n    /**\r\n     * Contains hidden tokens, usually comments.\r\n     */\r\n    hidden: IToken[];\r\n    errors: ILexingError[];\r\n    report?: LexingReport;\r\n}\r\n\r\nexport type TokenizeMode = 'full' | 'partial';\r\n\r\nexport interface TokenizeOptions {\r\n    mode?: TokenizeMode;\r\n}\r\n\r\nexport const DEFAULT_TOKENIZE_OPTIONS: TokenizeOptions = { mode: 'full' };\r\n\r\nexport interface Lexer {\r\n    readonly definition: TokenTypeDictionary;\r\n    tokenize(text: string, options?: TokenizeOptions): LexerResult;\r\n}\r\n\r\nexport class DefaultLexer implements Lexer {\r\n\r\n    protected readonly tokenBuilder: TokenBuilder;\r\n    protected readonly errorMessageProvider: ILexerErrorMessageProvider;\r\n    protected tokenTypes: TokenTypeDictionary;\r\n    protected chevrotainLexer: ChevrotainLexer;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.errorMessageProvider = services.parser.LexerErrorMessageProvider;\r\n        this.tokenBuilder = services.parser.TokenBuilder;\r\n        const tokens = this.tokenBuilder.buildTokens(services.Grammar, {\r\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\r\n        });\r\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\r\n        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\r\n        const production = services.LanguageMetaData.mode === 'production';\r\n        this.chevrotainLexer = new ChevrotainLexer(lexerTokens, {\r\n            positionTracking: 'full',\r\n            skipValidations: production,\r\n            errorMessageProvider: this.errorMessageProvider\r\n        });\r\n    }\r\n\r\n    get definition(): TokenTypeDictionary {\r\n        return this.tokenTypes;\r\n    }\r\n\r\n    tokenize(text: string, _options: TokenizeOptions = DEFAULT_TOKENIZE_OPTIONS): LexerResult {\r\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\r\n        return {\r\n            tokens: chevrotainResult.tokens,\r\n            errors: chevrotainResult.errors,\r\n            hidden: chevrotainResult.groups.hidden ?? [],\r\n            report: this.tokenBuilder.flushLexingReport?.(text)\r\n        };\r\n    }\r\n\r\n    protected toTokenTypeDictionary(buildTokens: TokenVocabulary): TokenTypeDictionary {\r\n        if (isTokenTypeDictionary(buildTokens)) return buildTokens;\r\n        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\r\n        const res: TokenTypeDictionary = {};\r\n        tokens.forEach(token => res[token.name] = token);\r\n        return res;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a check whether the given TokenVocabulary is TokenType array\r\n */\r\nexport function isTokenTypeArray(tokenVocabulary: TokenVocabulary): tokenVocabulary is TokenType[] {\r\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);\r\n}\r\n\r\n/**\r\n * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition\r\n */\r\nexport function isIMultiModeLexerDefinition(tokenVocabulary: TokenVocabulary): tokenVocabulary is IMultiModeLexerDefinition {\r\n    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;\r\n}\r\n\r\n/**\r\n * Returns a check whether the given TokenVocabulary is TokenTypeDictionary\r\n */\r\nexport function isTokenTypeDictionary(tokenVocabulary: TokenVocabulary): tokenVocabulary is TokenTypeDictionary {\r\n    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7788, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/documentation/jsdoc.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/documentation/jsdoc.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { Position, Range } from 'vscode-languageserver-types';\r\nimport type { CstNode } from '../syntax-tree.js';\r\nimport { NEWLINE_REGEXP, escapeRegExp } from '../utils/regexp-utils.js';\r\nimport { URI } from '../utils/uri-utils.js';\r\n\r\nexport interface JSDocComment extends JSDocValue {\r\n    readonly elements: JSDocElement[]\r\n    getTag(name: string): JSDocTag | undefined\r\n    getTags(name: string): JSDocTag[]\r\n}\r\n\r\nexport type JSDocElement = JSDocParagraph | JSDocTag;\r\n\r\nexport type JSDocInline = JSDocTag | JSDocLine;\r\n\r\nexport interface JSDocValue {\r\n    /**\r\n     * Represents the range that this JSDoc element occupies.\r\n     * If the JSDoc was parsed from a `CstNode`, the range will represent the location in the source document.\r\n     */\r\n    readonly range: Range\r\n    /**\r\n     * Renders this JSDoc element to a plain text representation.\r\n     */\r\n    toString(): string\r\n    /**\r\n     * Renders this JSDoc element to a markdown representation.\r\n     *\r\n     * @param options Rendering options to customize the markdown result.\r\n     */\r\n    toMarkdown(options?: JSDocRenderOptions): string\r\n}\r\n\r\nexport interface JSDocParagraph extends JSDocValue {\r\n    readonly inlines: JSDocInline[]\r\n}\r\n\r\nexport interface JSDocLine extends JSDocValue {\r\n    readonly text: string\r\n}\r\n\r\nexport interface JSDocTag extends JSDocValue {\r\n    readonly name: string\r\n    readonly content: JSDocParagraph\r\n    readonly inline: boolean\r\n}\r\n\r\nexport interface JSDocParseOptions {\r\n    /**\r\n     * The start symbol of your comment format. Defaults to `/**`.\r\n     */\r\n    readonly start?: RegExp | string\r\n    /**\r\n     * The symbol that start a line of your comment format. Defaults to `*`.\r\n     */\r\n    readonly line?: RegExp | string\r\n    /**\r\n     * The end symbol of your comment format. Defaults to `*\\/`.\r\n     */\r\n    readonly end?: RegExp | string\r\n}\r\n\r\nexport interface JSDocRenderOptions {\r\n    /**\r\n     * Determines the style for rendering tags. Defaults to `italic`.\r\n     */\r\n    tag?: 'plain' | 'italic' | 'bold' | 'bold-italic'\r\n    /**\r\n     * Determines the default for rendering `@link` tags. Defaults to `plain`.\r\n     */\r\n    link?: 'code' | 'plain'\r\n    /**\r\n     * Custom tag rendering function.\r\n     * Return a markdown formatted tag or `undefined` to fall back to the default rendering.\r\n     */\r\n    renderTag?(tag: JSDocTag): string | undefined\r\n    /**\r\n     * Custom link rendering function. Accepts a link target and a display value for the link.\r\n     * Return a markdown formatted link with the format `[$display]($link)` or `undefined` if the link is not a valid target.\r\n     */\r\n    renderLink?(link: string, display: string): string | undefined\r\n}\r\n\r\n/**\r\n * Parses a JSDoc from a `CstNode` containing a comment.\r\n *\r\n * @param node A `CstNode` from a parsed Langium document.\r\n * @param options Parsing options specialized to your language. See {@link JSDocParseOptions}.\r\n */\r\nexport function parseJSDoc(node: CstNode, options?: JSDocParseOptions): JSDocComment;\r\n/**\r\n * Parses a JSDoc from a string comment.\r\n *\r\n * @param content A string containing the source of the JSDoc comment.\r\n * @param start The start position the comment occupies in the source document.\r\n * @param options Parsing options specialized to your language. See {@link JSDocParseOptions}.\r\n */\r\nexport function parseJSDoc(content: string, start?: Position, options?: JSDocParseOptions): JSDocComment;\r\nexport function parseJSDoc(node: CstNode | string, start?: Position | JSDocParseOptions, options?: JSDocParseOptions): JSDocComment {\r\n    let opts: JSDocParseOptions | undefined;\r\n    let position: Position | undefined;\r\n    if (typeof node === 'string') {\r\n        position = start as Position | undefined;\r\n        opts = options as JSDocParseOptions | undefined;\r\n    } else {\r\n        position = node.range.start;\r\n        opts = start as JSDocParseOptions | undefined;\r\n    }\r\n    if (!position) {\r\n        position = Position.create(0, 0);\r\n    }\r\n\r\n    const lines = getLines(node);\r\n    const normalizedOptions = normalizeOptions(opts);\r\n\r\n    const tokens = tokenize({\r\n        lines,\r\n        position,\r\n        options: normalizedOptions\r\n    });\r\n\r\n    return parseJSDocComment({\r\n        index: 0,\r\n        tokens,\r\n        position\r\n    });\r\n}\r\n\r\nexport function isJSDoc(node: CstNode | string, options?: JSDocParseOptions): boolean {\r\n    const normalizedOptions = normalizeOptions(options);\r\n    const lines = getLines(node);\r\n    if (lines.length === 0) {\r\n        return false;\r\n    }\r\n\r\n    const first = lines[0];\r\n    const last = lines[lines.length - 1];\r\n    const firstRegex = normalizedOptions.start;\r\n    const lastRegex = normalizedOptions.end;\r\n\r\n    return Boolean(firstRegex?.exec(first)) && Boolean(lastRegex?.exec(last));\r\n}\r\n\r\nfunction getLines(node: CstNode | string): string[] {\r\n    let content = '';\r\n    if (typeof node === 'string') {\r\n        content = node;\r\n    } else {\r\n        content = node.text;\r\n    }\r\n    const lines = content.split(NEWLINE_REGEXP);\r\n    return lines;\r\n}\r\n\r\n// Tokenization\r\n\r\ninterface JSDocToken {\r\n    type: 'text' | 'tag' | 'inline-tag' | 'break'\r\n    content: string\r\n    range: Range\r\n}\r\n\r\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\r\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\r\n\r\nfunction tokenize(context: TokenizationContext): JSDocToken[] {\r\n    const tokens: JSDocToken[] = [];\r\n    let currentLine = context.position.line;\r\n    let currentCharacter = context.position.character;\r\n    for (let i = 0; i < context.lines.length; i++) {\r\n        const first = i === 0;\r\n        const last = i === context.lines.length - 1;\r\n        let line = context.lines[i];\r\n        let index = 0;\r\n\r\n        if (first && context.options.start) {\r\n            const match = context.options.start?.exec(line);\r\n            if (match) {\r\n                index = match.index + match[0].length;\r\n            }\r\n        } else {\r\n            const match = context.options.line?.exec(line);\r\n            if (match) {\r\n                index = match.index + match[0].length;\r\n            }\r\n        }\r\n        if (last) {\r\n            const match = context.options.end?.exec(line);\r\n            if (match) {\r\n                line = line.substring(0, match.index);\r\n            }\r\n        }\r\n\r\n        line = line.substring(0, lastCharacter(line));\r\n        const whitespaceEnd = skipWhitespace(line, index);\r\n\r\n        if (whitespaceEnd >= line.length) {\r\n            // Only create a break token when we already have previous tokens\r\n            if (tokens.length > 0) {\r\n                const position = Position.create(currentLine, currentCharacter);\r\n                tokens.push({\r\n                    type: 'break',\r\n                    content: '',\r\n                    range: Range.create(position, position)\r\n                });\r\n            }\r\n        } else {\r\n            tagRegex.lastIndex = index;\r\n            const tagMatch = tagRegex.exec(line);\r\n            if (tagMatch) {\r\n                const fullMatch = tagMatch[0];\r\n                const value = tagMatch[1];\r\n                const start = Position.create(currentLine, currentCharacter + index);\r\n                const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\r\n                tokens.push({\r\n                    type: 'tag',\r\n                    content: value,\r\n                    range: Range.create(start, end)\r\n                });\r\n                index += fullMatch.length;\r\n                index = skipWhitespace(line, index);\r\n            }\r\n\r\n            if (index < line.length) {\r\n                const rest = line.substring(index);\r\n                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\r\n                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\r\n            }\r\n        }\r\n\r\n        currentLine++;\r\n        currentCharacter = 0;\r\n    }\r\n\r\n    // Remove last break token if there is one\r\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'break') {\r\n        return tokens.slice(0, -1);\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\nfunction buildInlineTokens(tags: RegExpMatchArray[], line: string, lineIndex: number, characterIndex: number): JSDocToken[] {\r\n    const tokens: JSDocToken[] = [];\r\n\r\n    if (tags.length === 0) {\r\n        const start = Position.create(lineIndex, characterIndex);\r\n        const end = Position.create(lineIndex, characterIndex + line.length);\r\n        tokens.push({\r\n            type: 'text',\r\n            content: line,\r\n            range: Range.create(start, end)\r\n        });\r\n    } else {\r\n        let lastIndex = 0;\r\n        for (const match of tags) {\r\n            const matchIndex = match.index!;\r\n            const startContent = line.substring(lastIndex, matchIndex);\r\n            if (startContent.length > 0) {\r\n                tokens.push({\r\n                    type: 'text',\r\n                    content: line.substring(lastIndex, matchIndex),\r\n                    range: Range.create(\r\n                        Position.create(lineIndex, lastIndex + characterIndex),\r\n                        Position.create(lineIndex, matchIndex + characterIndex)\r\n                    )\r\n                });\r\n            }\r\n            let offset = startContent.length + 1;\r\n            const tagName = match[1];\r\n            tokens.push({\r\n                type: 'inline-tag',\r\n                content: tagName,\r\n                range: Range.create(\r\n                    Position.create(lineIndex, lastIndex + offset + characterIndex),\r\n                    Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex)\r\n                )\r\n            });\r\n            offset += tagName.length;\r\n            if (match.length === 4) {\r\n                offset += match[2].length;\r\n                const value = match[3];\r\n                tokens.push({\r\n                    type: 'text',\r\n                    content: value,\r\n                    range: Range.create(\r\n                        Position.create(lineIndex, lastIndex + offset + characterIndex),\r\n                        Position.create(lineIndex, lastIndex + offset + value.length + characterIndex)\r\n                    )\r\n                });\r\n            } else {\r\n                tokens.push({\r\n                    type: 'text',\r\n                    content: '',\r\n                    range: Range.create(\r\n                        Position.create(lineIndex, lastIndex + offset + characterIndex),\r\n                        Position.create(lineIndex, lastIndex + offset + characterIndex)\r\n                    )\r\n                });\r\n            }\r\n            lastIndex = matchIndex + match[0].length;\r\n        }\r\n        const endContent = line.substring(lastIndex);\r\n        if (endContent.length > 0) {\r\n            tokens.push({\r\n                type: 'text',\r\n                content: endContent,\r\n                range: Range.create(\r\n                    Position.create(lineIndex, lastIndex + characterIndex),\r\n                    Position.create(lineIndex, lastIndex + characterIndex + endContent.length)\r\n                )\r\n            });\r\n        }\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\nconst nonWhitespaceRegex = /\\S/;\r\nconst whitespaceEndRegex = /\\s*$/;\r\n\r\nfunction skipWhitespace(line: string, index: number): number {\r\n    const match = line.substring(index).match(nonWhitespaceRegex);\r\n    if (match) {\r\n        return index + match.index!;\r\n    } else {\r\n        return line.length;\r\n    }\r\n}\r\n\r\nfunction lastCharacter(line: string): number | undefined {\r\n    const match = line.match(whitespaceEndRegex);\r\n    if (match && typeof match.index === 'number') {\r\n        return match.index;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n// Parsing\r\n\r\nfunction parseJSDocComment(context: ParseContext): JSDocComment {\r\n    const startPosition: Position = Position.create(context.position.line, context.position.character);\r\n    if (context.tokens.length === 0) {\r\n        return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\r\n    }\r\n    const elements: JSDocElement[] = [];\r\n    while (context.index < context.tokens.length) {\r\n        const element = parseJSDocElement(context, elements[elements.length - 1]);\r\n        if (element) {\r\n            elements.push(element);\r\n        }\r\n    }\r\n    const start = elements[0]?.range.start ?? startPosition;\r\n    const end = elements[elements.length - 1]?.range.end ?? startPosition;\r\n    return new JSDocCommentImpl(elements, Range.create(start, end));\r\n}\r\n\r\nfunction parseJSDocElement(context: ParseContext, last?: JSDocElement): JSDocElement | undefined {\r\n    const next = context.tokens[context.index];\r\n    if (next.type === 'tag') {\r\n        return parseJSDocTag(context, false);\r\n    } else if (next.type === 'text' || next.type === 'inline-tag') {\r\n        return parseJSDocText(context);\r\n    } else {\r\n        appendEmptyLine(next, last);\r\n        context.index++;\r\n        return undefined;\r\n    }\r\n}\r\n\r\nfunction appendEmptyLine(token: JSDocToken, element?: JSDocElement): void {\r\n    if (element) {\r\n        const line = new JSDocLineImpl('', token.range);\r\n        if ('inlines' in element) {\r\n            element.inlines.push(line);\r\n        } else {\r\n            element.content.inlines.push(line);\r\n        }\r\n    }\r\n}\r\n\r\nfunction parseJSDocText(context: ParseContext): JSDocParagraph {\r\n    let token = context.tokens[context.index];\r\n    const firstToken = token;\r\n    let lastToken = token;\r\n    const lines: JSDocInline[] = [];\r\n    while (token && token.type !== 'break' && token.type !== 'tag') {\r\n        lines.push(parseJSDocInline(context));\r\n        lastToken = token;\r\n        token = context.tokens[context.index];\r\n    }\r\n    return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\r\n}\r\n\r\nfunction parseJSDocInline(context: ParseContext): JSDocInline {\r\n    const token = context.tokens[context.index];\r\n    if (token.type === 'inline-tag') {\r\n        return parseJSDocTag(context, true);\r\n    } else {\r\n        return parseJSDocLine(context);\r\n    }\r\n}\r\n\r\nfunction parseJSDocTag(context: ParseContext, inline: boolean): JSDocTag {\r\n    const tagToken = context.tokens[context.index++];\r\n    const name = tagToken.content.substring(1);\r\n    const nextToken = context.tokens[context.index];\r\n    if (nextToken?.type === 'text') {\r\n        if (inline) {\r\n            const docLine = parseJSDocLine(context);\r\n            return new JSDocTagImpl(\r\n                name,\r\n                new JSDocTextImpl([docLine], docLine.range),\r\n                inline,\r\n                Range.create(tagToken.range.start, docLine.range.end)\r\n            );\r\n        } else {\r\n            const textDoc = parseJSDocText(context);\r\n            return new JSDocTagImpl(\r\n                name,\r\n                textDoc,\r\n                inline,\r\n                Range.create(tagToken.range.start, textDoc.range.end)\r\n            );\r\n        }\r\n    } else {\r\n        const range = tagToken.range;\r\n        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\r\n    }\r\n}\r\n\r\nfunction parseJSDocLine(context: ParseContext): JSDocLine {\r\n    const token = context.tokens[context.index++];\r\n    return new JSDocLineImpl(token.content, token.range);\r\n}\r\n\r\ninterface NormalizedOptions {\r\n    start?: RegExp\r\n    end?: RegExp\r\n    line?: RegExp\r\n}\r\n\r\ninterface TokenizationContext {\r\n    position: Position\r\n    lines: string[]\r\n    options: NormalizedOptions\r\n}\r\n\r\ninterface ParseContext {\r\n    position: Position\r\n    tokens: JSDocToken[]\r\n    index: number\r\n}\r\n\r\nfunction normalizeOptions(options?: JSDocParseOptions): NormalizedOptions {\r\n    if (!options) {\r\n        return normalizeOptions({\r\n            start: '/**',\r\n            end: '*/',\r\n            line: '*'\r\n        });\r\n    }\r\n    const { start, end, line } = options;\r\n    return {\r\n        start: normalizeOption(start, true),\r\n        end: normalizeOption(end, false),\r\n        line: normalizeOption(line, true)\r\n    };\r\n}\r\n\r\nfunction normalizeOption(option: RegExp | string | undefined, start: boolean): RegExp | undefined {\r\n    if (typeof option === 'string' || typeof option === 'object') {\r\n        const escaped = typeof option === 'string' ? escapeRegExp(option) : option.source;\r\n        if (start) {\r\n            return new RegExp(`^\\\\s*${escaped}`);\r\n        } else {\r\n            return new RegExp(`\\\\s*${escaped}\\\\s*$`);\r\n        }\r\n    } else {\r\n        return option;\r\n    }\r\n}\r\n\r\nclass JSDocCommentImpl implements JSDocComment {\r\n\r\n    readonly elements: JSDocElement[];\r\n    readonly range: Range;\r\n\r\n    constructor(elements: JSDocElement[], range: Range) {\r\n        this.elements = elements;\r\n        this.range = range;\r\n    }\r\n\r\n    getTag(name: string): JSDocTag | undefined {\r\n        return this.getAllTags().find(e => e.name === name);\r\n    }\r\n\r\n    getTags(name: string): JSDocTag[] {\r\n        return this.getAllTags().filter(e => e.name === name);\r\n    }\r\n\r\n    private getAllTags(): JSDocTag[] {\r\n        return this.elements.filter((e): e is JSDocTag => 'name' in e);\r\n    }\r\n\r\n    toString(): string {\r\n        let value = '';\r\n        for (const element of this.elements) {\r\n            if (value.length === 0) {\r\n                value = element.toString();\r\n            } else {\r\n                const text = element.toString();\r\n                value += fillNewlines(value) + text;\r\n            }\r\n        }\r\n        return value.trim();\r\n    }\r\n\r\n    toMarkdown(options?: JSDocRenderOptions): string {\r\n        let value = '';\r\n        for (const element of this.elements) {\r\n            if (value.length === 0) {\r\n                value = element.toMarkdown(options);\r\n            } else {\r\n                const text = element.toMarkdown(options);\r\n                value += fillNewlines(value) + text;\r\n            }\r\n        }\r\n        return value.trim();\r\n    }\r\n}\r\n\r\nclass JSDocTagImpl implements JSDocTag {\r\n    name: string;\r\n    content: JSDocParagraph;\r\n    range: Range;\r\n    inline: boolean;\r\n\r\n    constructor(name: string, content: JSDocParagraph, inline: boolean, range: Range) {\r\n        this.name = name;\r\n        this.content = content;\r\n        this.inline = inline;\r\n        this.range = range;\r\n    }\r\n\r\n    toString(): string {\r\n        let text = `@${this.name}`;\r\n        const content = this.content.toString();\r\n        if (this.content.inlines.length === 1) {\r\n            text = `${text} ${content}`;\r\n        } else if (this.content.inlines.length > 1) {\r\n            text = `${text}\\n${content}`;\r\n        }\r\n        if (this.inline) {\r\n            // Inline tags are surrounded by curly braces\r\n            return `{${text}}`;\r\n        } else {\r\n            return text;\r\n        }\r\n    }\r\n\r\n    toMarkdown(options?: JSDocRenderOptions): string {\r\n        return options?.renderTag?.(this) ?? this.toMarkdownDefault(options);\r\n    }\r\n\r\n    private toMarkdownDefault(options?: JSDocRenderOptions): string {\r\n        const content = this.content.toMarkdown(options);\r\n        if (this.inline) {\r\n            const rendered = renderInlineTag(this.name, content, options ?? {});\r\n            if (typeof rendered === 'string') {\r\n                return rendered;\r\n            }\r\n        }\r\n        let marker = '';\r\n        if (options?.tag === 'italic' || options?.tag === undefined) {\r\n            marker = '*';\r\n        } else if (options?.tag === 'bold') {\r\n            marker = '**';\r\n        } else if (options?.tag === 'bold-italic') {\r\n            marker = '***';\r\n        }\r\n        let text = `${marker}@${this.name}${marker}`;\r\n        if (this.content.inlines.length === 1) {\r\n            text = `${text}  ${content}`;\r\n        } else if (this.content.inlines.length > 1) {\r\n            text = `${text}\\n${content}`;\r\n        }\r\n        if (this.inline) {\r\n            // Inline tags are surrounded by curly braces\r\n            return `{${text}}`;\r\n        } else {\r\n            return text;\r\n        }\r\n    }\r\n}\r\n\r\nfunction renderInlineTag(tag: string, content: string, options: JSDocRenderOptions): string | undefined {\r\n    if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {\r\n        const index = content.indexOf(' ');\r\n        let display = content;\r\n        if (index > 0) {\r\n            const displayStart = skipWhitespace(content, index);\r\n            display = content.substring(displayStart);\r\n            content = content.substring(0, index);\r\n        }\r\n        if (tag === 'linkcode' || (tag === 'link' && options.link === 'code')) {\r\n            // Surround the display value in a markdown inline code block\r\n            display = `\\`${display}\\``;\r\n        }\r\n        const renderedLink = options.renderLink?.(content, display) ?? renderLinkDefault(content, display);\r\n        return renderedLink;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction renderLinkDefault(content: string, display: string): string {\r\n    try {\r\n        URI.parse(content, true);\r\n        return `[${display}](${content})`;\r\n    } catch {\r\n        return content;\r\n    }\r\n}\r\n\r\nclass JSDocTextImpl implements JSDocParagraph {\r\n    inlines: JSDocInline[];\r\n    range: Range;\r\n\r\n    constructor(lines: JSDocInline[], range: Range) {\r\n        this.inlines = lines;\r\n        this.range = range;\r\n    }\r\n\r\n    toString(): string {\r\n        let text = '';\r\n        for (let i = 0; i < this.inlines.length; i++) {\r\n            const inline = this.inlines[i];\r\n            const next = this.inlines[i + 1];\r\n            text += inline.toString();\r\n            if (next && next.range.start.line > inline.range.start.line) {\r\n                text += '\\n';\r\n            }\r\n        }\r\n        return text;\r\n    }\r\n\r\n    toMarkdown(options?: JSDocRenderOptions): string {\r\n        let text = '';\r\n        for (let i = 0; i < this.inlines.length; i++) {\r\n            const inline = this.inlines[i];\r\n            const next = this.inlines[i + 1];\r\n            text += inline.toMarkdown(options);\r\n            if (next && next.range.start.line > inline.range.start.line) {\r\n                text += '\\n';\r\n            }\r\n        }\r\n        return text;\r\n    }\r\n}\r\n\r\nclass JSDocLineImpl implements JSDocLine {\r\n    text: string;\r\n    range: Range;\r\n\r\n    constructor(text: string, range: Range) {\r\n        this.text = text;\r\n        this.range = range;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.text;\r\n    }\r\n    toMarkdown(): string {\r\n        return this.text;\r\n    }\r\n\r\n}\r\n\r\nfunction fillNewlines(text: string): string {\r\n    if (text.endsWith('\\n')) {\r\n        return '\\n';\r\n    } else {\r\n        return '\\n\\n';\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8284, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/documentation/documentation-provider.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/documentation/documentation-provider.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription } from '../syntax-tree.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { CommentProvider } from './comment-provider.js';\r\nimport type { JSDocTag } from './jsdoc.js';\r\nimport { getDocument } from '../utils/ast-utils.js';\r\nimport { isJSDoc, parseJSDoc } from './jsdoc.js';\r\n\r\n/**\r\n * Provides documentation for AST nodes.\r\n */\r\nexport interface DocumentationProvider {\r\n    /**\r\n     * Returns a markdown documentation string for the specified AST node.\r\n     *\r\n     * The default implementation `JSDocDocumentationProvider` will inspect the comment associated with the specified node.\r\n     */\r\n    getDocumentation(node: AstNode): string | undefined;\r\n}\r\n\r\nexport class JSDocDocumentationProvider implements DocumentationProvider {\r\n\r\n    protected readonly indexManager: IndexManager;\r\n    protected readonly commentProvider: CommentProvider;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.indexManager = services.shared.workspace.IndexManager;\r\n        this.commentProvider = services.documentation.CommentProvider;\r\n    }\r\n\r\n    getDocumentation(node: AstNode): string | undefined {\r\n        const comment = this.commentProvider.getComment(node);\r\n        if (comment && isJSDoc(comment)) {\r\n            const parsedJSDoc = parseJSDoc(comment);\r\n            return parsedJSDoc.toMarkdown({\r\n                renderLink: (link, display) => {\r\n                    return this.documentationLinkRenderer(node, link, display);\r\n                },\r\n                renderTag: (tag) => {\r\n                    return this.documentationTagRenderer(node, tag);\r\n                }\r\n            });\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected documentationLinkRenderer(node: AstNode, name: string, display: string): string | undefined {\r\n        const description = this.findNameInPrecomputedScopes(node, name) ?? this.findNameInGlobalScope(node, name);\r\n        if (description && description.nameSegment) {\r\n            const line = description.nameSegment.range.start.line + 1;\r\n            const character = description.nameSegment.range.start.character + 1;\r\n            const uri = description.documentUri.with({ fragment: `L${line},${character}` });\r\n            return `[${display}](${uri.toString()})`;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    protected documentationTagRenderer(_node: AstNode, _tag: JSDocTag): string | undefined {\r\n        // Fall back to the default tag rendering\r\n        return undefined;\r\n    }\r\n\r\n    protected findNameInPrecomputedScopes(node: AstNode, name: string): AstNodeDescription | undefined {\r\n        const document = getDocument(node);\r\n        const precomputed = document.precomputedScopes;\r\n        if (!precomputed) {\r\n            return undefined;\r\n        }\r\n        let currentNode: AstNode | undefined = node;\r\n        do {\r\n            const allDescriptions = precomputed.get(currentNode);\r\n            const description = allDescriptions.find(e => e.name === name);\r\n            if (description) {\r\n                return description;\r\n            }\r\n            currentNode = currentNode.$container;\r\n        } while (currentNode);\r\n\r\n        return undefined;\r\n    }\r\n\r\n    protected findNameInGlobalScope(node: AstNode, name: string): AstNodeDescription | undefined {\r\n        const description = this.indexManager.allElements().find(e => e.name === name);\r\n        return description;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8360, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/documentation/comment-provider.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/documentation/comment-provider.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { GrammarConfig } from '../languages/grammar-config.js';\r\nimport { isAstNodeWithComment } from '../serializer/json-serializer.js';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport { findCommentNode } from '../utils/cst-utils.js';\r\n\r\n/**\r\n * Provides comments for AST nodes.\r\n */\r\nexport interface CommentProvider {\r\n    /**\r\n     * Returns the comment associated with the specified AST node.\r\n     * @param node The AST node to get the comment for.\r\n     * @returns The comment associated with the specified AST node or `undefined` if there is no comment.\r\n     */\r\n    getComment(node: AstNode): string | undefined;\r\n}\r\n\r\nexport class DefaultCommentProvider implements CommentProvider {\r\n    protected readonly grammarConfig: () => GrammarConfig;\r\n    constructor(services: LangiumCoreServices) {\r\n        this.grammarConfig = () => services.parser.GrammarConfig;\r\n    }\r\n    getComment(node: AstNode): string | undefined {\r\n        if(isAstNodeWithComment(node)) {\r\n            return node.$comment;\r\n        }\r\n        return findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)?.text;\r\n    }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAGhF,OAAO,EAAE,oBAAoB,EAAE,MAAM,kCAAkC,CAAC;AAGxE,OAAO,EAAE,eAAe,EAAE,MAAM,uBAAuB,CAAC;;;AAclD,MAAO,sBAAsB;IAE/B,YAAY,QAA6B,CAAA;QACrC,IAAI,CAAC,aAAa,GAAG,GAAG,CAAG,CAAD,OAAS,CAAC,MAAM,CAAC,aAAa,CAAC;IAC7D,CAAC;IACD,UAAU,CAAC,IAAa,EAAA;;QACpB,QAAG,8OAAoB,EAAC,IAAI,CAAC,EAAE,CAAC;YAC5B,OAAO,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;QACD,OAAO,CAAA,SAAA,8NAAe,EAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,EAAE,CAAC,qBAAqB,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,CAAC;IAC5F,CAAC;CACJ"}},
    {"offset": {"line": 8388, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/parser/async-parser.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/parser/async-parser.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken } from '../utils/cancellation.js';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { LangiumParser, ParseResult } from './langium-parser.js';\r\nimport type { Hydrator } from '../serializer/hydrator.js';\r\nimport type { Event } from '../utils/event.js';\r\nimport { Deferred, OperationCancelled } from '../utils/promise-utils.js';\r\nimport { Emitter } from '../utils/event.js';\r\n\r\n/**\r\n * Async parser that allows cancellation of the current parsing process.\r\n *\r\n * @remarks\r\n * The sync parser implementation is blocking the event loop, which can become quite problematic for large files.\r\n * The default implementation is not actually async. It just wraps the sync parser in a promise. A real implementation would create worker threads or web workers to offload the parsing work.\r\n */\r\nexport interface AsyncParser {\r\n    /**\r\n     * Parses the given text and returns the parse result.\r\n     *\r\n     * @param text The text to parse.\r\n     * @param cancelToken A cancellation token that can be used to cancel the parsing process.\r\n     * @returns A promise that resolves to the parse result.\r\n     *\r\n     * @throws `OperationCancelled` if the parsing process is cancelled.\r\n     */\r\n    parse<T extends AstNode>(text: string, cancelToken: CancellationToken): Promise<ParseResult<T>>;\r\n}\r\n\r\n/**\r\n * Default implementation of the async parser which simply wraps the sync parser in a promise.\r\n *\r\n * @remarks\r\n * A real implementation would create worker threads or web workers to offload the parsing work.\r\n */\r\nexport class DefaultAsyncParser implements AsyncParser {\r\n\r\n    protected readonly syncParser: LangiumParser;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.syncParser = services.parser.LangiumParser;\r\n    }\r\n\r\n    parse<T extends AstNode>(text: string, _cancelToken: CancellationToken): Promise<ParseResult<T>> {\r\n        return Promise.resolve(this.syncParser.parse<T>(text));\r\n    }\r\n}\r\n\r\nexport abstract class AbstractThreadedAsyncParser implements AsyncParser {\r\n\r\n    /**\r\n     * The thread count determines how many threads are used to parse files in parallel.\r\n     * The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.\r\n     */\r\n    protected threadCount = 8;\r\n    /**\r\n     * The termination delay determines how long the parser waits for a thread to finish after a cancellation request.\r\n     * The default value is 200(ms).\r\n     */\r\n    protected terminationDelay = 200;\r\n    protected workerPool: ParserWorker[] = [];\r\n    protected queue: Array<Deferred<ParserWorker>> = [];\r\n\r\n    protected readonly hydrator: Hydrator;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.hydrator = services.serializer.Hydrator;\r\n    }\r\n\r\n    protected initializeWorkers(): void {\r\n        while (this.workerPool.length < this.threadCount) {\r\n            const worker = this.createWorker();\r\n            worker.onReady(() => {\r\n                if (this.queue.length > 0) {\r\n                    const deferred = this.queue.shift();\r\n                    if (deferred) {\r\n                        worker.lock();\r\n                        deferred.resolve(worker);\r\n                    }\r\n                }\r\n            });\r\n            this.workerPool.push(worker);\r\n        }\r\n    }\r\n\r\n    async parse<T extends AstNode>(text: string, cancelToken: CancellationToken): Promise<ParseResult<T>> {\r\n        const worker = await this.acquireParserWorker(cancelToken);\r\n        const deferred = new Deferred<ParseResult<T>>();\r\n        let timeout: NodeJS.Timeout | undefined;\r\n        // If the cancellation token is requested, we wait for a certain time before terminating the worker.\r\n        // Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.\r\n        // Otherwise, we might accidentally terminate the worker after the parsing process has finished.\r\n        const cancellation = cancelToken.onCancellationRequested(() => {\r\n            timeout = setTimeout(() => {\r\n                this.terminateWorker(worker);\r\n            }, this.terminationDelay);\r\n        });\r\n        worker.parse(text).then(result => {\r\n            const hydrated = this.hydrator.hydrate<T>(result);\r\n            deferred.resolve(hydrated);\r\n        }).catch(err => {\r\n            deferred.reject(err);\r\n        }).finally(() => {\r\n            cancellation.dispose();\r\n            clearTimeout(timeout);\r\n        });\r\n        return deferred.promise;\r\n    }\r\n\r\n    protected terminateWorker(worker: ParserWorker): void {\r\n        worker.terminate();\r\n        const index = this.workerPool.indexOf(worker);\r\n        if (index >= 0) {\r\n            this.workerPool.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    protected async acquireParserWorker(cancelToken: CancellationToken): Promise<ParserWorker> {\r\n        this.initializeWorkers();\r\n        for (const worker of this.workerPool) {\r\n            if (worker.ready) {\r\n                worker.lock();\r\n                return worker;\r\n            }\r\n        }\r\n        const deferred = new Deferred<ParserWorker>();\r\n        cancelToken.onCancellationRequested(() => {\r\n            const index = this.queue.indexOf(deferred);\r\n            if (index >= 0) {\r\n                this.queue.splice(index, 1);\r\n            }\r\n            deferred.reject(OperationCancelled);\r\n        });\r\n        this.queue.push(deferred);\r\n        return deferred.promise;\r\n    }\r\n\r\n    protected abstract createWorker(): ParserWorker;\r\n}\r\n\r\nexport type WorkerMessagePost = (message: unknown) => void;\r\nexport type WorkerMessageCallback = (cb: (message: unknown) => void) => void;\r\n\r\nexport class ParserWorker {\r\n\r\n    protected readonly sendMessage: WorkerMessagePost;\r\n    protected readonly _terminate: () => void;\r\n    protected readonly onReadyEmitter = new Emitter<void>();\r\n\r\n    protected deferred = new Deferred<ParseResult>();\r\n    protected _ready = true;\r\n    protected _parsing = false;\r\n\r\n    get ready(): boolean {\r\n        return this._ready;\r\n    }\r\n\r\n    get onReady(): Event<void> {\r\n        return this.onReadyEmitter.event;\r\n    }\r\n\r\n    constructor(sendMessage: WorkerMessagePost, onMessage: WorkerMessageCallback, onError: WorkerMessageCallback, terminate: () => void) {\r\n        this.sendMessage = sendMessage;\r\n        this._terminate = terminate;\r\n        onMessage(result => {\r\n            const parseResult = result as ParseResult;\r\n            this.deferred.resolve(parseResult);\r\n            this.unlock();\r\n        });\r\n        onError(error => {\r\n            this.deferred.reject(error);\r\n            this.unlock();\r\n        });\r\n    }\r\n\r\n    terminate(): void {\r\n        this.deferred.reject(OperationCancelled);\r\n        this._terminate();\r\n    }\r\n\r\n    lock(): void {\r\n        this._ready = false;\r\n    }\r\n\r\n    unlock(): void {\r\n        this._parsing = false;\r\n        this._ready = true;\r\n        this.onReadyEmitter.fire();\r\n    }\r\n\r\n    parse(text: string): Promise<ParseResult> {\r\n        if (this._parsing) {\r\n            throw new Error('Parser worker is busy');\r\n        }\r\n        this._parsing = true;\r\n        this.deferred = new Deferred();\r\n        this.sendMessage(text);\r\n        return this.deferred.promise;\r\n    }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;;;AAQhF,OAAO,EAAE,QAAQ,EAAE,kBAAkB,EAAE,MAAM,2BAA2B,CAAC;AACzE,OAAO,EAAE,OAAO,EAAE,MAAM,mBAAmB,CAAC;;;AA4BtC,MAAO,kBAAkB;IAI3B,YAAY,QAA6B,CAAA;QACrC,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC;IACpD,CAAC;IAED,KAAK,CAAoB,IAAY,EAAE,YAA+B,EAAA;QAClE,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAI,IAAI,CAAC,CAAC,CAAC;IAC3D,CAAC;CACJ;AAEK,MAAgB,2BAA2B;IAiB7C,YAAY,QAA6B,CAAA;QAfzC;;;WAGG,CACO,IAAA,CAAA,WAAW,GAAG,CAAC,CAAC;QAC1B;;;WAGG,CACO,IAAA,CAAA,gBAAgB,GAAG,GAAG,CAAC;QACvB,IAAA,CAAA,UAAU,GAAmB,EAAE,CAAC;QAChC,IAAA,CAAA,KAAK,GAAkC,EAAE,CAAC;QAKhD,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC;IACjD,CAAC;IAES,iBAAiB,GAAA;QACvB,MAAO,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW,CAAE,CAAC;YAC/C,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YACnC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE;gBAChB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACxB,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;oBACpC,IAAI,QAAQ,EAAE,CAAC;wBACX,MAAM,CAAC,IAAI,EAAE,CAAC;wBACd,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;oBAC7B,CAAC;gBACL,CAAC;YACL,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACjC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,KAAK,CAAoB,IAAY,EAAE,WAA8B,EAAA;QACvE,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;QAC3D,MAAM,QAAQ,GAAG,IAAI,2NAAQ,EAAkB,CAAC;QAChD,IAAI,OAAmC,CAAC;QACxC,oGAAoG;QACpG,6GAA6G;QAC7G,gGAAgG;QAChG,MAAM,YAAY,GAAG,WAAW,CAAC,uBAAuB,CAAC,GAAG,EAAE;YAC1D,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;gBACtB,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;YACjC,CAAC,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAC,MAAM,CAAC,EAAE;YAC7B,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAI,MAAM,CAAC,CAAC;YAClD,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC,KAAK,EAAC,GAAG,CAAC,EAAE;YACX,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE;YACZ,YAAY,CAAC,OAAO,EAAE,CAAC;YACvB,YAAY,CAAC,OAAO,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC,OAAO,CAAC;IAC5B,CAAC;IAES,eAAe,CAAC,MAAoB,EAAA;QAC1C,MAAM,CAAC,SAAS,EAAE,CAAC;QACnB,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC9C,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;YACb,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACrC,CAAC;IACL,CAAC;IAES,KAAK,CAAC,mBAAmB,CAAC,WAA8B,EAAA;QAC9D,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,UAAU,CAAE,CAAC;YACnC,IAAI,MAAM,CAAC,KAAK,EAAE,CAAC;gBACf,MAAM,CAAC,IAAI,EAAE,CAAC;gBACd,OAAO,MAAM,CAAC;YAClB,CAAC;QACL,CAAC;QACD,MAAM,QAAQ,GAAG,IAAI,2NAAQ,EAAgB,CAAC;QAC9C,WAAW,CAAC,uBAAuB,CAAC,GAAG,EAAE;YACrC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YAC3C,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;gBACb,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YAChC,CAAC;YACD,QAAQ,CAAC,MAAM,CAAC,qOAAkB,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC1B,OAAO,QAAQ,CAAC,OAAO,CAAC;IAC5B,CAAC;CAGJ;AAKK,MAAO,YAAY;IAUrB,IAAI,KAAK,GAAA;QACL,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAED,IAAI,OAAO,GAAA;QACP,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;IACrC,CAAC;IAED,YAAY,WAA8B,EAAE,SAAgC,EAAE,OAA8B,EAAE,SAAqB,CAAA;QAdhH,IAAA,CAAA,cAAc,GAAG,IAAI,qOAAO,EAAQ,CAAC;QAE9C,IAAA,CAAA,QAAQ,GAAG,IAAI,2NAAQ,EAAe,CAAC;QACvC,IAAA,CAAA,MAAM,GAAG,IAAI,CAAC;QACd,IAAA,CAAA,QAAQ,GAAG,KAAK,CAAC;QAWvB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,SAAS,EAAC,MAAM,CAAC,EAAE;YACf,MAAM,WAAW,GAAG,MAAqB,CAAC;YAC1C,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,MAAM,EAAE,CAAC;QAClB,CAAC,CAAC,CAAC;QACH,OAAO,EAAC,KAAK,CAAC,EAAE;YACZ,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAC5B,IAAI,CAAC,MAAM,EAAE,CAAC;QAClB,CAAC,CAAC,CAAC;IACP,CAAC;IAED,SAAS,GAAA;QACL,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,qOAAkB,CAAC,CAAC;QACzC,IAAI,CAAC,UAAU,EAAE,CAAC;IACtB,CAAC;IAED,IAAI,GAAA;QACA,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACxB,CAAC;IAED,MAAM,GAAA;QACF,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;IAC/B,CAAC;IAED,KAAK,CAAC,IAAY,EAAA;QACd,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAChB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;QAC7C,CAAC;QACD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,2NAAQ,EAAE,CAAC;QAC/B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACvB,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;IACjC,CAAC;CACJ"}},
    {"offset": {"line": 8541, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/workspace-lock.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/workspace-lock.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { type AbstractCancellationTokenSource, CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';\r\nimport { Deferred, isOperationCancelled, startCancelableOperation, type MaybePromise } from '../utils/promise-utils.js';\r\n\r\n/**\r\n * Utility service to execute mutually exclusive actions.\r\n */\r\nexport interface WorkspaceLock {\r\n    /**\r\n     * Performs a single async action, like initializing the workspace or processing document changes.\r\n     * Only one action will be executed at a time.\r\n     *\r\n     * When another action is queued up, the token provided for the action will be cancelled.\r\n     * Assuming the action makes use of this token, the next action only has to wait for the current action to finish cancellation.\r\n     */\r\n    write(action: (token: CancellationToken) => MaybePromise<void>): Promise<void>;\r\n\r\n    /**\r\n     * Performs a single action, like computing completion results or providing workspace symbols.\r\n     * Read actions will only be executed after all write actions have finished. They will be executed in parallel if possible.\r\n     *\r\n     * If a write action is currently running, the read action will be queued up and executed afterwards.\r\n     * If a new write action is queued up while a read action is waiting, the write action will receive priority and will be handled before the read action.\r\n     *\r\n     * Note that read actions are not allowed to modify anything in the workspace. Please use {@link write} instead.\r\n     */\r\n    read<T>(action: () => MaybePromise<T>): Promise<T>;\r\n\r\n    /**\r\n     * Cancels the last queued write action. All previous write actions already have been cancelled.\r\n     */\r\n    cancelWrite(): void;\r\n}\r\n\r\ntype LockAction<T = void> = (token: CancellationToken) => MaybePromise<T>;\r\n\r\ninterface LockEntry {\r\n    action: LockAction<unknown>;\r\n    deferred: Deferred<unknown>;\r\n    cancellationToken: CancellationToken;\r\n}\r\n\r\nexport class DefaultWorkspaceLock implements WorkspaceLock {\r\n\r\n    private previousTokenSource: AbstractCancellationTokenSource = new CancellationTokenSource();\r\n    private writeQueue: LockEntry[] = [];\r\n    private readQueue: LockEntry[] = [];\r\n    private done = true;\r\n\r\n    write(action: (token: CancellationToken) => MaybePromise<void>): Promise<void> {\r\n        this.cancelWrite();\r\n        const tokenSource = startCancelableOperation();\r\n        this.previousTokenSource = tokenSource;\r\n        return this.enqueue(this.writeQueue, action, tokenSource.token);\r\n    }\r\n\r\n    read<T>(action: () => MaybePromise<T>): Promise<T> {\r\n        return this.enqueue(this.readQueue, action);\r\n    }\r\n\r\n    private enqueue<T = void>(queue: LockEntry[], action: LockAction<T>, cancellationToken = CancellationToken.None): Promise<T> {\r\n        const deferred = new Deferred<unknown>();\r\n        const entry: LockEntry = {\r\n            action,\r\n            deferred,\r\n            cancellationToken\r\n        };\r\n        queue.push(entry);\r\n        this.performNextOperation();\r\n        return deferred.promise as Promise<T>;\r\n    }\r\n\r\n    private async performNextOperation(): Promise<void> {\r\n        if (!this.done) {\r\n            return;\r\n        }\r\n        const entries: LockEntry[] = [];\r\n        if (this.writeQueue.length > 0) {\r\n            // Just perform the next write action\r\n            entries.push(this.writeQueue.shift()!);\r\n        } else if (this.readQueue.length > 0) {\r\n            // Empty the read queue and perform all actions in parallel\r\n            entries.push(...this.readQueue.splice(0, this.readQueue.length));\r\n        } else {\r\n            return;\r\n        }\r\n        this.done = false;\r\n        await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\r\n            try {\r\n                // Move the execution of the action to the next event loop tick via `Promise.resolve()`\r\n                const result = await Promise.resolve().then(() => action(cancellationToken));\r\n                deferred.resolve(result);\r\n            } catch (err) {\r\n                if (isOperationCancelled(err)) {\r\n                    // If the operation was cancelled, we don't want to reject the promise\r\n                    deferred.resolve(undefined);\r\n                } else {\r\n                    deferred.reject(err);\r\n                }\r\n            }\r\n        }));\r\n        this.done = true;\r\n        this.performNextOperation();\r\n    }\r\n\r\n    cancelWrite(): void {\r\n        this.previousTokenSource.cancel();\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8620, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/serializer/hydrator.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/serializer/hydrator.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2024 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nimport type { TokenType } from 'chevrotain';\r\nimport { CompositeCstNodeImpl, LeafCstNodeImpl, RootCstNodeImpl } from '../parser/cst-node-builder.js';\r\nimport { isAbstractElement, type AbstractElement, type Grammar } from '../languages/generated/ast.js';\r\nimport type { Linker } from '../references/linker.js';\r\nimport type { Lexer } from '../parser/lexer.js';\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { ParseResult } from '../parser/langium-parser.js';\r\nimport type { Reference, AstNode, CstNode, LeafCstNode, GenericAstNode, Mutable, RootCstNode } from '../syntax-tree.js';\r\nimport { isRootCstNode, isCompositeCstNode, isLeafCstNode, isAstNode, isReference } from '../syntax-tree.js';\r\nimport { streamAst } from '../utils/ast-utils.js';\r\nimport { BiMap } from '../utils/collections.js';\r\nimport { streamCst } from '../utils/cst-utils.js';\r\nimport type { LexingReport } from '../parser/token-builder.js';\r\n\r\n/**\r\n * The hydrator service is responsible for allowing AST parse results to be sent across worker threads.\r\n */\r\nexport interface Hydrator {\r\n    /**\r\n     * Converts a parse result to a plain object. The resulting object can be sent across worker threads.\r\n     */\r\n    dehydrate(result: ParseResult<AstNode>): ParseResult<object>;\r\n    /**\r\n     * Converts a plain object to a parse result. The included AST node can then be used in the main thread.\r\n     * Calling this method on objects that have not been dehydrated first will result in undefined behavior.\r\n     */\r\n    hydrate<T extends AstNode = AstNode>(result: ParseResult<object>): ParseResult<T>;\r\n}\r\n\r\nexport interface DehydrateContext {\r\n    astNodes: Map<AstNode, any>;\r\n    cstNodes: Map<CstNode, any>;\r\n}\r\n\r\nexport interface HydrateContext {\r\n    astNodes: Map<any, AstNode>;\r\n    cstNodes: Map<any, CstNode>;\r\n}\r\n\r\nexport class DefaultHydrator implements Hydrator {\r\n\r\n    protected readonly grammar: Grammar;\r\n    protected readonly lexer: Lexer;\r\n    protected readonly linker: Linker;\r\n\r\n    protected readonly grammarElementIdMap = new BiMap<AbstractElement, number>();\r\n    protected readonly tokenTypeIdMap = new BiMap<number, TokenType>();\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.grammar = services.Grammar;\r\n        this.lexer = services.parser.Lexer;\r\n        this.linker = services.references.Linker;\r\n    }\r\n\r\n    dehydrate(result: ParseResult<AstNode>): ParseResult<object> {\r\n        return {\r\n            lexerErrors: result.lexerErrors,\r\n            lexerReport: result.lexerReport ? this.dehydrateLexerReport(result.lexerReport) : undefined,\r\n            // We need to create shallow copies of the errors\r\n            // The original errors inherit from the `Error` class, which is not transferable across worker threads\r\n            parserErrors: result.parserErrors.map(e => ({ ...e, message: e.message })),\r\n            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\r\n        };\r\n    }\r\n\r\n    protected dehydrateLexerReport(lexerReport: LexingReport): LexingReport {\r\n        // By default, lexer reports are serializable\r\n        return lexerReport;\r\n    }\r\n\r\n    protected createDehyrationContext(node: AstNode): DehydrateContext {\r\n        const astNodes = new Map<AstNode, any>();\r\n        const cstNodes = new Map<CstNode, any>();\r\n        for (const astNode of streamAst(node)) {\r\n            astNodes.set(astNode, {});\r\n        }\r\n        if (node.$cstNode) {\r\n            for (const cstNode of streamCst(node.$cstNode)) {\r\n                cstNodes.set(cstNode, {});\r\n            }\r\n        }\r\n        return {\r\n            astNodes,\r\n            cstNodes\r\n        };\r\n    }\r\n\r\n    protected dehydrateAstNode(node: AstNode, context: DehydrateContext): object {\r\n        const obj = context.astNodes.get(node) as Record<string, any>;\r\n        obj.$type = node.$type;\r\n        obj.$containerIndex = node.$containerIndex;\r\n        obj.$containerProperty = node.$containerProperty;\r\n        if (node.$cstNode !== undefined) {\r\n            obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\r\n        }\r\n        for (const [name, value] of Object.entries(node)) {\r\n            if (name.startsWith('$')) {\r\n                continue;\r\n            }\r\n            if (Array.isArray(value)) {\r\n                const arr: any[] = [];\r\n                obj[name] = arr;\r\n                for (const item of value) {\r\n                    if (isAstNode(item)) {\r\n                        arr.push(this.dehydrateAstNode(item, context));\r\n                    } else if (isReference(item)) {\r\n                        arr.push(this.dehydrateReference(item, context));\r\n                    } else {\r\n                        arr.push(item);\r\n                    }\r\n                }\r\n            } else if (isAstNode(value)) {\r\n                obj[name] = this.dehydrateAstNode(value, context);\r\n            } else if (isReference(value)) {\r\n                obj[name] = this.dehydrateReference(value, context);\r\n            } else if (value !== undefined) {\r\n                obj[name] = value;\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n\r\n    protected dehydrateReference(reference: Reference, context: DehydrateContext): any {\r\n        const obj: Record<string, unknown> = {};\r\n        obj.$refText = reference.$refText;\r\n        if (reference.$refNode) {\r\n            obj.$refNode = context.cstNodes.get(reference.$refNode);\r\n        }\r\n        return obj;\r\n    }\r\n\r\n    protected dehydrateCstNode(node: CstNode, context: DehydrateContext): any {\r\n        const cstNode = context.cstNodes.get(node) as Record<string, any>;\r\n        if (isRootCstNode(node)) {\r\n            cstNode.fullText = node.fullText;\r\n        } else {\r\n            // Note: This returns undefined for hidden nodes (i.e. comments)\r\n            cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\r\n        }\r\n        cstNode.hidden = node.hidden;\r\n        cstNode.astNode = context.astNodes.get(node.astNode);\r\n        if (isCompositeCstNode(node)) {\r\n            cstNode.content = node.content.map(child => this.dehydrateCstNode(child, context));\r\n        } else if (isLeafCstNode(node)) {\r\n            cstNode.tokenType = node.tokenType.name;\r\n            cstNode.offset = node.offset;\r\n            cstNode.length = node.length;\r\n            cstNode.startLine = node.range.start.line;\r\n            cstNode.startColumn = node.range.start.character;\r\n            cstNode.endLine = node.range.end.line;\r\n            cstNode.endColumn = node.range.end.character;\r\n        }\r\n        return cstNode;\r\n    }\r\n\r\n    hydrate<T extends AstNode = AstNode>(result: ParseResult<object>): ParseResult<T> {\r\n        const node = result.value;\r\n        const context = this.createHydrationContext(node);\r\n        if ('$cstNode' in node) {\r\n            this.hydrateCstNode(node.$cstNode, context);\r\n        }\r\n        return {\r\n            lexerErrors: result.lexerErrors,\r\n            lexerReport: result.lexerReport,\r\n            parserErrors: result.parserErrors,\r\n            value: this.hydrateAstNode(node, context) as T\r\n        };\r\n    }\r\n\r\n    protected createHydrationContext(node: any): HydrateContext {\r\n        const astNodes = new Map<any, AstNode>();\r\n        const cstNodes = new Map<any, CstNode>();\r\n        for (const astNode of streamAst(node)) {\r\n            astNodes.set(astNode, {} as AstNode);\r\n        }\r\n        let root: RootCstNode;\r\n        if (node.$cstNode) {\r\n            for (const cstNode of streamCst(node.$cstNode)) {\r\n                let cst: Mutable<CstNode> | undefined;\r\n                if ('fullText' in cstNode) {\r\n                    cst = new RootCstNodeImpl(cstNode.fullText as string);\r\n                    root = cst as RootCstNode;\r\n                } else if ('content' in cstNode) {\r\n                    cst = new CompositeCstNodeImpl();\r\n                } else if ('tokenType' in cstNode) {\r\n                    cst = this.hydrateCstLeafNode(cstNode);\r\n                }\r\n                if (cst) {\r\n                    cstNodes.set(cstNode, cst);\r\n                    cst.root = root!;\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            astNodes,\r\n            cstNodes\r\n        };\r\n    }\r\n\r\n    protected hydrateAstNode(node: any, context: HydrateContext): AstNode {\r\n        const astNode = context.astNodes.get(node) as Mutable<GenericAstNode>;\r\n        astNode.$type = node.$type;\r\n        astNode.$containerIndex = node.$containerIndex;\r\n        astNode.$containerProperty = node.$containerProperty;\r\n        if (node.$cstNode) {\r\n            astNode.$cstNode = context.cstNodes.get(node.$cstNode);\r\n        }\r\n        for (const [name, value] of Object.entries(node)) {\r\n            if (name.startsWith('$')) {\r\n                continue;\r\n            }\r\n            if (Array.isArray(value)) {\r\n                const arr: unknown[] = [];\r\n                astNode[name] = arr;\r\n                for (const item of value) {\r\n                    if (isAstNode(item)) {\r\n                        arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\r\n                    } else if (isReference(item)) {\r\n                        arr.push(this.hydrateReference(item, astNode, name, context));\r\n                    } else {\r\n                        arr.push(item);\r\n                    }\r\n                }\r\n            } else if (isAstNode(value)) {\r\n                astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\r\n            } else if (isReference(value)) {\r\n                astNode[name] = this.hydrateReference(value, astNode, name, context);\r\n            } else if (value !== undefined) {\r\n                astNode[name] = value;\r\n            }\r\n        }\r\n        return astNode;\r\n    }\r\n\r\n    protected setParent(node: any, parent: any): any {\r\n        node.$container = parent as AstNode;\r\n        return node;\r\n    }\r\n\r\n    protected hydrateReference(reference: any, node: AstNode, name: string, context: HydrateContext): Reference {\r\n        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode)!, reference.$refText);\r\n    }\r\n\r\n    protected hydrateCstNode(cstNode: any, context: HydrateContext, num = 0): CstNode {\r\n        const cstNodeObj = context.cstNodes.get(cstNode) as Mutable<CstNode>;\r\n        if (typeof cstNode.grammarSource === 'number') {\r\n            cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\r\n        }\r\n        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode)!;\r\n        if (isCompositeCstNode(cstNodeObj)) {\r\n            for (const child of cstNode.content) {\r\n                const hydrated = this.hydrateCstNode(child, context, num++);\r\n                cstNodeObj.content.push(hydrated);\r\n            }\r\n        }\r\n        return cstNodeObj;\r\n    }\r\n\r\n    protected hydrateCstLeafNode(cstNode: any): LeafCstNode {\r\n        const tokenType = this.getTokenType(cstNode.tokenType);\r\n        const offset = cstNode.offset;\r\n        const length = cstNode.length;\r\n        const startLine = cstNode.startLine;\r\n        const startColumn = cstNode.startColumn;\r\n        const endLine = cstNode.endLine;\r\n        const endColumn = cstNode.endColumn;\r\n        const hidden = cstNode.hidden;\r\n        const node = new LeafCstNodeImpl(\r\n            offset,\r\n            length,\r\n            {\r\n                start: {\r\n                    line: startLine,\r\n                    character: startColumn\r\n                },\r\n                end: {\r\n                    line: endLine,\r\n                    character: endColumn\r\n                }\r\n            },\r\n            tokenType,\r\n            hidden\r\n        );\r\n        return node;\r\n    }\r\n\r\n    protected getTokenType(name: string): TokenType {\r\n        return this.lexer.definition[name];\r\n    }\r\n\r\n    protected getGrammarElementId(node: AbstractElement | undefined): number | undefined {\r\n        if (!node) {\r\n            return undefined;\r\n        }\r\n        if (this.grammarElementIdMap.size === 0) {\r\n            this.createGrammarElementIdMap();\r\n        }\r\n        return this.grammarElementIdMap.get(node);\r\n    }\r\n\r\n    protected getGrammarElement(id: number): AbstractElement | undefined {\r\n        if (this.grammarElementIdMap.size === 0) {\r\n            this.createGrammarElementIdMap();\r\n        }\r\n        const element = this.grammarElementIdMap.getKey(id);\r\n        return element;\r\n    }\r\n\r\n    protected createGrammarElementIdMap(): void {\r\n        let id = 0;\r\n        for (const element of streamAst(this.grammar)) {\r\n            if (isAbstractElement(element)) {\r\n                this.grammarElementIdMap.set(element, id++);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8895, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/default-module.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/default-module.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n******************************************************************************/\r\n\r\nimport type { Module } from './dependency-injection.js';\r\nimport type { LangiumDefaultCoreServices, LangiumDefaultSharedCoreServices, LangiumCoreServices, LangiumSharedCoreServices } from './services.js';\r\nimport type { FileSystemProvider } from './workspace/file-system-provider.js';\r\nimport { createGrammarConfig } from './languages/grammar-config.js';\r\nimport { createCompletionParser } from './parser/completion-parser-builder.js';\r\nimport { createLangiumParser } from './parser/langium-parser-builder.js';\r\nimport { DefaultTokenBuilder } from './parser/token-builder.js';\r\nimport { DefaultValueConverter } from './parser/value-converter.js';\r\nimport { DefaultLinker } from './references/linker.js';\r\nimport { DefaultNameProvider } from './references/name-provider.js';\r\nimport { DefaultReferences } from './references/references.js';\r\nimport { DefaultScopeComputation } from './references/scope-computation.js';\r\nimport { DefaultScopeProvider } from './references/scope-provider.js';\r\nimport { DefaultJsonSerializer } from './serializer/json-serializer.js';\r\nimport { DefaultServiceRegistry } from './service-registry.js';\r\nimport { DefaultDocumentValidator } from './validation/document-validator.js';\r\nimport { ValidationRegistry } from './validation/validation-registry.js';\r\nimport { DefaultAstNodeDescriptionProvider, DefaultReferenceDescriptionProvider } from './workspace/ast-descriptions.js';\r\nimport { DefaultAstNodeLocator } from './workspace/ast-node-locator.js';\r\nimport { DefaultConfigurationProvider } from './workspace/configuration.js';\r\nimport { DefaultDocumentBuilder } from './workspace/document-builder.js';\r\nimport { DefaultLangiumDocumentFactory, DefaultLangiumDocuments } from './workspace/documents.js';\r\nimport { DefaultIndexManager } from './workspace/index-manager.js';\r\nimport { DefaultWorkspaceManager } from './workspace/workspace-manager.js';\r\nimport { DefaultLexer, DefaultLexerErrorMessageProvider } from './parser/lexer.js';\r\nimport { JSDocDocumentationProvider } from './documentation/documentation-provider.js';\r\nimport { DefaultCommentProvider } from './documentation/comment-provider.js';\r\nimport { LangiumParserErrorMessageProvider } from './parser/langium-parser.js';\r\nimport { DefaultAsyncParser } from './parser/async-parser.js';\r\nimport { DefaultWorkspaceLock } from './workspace/workspace-lock.js';\r\nimport { DefaultHydrator } from './serializer/hydrator.js';\r\n\r\n/**\r\n * Context required for creating the default language-specific dependency injection module.\r\n */\r\nexport interface DefaultCoreModuleContext {\r\n    shared: LangiumSharedCoreServices;\r\n}\r\n\r\n/**\r\n * Creates a dependency injection module configuring the default core services.\r\n * This is a set of services that are dedicated to a specific language.\r\n */\r\nexport function createDefaultCoreModule(context: DefaultCoreModuleContext): Module<LangiumCoreServices, LangiumDefaultCoreServices> {\r\n    return {\r\n        documentation: {\r\n            CommentProvider: (services) => new DefaultCommentProvider(services),\r\n            DocumentationProvider: (services) => new JSDocDocumentationProvider(services)\r\n        },\r\n        parser: {\r\n            AsyncParser: (services) => new DefaultAsyncParser(services),\r\n            GrammarConfig: (services) => createGrammarConfig(services),\r\n            LangiumParser: (services) => createLangiumParser(services),\r\n            CompletionParser: (services) => createCompletionParser(services),\r\n            ValueConverter: () => new DefaultValueConverter(),\r\n            TokenBuilder: () => new DefaultTokenBuilder(),\r\n            Lexer: (services) => new DefaultLexer(services),\r\n            ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider(),\r\n            LexerErrorMessageProvider: () => new DefaultLexerErrorMessageProvider()\r\n        },\r\n        workspace: {\r\n            AstNodeLocator: () => new DefaultAstNodeLocator(),\r\n            AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),\r\n            ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)\r\n        },\r\n        references: {\r\n            Linker: (services) => new DefaultLinker(services),\r\n            NameProvider: () => new DefaultNameProvider(),\r\n            ScopeProvider: (services) => new DefaultScopeProvider(services),\r\n            ScopeComputation: (services) => new DefaultScopeComputation(services),\r\n            References: (services) => new DefaultReferences(services)\r\n        },\r\n        serializer: {\r\n            Hydrator: (services) => new DefaultHydrator(services),\r\n            JsonSerializer: (services) => new DefaultJsonSerializer(services)\r\n        },\r\n        validation: {\r\n            DocumentValidator: (services) => new DefaultDocumentValidator(services),\r\n            ValidationRegistry: (services) => new ValidationRegistry(services)\r\n        },\r\n        shared: () => context.shared\r\n    };\r\n}\r\n\r\n/**\r\n * Context required for creating the default shared dependency injection module.\r\n */\r\nexport interface DefaultSharedCoreModuleContext {\r\n    /**\r\n     * Factory function to create a {@link FileSystemProvider}.\r\n     *\r\n     * Langium exposes an `EmptyFileSystem` and `NodeFileSystem`, exported through `langium/node`.\r\n     * When running Langium as part of a vscode language server or a Node.js app, using the `NodeFileSystem` is recommended,\r\n     * the `EmptyFileSystem` in every other use case.\r\n     */\r\n    fileSystemProvider: (services: LangiumSharedCoreServices) => FileSystemProvider;\r\n}\r\n\r\n/**\r\n * Creates a dependency injection module configuring the default shared core services.\r\n * This is the set of services that are shared between multiple languages.\r\n */\r\nexport function createDefaultSharedCoreModule(context: DefaultSharedCoreModuleContext): Module<LangiumSharedCoreServices, LangiumDefaultSharedCoreServices> {\r\n    return {\r\n        ServiceRegistry: (services) => new DefaultServiceRegistry(services),\r\n        workspace: {\r\n            LangiumDocuments: (services) => new DefaultLangiumDocuments(services),\r\n            LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),\r\n            DocumentBuilder: (services) => new DefaultDocumentBuilder(services),\r\n            IndexManager: (services) => new DefaultIndexManager(services),\r\n            WorkspaceManager: (services) => new DefaultWorkspaceManager(services),\r\n            FileSystemProvider: (services) => context.fileSystemProvider(services),\r\n            WorkspaceLock: () => new DefaultWorkspaceLock(),\r\n            ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)\r\n        }\r\n    };\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9020, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/dependency-injection.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/dependency-injection.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\n/**\r\n * A `Module<I>` is a description of possibly grouped service factories.\r\n *\r\n * Given a type I = { group: { service: A } },\r\n * Module<I> := { group: { service: (injector: I) => A } }\r\n *\r\n * Making `I` available during the creation of `I` allows us to create cyclic\r\n * dependencies.\r\n */\r\nexport type Module<I, T = I> = {\r\n    [K in keyof T]: Module<I, T[K]> | ((injector: I) => T[K])\r\n}\r\n\r\nexport namespace Module {\r\n    export const merge = <M1, M2, R extends M1 & M2>(m1: Module<R, M1>, m2: Module<R, M2>) => (_merge(_merge({}, m1), m2) as Module<R, M1 & M2>);\r\n}\r\n\r\n/**\r\n * Given a set of modules, the inject function returns a lazily evaluated injector\r\n * that injects dependencies into the requested service when it is requested the\r\n * first time. Subsequent requests will return the same service.\r\n *\r\n * In the case of cyclic dependencies, an Error will be thrown. This can be fixed\r\n * by injecting a provider `() => T` instead of a `T`.\r\n *\r\n * Please note that the arguments may be objects or arrays. However, the result will\r\n * be an object. Using it with for..of will have no effect.\r\n *\r\n * @param module1 first Module\r\n * @param module2 (optional) second Module\r\n * @param module3 (optional) third Module\r\n * @param module4 (optional) fourth Module\r\n * @param module5 (optional) fifth Module\r\n * @param module6 (optional) sixth Module\r\n * @param module7 (optional) seventh Module\r\n * @param module8 (optional) eighth Module\r\n * @param module9 (optional) ninth Module\r\n * @returns a new object of type I\r\n */\r\nexport function inject<I1, I2, I3, I4, I5, I6, I7, I8, I9, I extends I1 & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9>(\r\n    module1: Module<I, I1>, module2?: Module<I, I2>, module3?: Module<I, I3>, module4?: Module<I, I4>, module5?: Module<I, I5>, module6?: Module<I, I6>, module7?: Module<I, I7>, module8?: Module<I, I8>, module9?: Module<I, I9>\r\n): I {\r\n    const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {}) as Module<I>;\r\n    return _inject(module);\r\n}\r\n\r\nconst isProxy = Symbol('isProxy');\r\n\r\n/**\r\n * Eagerly load all services in the given dependency injection container. This is sometimes\r\n * necessary because services can register event listeners in their constructors.\r\n */\r\nexport function eagerLoad<T>(item: T): T {\r\n    if (item && (item as any)[isProxy]) {\r\n        for (const value of Object.values(item)) {\r\n            eagerLoad(value);\r\n        }\r\n    }\r\n    return item;\r\n}\r\n\r\n/**\r\n * Helper function that returns an injector by creating a proxy.\r\n * Invariant: injector is of type I. If injector is undefined, then T = I.\r\n */\r\nfunction _inject<I, T>(module: Module<I, T>, injector?: any): T {\r\n    const proxy: any = new Proxy({} as any, {\r\n        deleteProperty: () => false,\r\n        set: () => {\r\n            throw new Error('Cannot set property on injected service container');\r\n        },\r\n        get: (obj, prop) => {\r\n            if (prop === isProxy) {\r\n                return true;\r\n            } else {\r\n                return _resolve(obj, prop, module, injector || proxy);\r\n            }\r\n        },\r\n        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in\r\n        has: (_, prop) => prop in module, // used by ..in..\r\n        ownKeys: () => [...Object.getOwnPropertyNames(module)] // used by for..in\r\n    });\r\n    return proxy;\r\n}\r\n\r\n/**\r\n * Internally used to tag a requested dependency, directly before calling the factory.\r\n * This allows us to find cycles during instance creation.\r\n */\r\nconst __requested__ = Symbol();\r\n\r\n/**\r\n * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from\r\n * the module description. The result of service factories is cached. Groups are\r\n * recursively proxied.\r\n *\r\n * @param obj an object holding all group proxies and services\r\n * @param prop the key of a value within obj\r\n * @param module an object containing groups and service factories\r\n * @param injector the first level proxy that provides access to all values\r\n * @returns the requested value `obj[prop]`\r\n * @throws Error if a dependency cycle is detected\r\n */\r\nfunction _resolve<I, T>(obj: any, prop: string | symbol | number, module: Module<I, T>, injector: I): T[keyof T] | undefined {\r\n    if (prop in obj) {\r\n        if (obj[prop] instanceof Error) {\r\n            throw new Error('Construction failure. Please make sure that your dependencies are constructable.', {cause: obj[prop]});\r\n        }\r\n        if (obj[prop] === __requested__) {\r\n            throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');\r\n        }\r\n        return obj[prop];\r\n    } else if (prop in module) {\r\n        const value: Module<I, T[keyof T]> | ((injector: I) => T[keyof T]) = module[prop as keyof T];\r\n        obj[prop] = __requested__;\r\n        try {\r\n            obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);\r\n        } catch (error) {\r\n            obj[prop] = error instanceof Error ? error : undefined;\r\n            throw error;\r\n        }\r\n        return obj[prop];\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Performs a deep-merge of two modules by writing source entries into the target module.\r\n *\r\n * @param target the module which is written\r\n * @param source the module which is read\r\n * @returns the target module\r\n */\r\nfunction _merge(target: Module<any>, source?: Module<any>): Module<unknown> {\r\n    if (source) {\r\n        for (const [key, value2] of Object.entries(source)) {\r\n            if (value2 !== undefined) {\r\n                const value1 = target[key];\r\n                if (value1 !== null && value2 !== null && typeof value1 === 'object' && typeof value2 === 'object') {\r\n                    target[key] = _merge(value1, value2);\r\n                } else {\r\n                    target[key] = value2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9148, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/workspace/file-system-provider.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/workspace/file-system-provider.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { URI } from '../utils/uri-utils.js';\r\n\r\nexport interface FileSystemNode {\r\n    readonly isFile: boolean;\r\n    readonly isDirectory: boolean;\r\n    readonly uri: URI;\r\n}\r\n\r\nexport type FileSystemFilter = (node: FileSystemNode) => boolean;\r\n\r\n/**\r\n * Provides methods to interact with an abstract file system. The default implementation is based on the node.js `fs` API.\r\n */\r\nexport interface FileSystemProvider {\r\n    /**\r\n     * Reads a document asynchronously from a given URI.\r\n     * @returns The string content of the file with the specified URI.\r\n     */\r\n    readFile(uri: URI): Promise<string>;\r\n    /**\r\n     * Reads the directory information for the given URI.\r\n     * @returns The list of file system entries that are contained within the specified directory.\r\n     */\r\n    readDirectory(uri: URI): Promise<FileSystemNode[]>;\r\n}\r\n\r\nexport class EmptyFileSystemProvider implements FileSystemProvider {\r\n\r\n    readFile(): Promise<string> {\r\n        throw new Error('No file system is available.');\r\n    }\r\n\r\n    async readDirectory(): Promise<FileSystemNode[]> {\r\n        return [];\r\n    }\r\n\r\n}\r\n\r\nexport const EmptyFileSystem = {\r\n    fileSystemProvider: () => new EmptyFileSystemProvider()\r\n};\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;AA4B1E,MAAO,uBAAuB;IAEhC,QAAQ,GAAA;QACJ,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,aAAa,GAAA;QACf,OAAO,EAAE,CAAC;IACd,CAAC;CAEJ;AAEM,MAAM,eAAe,GAAG;IAC3B,kBAAkB,EAAE,GAAG,CAAG,CAAD,GAAK,uBAAuB,EAAE;CAC1D,CAAC"}},
    {"offset": {"line": 9173, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/langium@3.3.1/node_modules/langium/lib/utils/grammar-loader.js","sources":["file:///D:/%E8%AE%BE%E8%AE%A1/bkl-ite-cloud-redesign/node_modules/.pnpm/langium%403.3.1/node_modules/langium/src/utils/grammar-loader.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { createDefaultCoreModule, createDefaultSharedCoreModule } from '../default-module.js';\r\nimport type { Module } from '../dependency-injection.js';\r\nimport { inject } from '../dependency-injection.js';\r\nimport * as ast from '../languages/generated/ast.js';\r\nimport type { LangiumCoreServices, LangiumSharedCoreServices, PartialLangiumCoreServices, PartialLangiumSharedCoreServices } from '../services.js';\r\nimport type { Mutable } from '../syntax-tree.js';\r\nimport { EmptyFileSystem } from '../workspace/file-system-provider.js';\r\nimport { URI } from './uri-utils.js';\r\n\r\nconst minimalGrammarModule: Module<LangiumCoreServices, PartialLangiumCoreServices> = {\r\n    Grammar: () => undefined as unknown as ast.Grammar,\r\n    LanguageMetaData: () => ({\r\n        caseInsensitive: false,\r\n        fileExtensions: ['.langium'],\r\n        languageId: 'langium'\r\n    })\r\n};\r\n\r\nconst minimalSharedGrammarModule: Module<LangiumSharedCoreServices, PartialLangiumSharedCoreServices> = {\r\n    AstReflection: () => new ast.LangiumGrammarAstReflection()\r\n};\r\n\r\nfunction createMinimalGrammarServices(): LangiumCoreServices {\r\n    const shared = inject(\r\n        createDefaultSharedCoreModule(EmptyFileSystem),\r\n        minimalSharedGrammarModule\r\n    );\r\n    const grammar = inject(\r\n        createDefaultCoreModule({ shared }),\r\n        minimalGrammarModule\r\n    );\r\n    shared.ServiceRegistry.register(grammar);\r\n    return grammar;\r\n}\r\n\r\n/**\r\n * Load a Langium grammar for your language from a JSON string. This is used by several services,\r\n * most notably the parser builder which interprets the grammar to create a parser.\r\n */\r\nexport function loadGrammarFromJson(json: string): ast.Grammar {\r\n    const services = createMinimalGrammarServices();\r\n    const astNode = services.serializer.JsonSerializer.deserialize(json) as Mutable<ast.Grammar>;\r\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI.parse(`memory://${astNode.name ?? 'grammar'}.langium`));\r\n    return astNode;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAEhF,OAAO,EAAE,uBAAuB,EAAE,6BAA6B,EAAE,MAAM,sBAAsB,CAAC;AAE9F,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;AACpD,OAAO,KAAK,GAAG,MAAM,+BAA+B,CAAC;AAGrD,OAAO,EAAE,eAAe,EAAE,MAAM,sCAAsC,CAAC;AACvE,OAAO,EAAE,GAAG,EAAE,MAAM,gBAAgB,CAAC;;;;;;AAErC,MAAM,oBAAoB,GAA4D;IAClF,OAAO,EAAE,GAAG,CAAG,CAAD,QAAoC;IAClD,gBAAgB,EAAE,GAAG,CAAG,CAAD,AAAE;YACrB,eAAe,EAAE,KAAK;YACtB,cAAc,EAAE;gBAAC,UAAU;aAAC;YAC5B,UAAU,EAAE,SAAS;SACxB,CAAC;CACL,CAAC;AAEF,MAAM,0BAA0B,GAAwE;IACpG,aAAa,EAAE,GAAG,CAAG,CAAD,GAAK,GAAG,CAAC,8OAA2B,EAAE;CAC7D,CAAC;AAEF,SAAS,4BAA4B;IACjC,MAAM,MAAM,OAAG,uNAAM,MACjB,wOAA6B,EAAC,gPAAe,CAAC,EAC9C,0BAA0B,CAC7B,CAAC;IACF,MAAM,OAAO,OAAG,uNAAM,MAClB,kOAAuB,EAAC;QAAE,MAAM;IAAA,CAAE,CAAC,EACnC,oBAAoB,CACvB,CAAC;IACF,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IACzC,OAAO,OAAO,CAAC;AACnB,CAAC;AAMK,SAAU,mBAAmB,CAAC,IAAY;;IAC5C,MAAM,QAAQ,GAAG,4BAA4B,EAAE,CAAC;IAChD,MAAM,OAAO,GAAG,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,CAAyB,CAAC;IAC7F,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,sBAAsB,CAAC,SAAS,CAAC,OAAO,EAAE,sNAAG,CAAC,KAAK,CAAC,CAAA,SAAA,EAAY,CAAA,KAAA,OAAO,CAAC,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,SAAS,CAAA,QAAA,CAAU,CAAC,CAAC,CAAC;IAChI,OAAO,OAAO,CAAC;AACnB,CAAC"}}]
}